import { app } from "../../../scripts/app.js";
import { api } from "../../../scripts/api.js";
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$2(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return ((str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  });
};
const camelizeRE = /-\w/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c2) => c2.slice(1).toUpperCase());
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s2 = str ? `on${capitalize$1(str)}` : ``;
    return s2;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$2(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value) || isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$2(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString$1 = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$1(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString$1(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$2(val) && !isArray$1(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i2 = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i2, l2;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].pause();
        }
      }
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i2, l2;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].resume();
          }
        }
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      this.effects.length = 0;
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err2) {
          if (!error) error = err2;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value;
      dep.version++;
    }
  } catch (err2) {
    dep.version++;
    throw err2;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
        removeSub(l2, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
        addSub(l2);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$1(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
function toWrapped(target, item) {
  if (isReadonly(target)) {
    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
  }
  return toReactive(item);
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x2) => isArray$1(x2) ? reactiveReadArray(x2) : x2)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toWrapped(this, value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply$1(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply$1(
      this,
      "filter",
      fn,
      thisArg,
      (v2) => v2.map((item) => toWrapped(this, item)),
      arguments
    );
  },
  find(fn, thisArg) {
    return apply$1(
      this,
      "find",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findIndex(fn, thisArg) {
    return apply$1(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply$1(
      this,
      "findLast",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findLastIndex(fn, thisArg) {
    return apply$1(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply$1(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply$1(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply$1(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", (item) => toWrapped(this, item));
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply$1(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toWrapped(self2, item), index, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toWrapped(self2, item), index, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty$1(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value = targetIsArray && isIntegerKey(key) ? res : res.value;
      return isReadonly2 && isObject$2(value) ? readonly(value) : value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    const isArrayWithIntegerKey = isArray$1(target) && isIntegerKey(key);
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return true;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn$1(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$1(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn$1(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$1(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return reactiveGetter(s2);
      } else if (isFunction$1(s2)) {
        return call ? call(s2, 2) : s2();
      } else ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Map();
  if ((seen.get(value) || 0) >= depth) {
    return value;
  }
  seen.set(value, depth);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, depth, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a2) => {
          var _a, _b;
          return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close2 = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$2(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err2) {
    handleError(err2, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err2) => {
        handleError(err2, instance, type);
      });
    }
    return res;
  }
  if (isArray$1(fn)) {
    const values = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
    }
    return values;
  }
}
function handleError(err2, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err2, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err2,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err2, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err2, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err2;
  } else {
    console.error(err2);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i2 = flushIndex + 1) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b2) => getId(a2) - getId(b2)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled2 = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (parentComponent && parentComponent.isCE) {
            (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
          }
          if (!disabled2) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled2) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled2) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled2);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
    vnode2.anchor = hydrateChildren(
      nextSibling(node2),
      vnode2,
      parentNode(node2),
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    vnode2.targetStart = targetStart;
    vnode2.targetAnchor = targetAnchor;
  }
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  const disabled2 = isTeleportDisabled(vnode.props);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled2) {
        hydrateDisabledTeleport(
          node,
          vnode,
          targetNode,
          targetNode && nextSibling(targetNode)
        );
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled2);
  } else if (disabled2) {
    if (vnode.shapeFlag & 16) {
      hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c2 of children) {
      if (c2.type !== Comment) {
        child = c2;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter: onEnter2,
    onAfterEnter: onAfterEnter2,
    onEnterCancelled,
    onBeforeLeave: onBeforeLeave2,
    onLeave: onLeave2,
    onAfterLeave: onAfterLeave2,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter2;
      let afterHook = onAfterEnter2;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter2;
          afterHook = onAfterAppear || onAfterEnter2;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove22) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove22();
      }
      callHook2(onBeforeLeave2, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove22();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave2, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave2) {
        callAsyncHook(onLeave2, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$1(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function useId() {
  const i2 = getCurrentInstance();
  if (i2) {
    return (i2.appContext.config.idPrefix || "v") + "-" + i2.ids[0] + i2.ids[1]++;
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach(
      (r, i2) => setRef(
        r,
        oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {
    return hasOwn$1(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    invalidatePendingSetRef(oldRawRef);
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      {
        oldRef.value = null;
      }
      const oldRawRefAtom = oldRawRef;
      if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$2(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                const newVal = [refValue];
                {
                  ref3.value = newVal;
                }
                if (rawRef.k) refs[rawRef.k] = newVal;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          {
            ref3.value = value;
          }
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        const job = () => {
          doSet();
          pendingSetRefMap.delete(rawRef);
        };
        job.id = -1;
        pendingSetRefMap.set(rawRef, job);
        queuePostRenderEffect(job, parentSuspense);
      } else {
        invalidatePendingSetRef(rawRef);
        doSet();
      }
    }
  }
}
function invalidatePendingSetRef(rawRef) {
  const pendingSetRef = pendingSetRefMap.get(rawRef);
  if (pendingSetRef) {
    pendingSetRef.flags |= 8;
    pendingSetRefMap.delete(rawRef);
  }
}
getGlobalThis$1().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis$1().cancelIdleCallback || ((id) => clearTimeout(id));
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    const hasProps = Object.keys(props).length > 0;
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      hasProps ? -2 : 64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2) return null;
  if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $host: (i2) => i2.ce,
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => {
      queueJob(i2.update);
    }),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data: data3, props, accessCache, type, appContext } = instance;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data3[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data3 !== EMPTY_OBJ && hasOwn$1(data3, key)) {
        accessCache[key] = 2;
        return data3[key];
      } else if (hasOwn$1(props, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data: data3, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data3 !== EMPTY_OBJ && hasOwn$1(data3, key)) {
      data3[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data: data3, setupState, accessCache, ctx, appContext, props, type }
  }, key) {
    let cssModules;
    return !!(accessCache[key] || data3 !== EMPTY_OBJ && key[0] !== "$" && hasOwn$1(data3, key) || hasSetupBinding(setupState, key) || hasOwn$1(props, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$1(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created: created2,
    beforeMount: beforeMount2,
    mounted: mounted5,
    beforeUpdate: beforeUpdate2,
    updated: updated4,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount: beforeUnmount3,
    destroyed,
    unmounted: unmounted4,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data3 = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data3)) ;
    else {
      instance.data = reactive(data3);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created2) {
    callHook$1(created2, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook3) => register(_hook3.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount2);
  registerLifecycleHook(onMounted, mounted5);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate2);
  registerLifecycleHook(onUpdated, updated4);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount3);
  registerLifecycleHook(onUnmounted, unmounted4);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val,
          enumerable: true
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler3 = ctx[raw];
    if (isFunction$1(handler3)) {
      {
        watch(getter, handler3);
      }
    }
  } else if (isFunction$1(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$2(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler3 = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler3)) {
        watch(getter, handler3, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$1(to) && isArray$1(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render2(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app2._instance,
            16
          );
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value) {
  if (currentInstance) {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = getCurrentInstance();
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a2) => isString$2(a2) ? a2.trim() : a2);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler3 = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler3 && isModelListener2) {
    handler3 = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler3) {
    callWithAsyncErrorHandling(
      handler3,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = asMixin ? mixinEmitsCache : appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs: attrs2,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data: data3,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data3,
          ctx
        )
      );
      fallthroughAttrs = attrs2;
    } else {
      const render22 = Component;
      if (false) ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs2);
            },
            slots,
            emit: emit2
          } : { attrs: attrs2, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs2 : getFunctionalFallthrough(attrs2);
    }
  } catch (err2) {
    blockStack.length = 0;
    handleError(err2, instance, 1);
    result = createVNode(Comment);
  }
  let root4 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root4;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root4 = cloneVNode(root4, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root4 = cloneVNode(root4, null, false, true);
    root4.dirs = root4.dirs ? root4.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root4, vnode.transition);
  }
  {
    result = root4;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs2) => {
  let res;
  for (const key in attrs2) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs2[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs2, props) => {
  const res = {};
  for (const key in attrs2) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs2[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root4 = parent.subTree;
    if (root4.suspense && root4.suspense.activeBranch === vnode) {
      root4.el = vnode.el;
    }
    if (root4 === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs2 = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs2);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs2;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs2;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs: attrs2,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs2, key)) {
            if (value !== attrs2[key]) {
              attrs2[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs2[key]) {
            attrs2[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs2)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs2 !== rawCurrentProps) {
      for (const key in attrs2) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs2[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs2) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs2) || value !== attrs2[key]) {
          attrs2[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$1(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction$1(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$1(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn$1(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref3 == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      const customElement = !!(n1.el && n1.el._isVueCE) ? n1.el : null;
      try {
        if (customElement) {
          customElement._beginPatch();
        }
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } finally {
        if (customElement) {
          customElement._endPatch();
        }
      }
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
        initialVNode.placeholder = placeholder.el;
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent, root: root4, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root4.ce && // @ts-expect-error _def is private
          root4.ce._def.shadowRoot !== false) {
            root4.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchorVNode = c2[nextIndex + 1];
        const anchor = nextIndex + 1 < l2 ? (
          // #13559, fallback to el placeholder for unresolved async component
          anchorVNode.el || anchorVNode.placeholder
        ) : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove222 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          if (el._isLeaving) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          leave(el, () => {
            remove222();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove222, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove22(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove22 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m: m2, a: a2 } = instance;
    invalidateMount(m2);
    invalidateMount(a2);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render2 = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove22,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text && // avoid cached text nodes retaining detached dom nodes
      c2.patchFlag !== -1) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u = 0;
      v2 = result.length - 1;
      while (u < v2) {
        c2 = u + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i2] = result[u - 1];
        }
        result[u] = i2;
      }
    }
  }
  u = result.length;
  v2 = result[u - 1];
  while (u-- > 0) {
    result[u] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i2 = 0; i2 < hooks.length; i2++)
      hooks[i2].flags |= 8;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style2)) {
      if (isProxy(style2) && !isArray$1(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode$1(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g2 = getGlobalThis$1();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g2[key])) setters = g2[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set) => set(v2));
      else setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup: setup2 } = Component;
  if (setup2) {
    pauseTracking();
    const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup2,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise$1(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance);
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])\w/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components) || instance.parent && inferFromRegistry(
      instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c2;
};
function h$2(type, propsOrChildren, children) {
  try {
    setBlockTracking(-1);
    const l2 = arguments.length;
    if (l2 === 2) {
      if (isObject$2(propsOrChildren) && !isArray$1(propsOrChildren)) {
        if (isVNode$1(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l2 > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l2 === 3 && isVNode$1(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  } finally {
    setBlockTracking(1);
  }
}
const version = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt$1 = typeof window !== "undefined" && window.trustedTypes;
if (tt$1) {
  try {
    policy = /* @__PURE__ */ tt$1.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t2) => {
  t2.displayName = "Transition";
  t2.props = TransitionPropsValidators;
  return t2;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h$2(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter: onEnter2,
    onEnterCancelled,
    onLeave: onLeave2,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter2,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter2;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow(el);
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow(el);
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave2)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave2, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  if (s2 === "auto") return 0;
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow(el) {
  const targetDocument = el ? el.ownerDocument : document;
  return targetDocument.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(?:^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$2(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$2(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style2, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style2, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style2[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style2.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
    if (el[vShowHidden]) {
      style2.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$1(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean2 ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler3, options) {
  el.addEventListener(event, handler3, options);
}
function removeEventListener(el, event, handler3, options) {
  el.removeEventListener(event, handler3, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$1(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$2(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "sandbox" && el.tagName === "IFRAME") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$2(value)) {
    return false;
  }
  return key in el;
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = ((...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app2._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
});
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var ie$1 = Object.defineProperty;
var K$1 = Object.getOwnPropertySymbols;
var se = Object.prototype.hasOwnProperty, ae$1 = Object.prototype.propertyIsEnumerable;
var N$1 = (e, t2, n) => t2 in e ? ie$1(e, t2, { enumerable: true, configurable: true, writable: true, value: n }) : e[t2] = n, d = (e, t2) => {
  for (var n in t2 || (t2 = {})) se.call(t2, n) && N$1(e, n, t2[n]);
  if (K$1) for (var n of K$1(t2)) ae$1.call(t2, n) && N$1(e, n, t2[n]);
  return e;
};
function l(e) {
  return e == null || e === "" || Array.isArray(e) && e.length === 0 || !(e instanceof Date) && typeof e == "object" && Object.keys(e).length === 0;
}
function c$1(e) {
  return typeof e == "function" && "call" in e && "apply" in e;
}
function s$2(e) {
  return !l(e);
}
function i(e, t2 = true) {
  return e instanceof Object && e.constructor === Object && (t2 || Object.keys(e).length !== 0);
}
function $$1(e = {}, t2 = {}) {
  let n = d({}, e);
  return Object.keys(t2).forEach((o) => {
    let r = o;
    i(t2[r]) && r in e && i(e[r]) ? n[r] = $$1(e[r], t2[r]) : n[r] = t2[r];
  }), n;
}
function w(...e) {
  return e.reduce((t2, n, o) => o === 0 ? n : $$1(t2, n), {});
}
function m(e, ...t2) {
  return c$1(e) ? e(...t2) : e;
}
function a(e, t2 = true) {
  return typeof e == "string" && (t2 || e !== "");
}
function g$1(e) {
  return a(e) ? e.replace(/(-|_)/g, "").toLowerCase() : e;
}
function F$2(e, t2 = "", n = {}) {
  let o = g$1(t2).split("."), r = o.shift();
  if (r) {
    if (i(e)) {
      let u = Object.keys(e).find((f2) => g$1(f2) === r) || "";
      return F$2(m(e[u], n), o.join("."), n);
    }
    return;
  }
  return m(e, n);
}
function C$2(e, t2 = true) {
  return Array.isArray(e) && (t2 || e.length !== 0);
}
function z$1(e) {
  return s$2(e) && !isNaN(e);
}
function G(e, t2) {
  if (t2) {
    let n = t2.test(e);
    return t2.lastIndex = 0, n;
  }
  return false;
}
function H(...e) {
  return w(...e);
}
function Y$2(e) {
  return e && e.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "").replace(/ {2,}/g, " ").replace(/ ([{:}]) /g, "$1").replace(/([;,]) /g, "$1").replace(/ !/g, "!").replace(/: /g, ":").trim();
}
function ne$1(e) {
  return a(e, false) ? e[0].toUpperCase() + e.slice(1) : e;
}
function re(e) {
  return a(e) ? e.replace(/(_)/g, "-").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() : e;
}
function s$1() {
  let r = /* @__PURE__ */ new Map();
  return { on(e, t2) {
    let n = r.get(e);
    return n ? n.push(t2) : n = [t2], r.set(e, n), this;
  }, off(e, t2) {
    let n = r.get(e);
    return n && n.splice(n.indexOf(t2) >>> 0, 1), this;
  }, emit(e, t2) {
    let n = r.get(e);
    n && n.forEach((i2) => {
      i2(t2);
    });
  }, clear() {
    r.clear();
  } };
}
function f(...e) {
  if (e) {
    let t2 = [];
    for (let i2 = 0; i2 < e.length; i2++) {
      let n = e[i2];
      if (!n) continue;
      let s2 = typeof n;
      if (s2 === "string" || s2 === "number") t2.push(n);
      else if (s2 === "object") {
        let c2 = Array.isArray(n) ? [f(...n)] : Object.entries(n).map(([r, o]) => o ? r : void 0);
        t2 = c2.length ? t2.concat(c2.filter((r) => !!r)) : t2;
      }
    }
    return t2.join(" ").trim();
  }
}
function R(t2, e) {
  return t2 ? t2.classList ? t2.classList.contains(e) : new RegExp("(^| )" + e + "( |$)", "gi").test(t2.className) : false;
}
function W(t2, e) {
  if (t2 && e) {
    let o = (n) => {
      R(t2, n) || (t2.classList ? t2.classList.add(n) : t2.className += " " + n);
    };
    [e].flat().filter(Boolean).forEach((n) => n.split(" ").forEach(o));
  }
}
function F$1() {
  return window.innerWidth - document.documentElement.offsetWidth;
}
function st$1(t2) {
  typeof t2 == "string" ? W(document.body, t2 || "p-overflow-hidden") : (t2 != null && t2.variableName && document.body.style.setProperty(t2.variableName, F$1() + "px"), W(document.body, (t2 == null ? void 0 : t2.className) || "p-overflow-hidden"));
}
function P(t2, e) {
  if (t2 && e) {
    let o = (n) => {
      t2.classList ? t2.classList.remove(n) : t2.className = t2.className.replace(new RegExp("(^|\\b)" + n.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    };
    [e].flat().filter(Boolean).forEach((n) => n.split(" ").forEach(o));
  }
}
function dt$1(t2) {
  typeof t2 == "string" ? P(document.body, t2 || "p-overflow-hidden") : (t2 != null && t2.variableName && document.body.style.removeProperty(t2.variableName), P(document.body, (t2 == null ? void 0 : t2.className) || "p-overflow-hidden"));
}
function h$1() {
  let t2 = window, e = document, o = e.documentElement, n = e.getElementsByTagName("body")[0], r = t2.innerWidth || o.clientWidth || n.clientWidth, i2 = t2.innerHeight || o.clientHeight || n.clientHeight;
  return { width: r, height: i2 };
}
function E$1(t2) {
  return t2 ? Math.abs(t2.scrollLeft) : 0;
}
function S$1(t2, e) {
  t2 && (typeof e == "string" ? t2.style.cssText = e : Object.entries(e || {}).forEach(([o, n]) => t2.style[o] = n));
}
function v$1(t2, e) {
  if (t2 instanceof HTMLElement) {
    let o = t2.offsetWidth;
    return o;
  }
  return 0;
}
function y(t2) {
  if (t2) {
    let e = t2.parentNode;
    return e && e instanceof ShadowRoot && e.host && (e = e.host), e;
  }
  return null;
}
function T(t2) {
  return !!(t2 !== null && typeof t2 != "undefined" && t2.nodeName && y(t2));
}
function c(t2) {
  return typeof Element != "undefined" ? t2 instanceof Element : t2 !== null && typeof t2 == "object" && t2.nodeType === 1 && typeof t2.nodeName == "string";
}
function A(t2, e = {}) {
  if (c(t2)) {
    let o = (n, r) => {
      var l2, d2;
      let i2 = (l2 = t2 == null ? void 0 : t2.$attrs) != null && l2[n] ? [(d2 = t2 == null ? void 0 : t2.$attrs) == null ? void 0 : d2[n]] : [];
      return [r].flat().reduce((s2, a2) => {
        if (a2 != null) {
          let u = typeof a2;
          if (u === "string" || u === "number") s2.push(a2);
          else if (u === "object") {
            let p2 = Array.isArray(a2) ? o(n, a2) : Object.entries(a2).map(([f2, g2]) => n === "style" && (g2 || g2 === 0) ? `${f2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()}:${g2}` : g2 ? f2 : void 0);
            s2 = p2.length ? s2.concat(p2.filter((f2) => !!f2)) : s2;
          }
        }
        return s2;
      }, i2);
    };
    Object.entries(e).forEach(([n, r]) => {
      if (r != null) {
        let i2 = n.match(/^on(.+)/);
        i2 ? t2.addEventListener(i2[1].toLowerCase(), r) : n === "p-bind" || n === "pBind" ? A(t2, r) : (r = n === "class" ? [...new Set(o("class", r))].join(" ").trim() : n === "style" ? o("style", r).join(";").trim() : r, (t2.$attrs = t2.$attrs || {}) && (t2.$attrs[n] = r), t2.setAttribute(n, r));
      }
    });
  }
}
function U(t2, e = {}, ...o) {
  {
    let n = document.createElement(t2);
    return A(n, e), n.append(...o), n;
  }
}
function Y$1(t2, e) {
  return c(t2) ? Array.from(t2.querySelectorAll(e)) : [];
}
function z(t2, e) {
  return c(t2) ? t2.matches(e) ? t2 : t2.querySelector(e) : null;
}
function bt(t2, e) {
  t2 && document.activeElement !== t2 && t2.focus(e);
}
function Q$1(t2, e) {
  if (c(t2)) {
    let o = t2.getAttribute(e);
    return isNaN(o) ? o === "true" || o === "false" ? o === "true" : o : +o;
  }
}
function b$1(t2, e = "") {
  let o = Y$1(t2, `button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [href]:not([tabindex = "-1"]):not([style*="display:none"]):not([hidden])${e},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e}`), n = [];
  for (let r of o) getComputedStyle(r).display != "none" && getComputedStyle(r).visibility != "hidden" && n.push(r);
  return n;
}
function vt(t2, e) {
  let o = b$1(t2, e);
  return o.length > 0 ? o[0] : null;
}
function Tt(t2) {
  if (t2) {
    let e = t2.offsetHeight, o = getComputedStyle(t2);
    return e -= parseFloat(o.paddingTop) + parseFloat(o.paddingBottom) + parseFloat(o.borderTopWidth) + parseFloat(o.borderBottomWidth), e;
  }
  return 0;
}
function Lt(t2, e) {
  let o = b$1(t2, e);
  return o.length > 0 ? o[o.length - 1] : null;
}
function K(t2) {
  if (t2) {
    let e = t2.getBoundingClientRect();
    return { top: e.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0), left: e.left + (window.pageXOffset || E$1(document.documentElement) || E$1(document.body) || 0) };
  }
  return { top: "auto", left: "auto" };
}
function C$1(t2, e) {
  if (t2) {
    let o = t2.offsetHeight;
    return o;
  }
  return 0;
}
function Rt(t2) {
  if (t2) {
    let e = t2.offsetWidth, o = getComputedStyle(t2);
    return e -= parseFloat(o.paddingLeft) + parseFloat(o.paddingRight) + parseFloat(o.borderLeftWidth) + parseFloat(o.borderRightWidth), e;
  }
  return 0;
}
function tt() {
  return !!(typeof window != "undefined" && window.document && window.document.createElement);
}
function It(t2, e = "") {
  return c(t2) ? t2.matches(`button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e},
            [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])${e}`) : false;
}
function _t(t2, e = "", o) {
  c(t2) && o !== null && o !== void 0 && t2.setAttribute(e, o);
}
var t = {};
function s(n = "pui_id_") {
  return Object.hasOwn(t, n) || (t[n] = 0), t[n]++, `${n}${t[n]}`;
}
function g() {
  let r = [], i2 = (e, n, t2 = 999) => {
    let s2 = u(e, n, t2), o = s2.value + (s2.key === e ? 0 : t2) + 1;
    return r.push({ key: e, value: o }), o;
  }, d2 = (e) => {
    r = r.filter((n) => n.value !== e);
  }, a2 = (e, n) => u(e).value, u = (e, n, t2 = 0) => [...r].reverse().find((s2) => true) || { key: e, value: t2 }, l2 = (e) => e && parseInt(e.style.zIndex, 10) || 0;
  return { get: l2, set: (e, n, t2) => {
    n && (n.style.zIndex = String(i2(e, true, t2)));
  }, clear: (e) => {
    e && (d2(l2(e)), e.style.zIndex = "");
  }, getCurrent: (e) => a2(e) };
}
var x = g();
var rt = Object.defineProperty, st = Object.defineProperties;
var nt = Object.getOwnPropertyDescriptors;
var F = Object.getOwnPropertySymbols;
var xe = Object.prototype.hasOwnProperty, be = Object.prototype.propertyIsEnumerable;
var _e$1 = (e, t2, r) => t2 in e ? rt(e, t2, { enumerable: true, configurable: true, writable: true, value: r }) : e[t2] = r, h = (e, t2) => {
  for (var r in t2 || (t2 = {})) xe.call(t2, r) && _e$1(e, r, t2[r]);
  if (F) for (var r of F(t2)) be.call(t2, r) && _e$1(e, r, t2[r]);
  return e;
}, $ = (e, t2) => st(e, nt(t2));
var v = (e, t2) => {
  var r = {};
  for (var s2 in e) xe.call(e, s2) && t2.indexOf(s2) < 0 && (r[s2] = e[s2]);
  if (e != null && F) for (var s2 of F(e)) t2.indexOf(s2) < 0 && be.call(e, s2) && (r[s2] = e[s2]);
  return r;
};
var at = s$1(), N = at;
var k = /{([^}]*)}/g, ne = /(\d+\s+[\+\-\*\/]\s+\d+)/g, ie = /var\([^)]+\)/g;
function oe(e) {
  return a(e) ? e.replace(/[A-Z]/g, (t2, r) => r === 0 ? t2 : "." + t2.toLowerCase()).toLowerCase() : e;
}
function ve(e) {
  return i(e) && e.hasOwnProperty("$value") && e.hasOwnProperty("$type") ? e.$value : e;
}
function dt(e) {
  return e.replaceAll(/ /g, "").replace(/[^\w]/g, "-");
}
function Q(e = "", t2 = "") {
  return dt(`${a(e, false) && a(t2, false) ? `${e}-` : e}${t2}`);
}
function ae(e = "", t2 = "") {
  return `--${Q(e, t2)}`;
}
function ht(e = "") {
  let t2 = (e.match(/{/g) || []).length, r = (e.match(/}/g) || []).length;
  return (t2 + r) % 2 !== 0;
}
function Y(e, t2 = "", r = "", s2 = [], i2) {
  if (a(e)) {
    let a2 = e.trim();
    if (ht(a2)) return;
    if (G(a2, k)) {
      let n = a2.replaceAll(k, (l2) => {
        let c2 = l2.replace(/{|}/g, "").split(".").filter((m2) => !s2.some((d2) => G(m2, d2)));
        return `var(${ae(r, re(c2.join("-")))}${s$2(i2) ? `, ${i2}` : ""})`;
      });
      return G(n.replace(ie, "0"), ne) ? `calc(${n})` : n;
    }
    return a2;
  } else if (z$1(e)) return e;
}
function Re(e, t2, r) {
  a(t2, false) && e.push(`${t2}:${r};`);
}
function C(e, t2) {
  return e ? `${e}{${t2}}` : "";
}
function le(e, t2) {
  if (e.indexOf("dt(") === -1) return e;
  function r(n, l2) {
    let o = [], c2 = 0, m2 = "", d2 = null, u = 0;
    for (; c2 <= n.length; ) {
      let g2 = n[c2];
      if ((g2 === '"' || g2 === "'" || g2 === "`") && n[c2 - 1] !== "\\" && (d2 = d2 === g2 ? null : g2), !d2 && (g2 === "(" && u++, g2 === ")" && u--, (g2 === "," || c2 === n.length) && u === 0)) {
        let f2 = m2.trim();
        f2.startsWith("dt(") ? o.push(le(f2, l2)) : o.push(s2(f2)), m2 = "", c2++;
        continue;
      }
      g2 !== void 0 && (m2 += g2), c2++;
    }
    return o;
  }
  function s2(n) {
    let l2 = n[0];
    if ((l2 === '"' || l2 === "'" || l2 === "`") && n[n.length - 1] === l2) return n.slice(1, -1);
    let o = Number(n);
    return isNaN(o) ? n : o;
  }
  let i2 = [], a2 = [];
  for (let n = 0; n < e.length; n++) if (e[n] === "d" && e.slice(n, n + 3) === "dt(") a2.push(n), n += 2;
  else if (e[n] === ")" && a2.length > 0) {
    let l2 = a2.pop();
    a2.length === 0 && i2.push([l2, n]);
  }
  if (!i2.length) return e;
  for (let n = i2.length - 1; n >= 0; n--) {
    let [l2, o] = i2[n], c2 = e.slice(l2 + 3, o), m2 = r(c2, t2), d2 = t2(...m2);
    e = e.slice(0, l2) + d2 + e.slice(o + 1);
  }
  return e;
}
var rr = (e) => {
  var a2;
  let t2 = S.getTheme(), r = ue(t2, e, void 0, "variable"), s2 = (a2 = r == null ? void 0 : r.match(/--[\w-]+/g)) == null ? void 0 : a2[0], i2 = ue(t2, e, void 0, "value");
  return { name: s2, variable: r, value: i2 };
}, E = (...e) => ue(S.getTheme(), ...e), ue = (e = {}, t2, r, s2) => {
  if (t2) {
    let { variable: i2, options: a2 } = S.defaults || {}, { prefix: n, transform: l$1 } = (e == null ? void 0 : e.options) || a2 || {}, o = G(t2, k) ? t2 : `{${t2}}`;
    return s2 === "value" || l(s2) && l$1 === "strict" ? S.getTokenValue(t2) : Y(o, void 0, n, [i2.excludedKeyRegex], r);
  }
  return "";
};
function ar(e, ...t2) {
  if (e instanceof Array) {
    let r = e.reduce((s2, i2, a2) => {
      var n;
      return s2 + i2 + ((n = m(t2[a2], { dt: E })) != null ? n : "");
    }, "");
    return le(r, E);
  }
  return m(e, { dt: E });
}
function de(e, t2 = {}) {
  let r = S.defaults.variable, { prefix: s2 = r.prefix, selector: i$1 = r.selector, excludedKeyRegex: a2 = r.excludedKeyRegex } = t2, n = [], l2 = [], o = [{ node: e, path: s2 }];
  for (; o.length; ) {
    let { node: m2, path: d2 } = o.pop();
    for (let u in m2) {
      let g2 = m2[u], f2 = ve(g2), p2 = G(u, a2) ? Q(d2) : Q(d2, re(u));
      if (i(f2)) o.push({ node: f2, path: p2 });
      else {
        let y2 = ae(p2), R2 = Y(f2, p2, s2, [a2]);
        Re(l2, y2, R2);
        let T2 = p2;
        s2 && T2.startsWith(s2 + "-") && (T2 = T2.slice(s2.length + 1)), n.push(T2.replace(/-/g, "."));
      }
    }
  }
  let c2 = l2.join("");
  return { value: l2, tokens: n, declarations: c2, css: C(i$1, c2) };
}
var b = { regex: { rules: { class: { pattern: /^\.([a-zA-Z][\w-]*)$/, resolve(e) {
  return { type: "class", selector: e, matched: this.pattern.test(e.trim()) };
} }, attr: { pattern: /^\[(.*)\]$/, resolve(e) {
  return { type: "attr", selector: `:root${e},:host${e}`, matched: this.pattern.test(e.trim()) };
} }, media: { pattern: /^@media (.*)$/, resolve(e) {
  return { type: "media", selector: e, matched: this.pattern.test(e.trim()) };
} }, system: { pattern: /^system$/, resolve(e) {
  return { type: "system", selector: "@media (prefers-color-scheme: dark)", matched: this.pattern.test(e.trim()) };
} }, custom: { resolve(e) {
  return { type: "custom", selector: e, matched: true };
} } }, resolve(e) {
  let t2 = Object.keys(this.rules).filter((r) => r !== "custom").map((r) => this.rules[r]);
  return [e].flat().map((r) => {
    var s2;
    return (s2 = t2.map((i2) => i2.resolve(r)).find((i2) => i2.matched)) != null ? s2 : this.rules.custom.resolve(r);
  });
} }, _toVariables(e, t2) {
  return de(e, { prefix: t2 == null ? void 0 : t2.prefix });
}, getCommon({ name: e = "", theme: t2 = {}, params: r, set: s2, defaults: i2 }) {
  var R2, T2, j, O, M, z2, V;
  let { preset: a2, options: n } = t2, l2, o, c2, m$1, d2, u, g2;
  if (s$2(a2) && n.transform !== "strict") {
    let { primitive: L, semantic: te, extend: re2 } = a2, f2 = te || {}, { colorScheme: K2 } = f2, A2 = v(f2, ["colorScheme"]), x2 = re2 || {}, { colorScheme: X } = x2, G2 = v(x2, ["colorScheme"]), p2 = K2 || {}, { dark: U2 } = p2, B = v(p2, ["dark"]), y2 = X || {}, { dark: I } = y2, H2 = v(y2, ["dark"]), W2 = s$2(L) ? this._toVariables({ primitive: L }, n) : {}, q = s$2(A2) ? this._toVariables({ semantic: A2 }, n) : {}, Z = s$2(B) ? this._toVariables({ light: B }, n) : {}, pe = s$2(U2) ? this._toVariables({ dark: U2 }, n) : {}, fe = s$2(G2) ? this._toVariables({ semantic: G2 }, n) : {}, ye = s$2(H2) ? this._toVariables({ light: H2 }, n) : {}, Se = s$2(I) ? this._toVariables({ dark: I }, n) : {}, [Me, ze] = [(R2 = W2.declarations) != null ? R2 : "", W2.tokens], [Ke, Xe] = [(T2 = q.declarations) != null ? T2 : "", q.tokens || []], [Ge, Ue] = [(j = Z.declarations) != null ? j : "", Z.tokens || []], [Be, Ie] = [(O = pe.declarations) != null ? O : "", pe.tokens || []], [He, We] = [(M = fe.declarations) != null ? M : "", fe.tokens || []], [qe, Ze] = [(z2 = ye.declarations) != null ? z2 : "", ye.tokens || []], [Fe, Je] = [(V = Se.declarations) != null ? V : "", Se.tokens || []];
    l2 = this.transformCSS(e, Me, "light", "variable", n, s2, i2), o = ze;
    let Qe = this.transformCSS(e, `${Ke}${Ge}`, "light", "variable", n, s2, i2), Ye = this.transformCSS(e, `${Be}`, "dark", "variable", n, s2, i2);
    c2 = `${Qe}${Ye}`, m$1 = [.../* @__PURE__ */ new Set([...Xe, ...Ue, ...Ie])];
    let et = this.transformCSS(e, `${He}${qe}color-scheme:light`, "light", "variable", n, s2, i2), tt2 = this.transformCSS(e, `${Fe}color-scheme:dark`, "dark", "variable", n, s2, i2);
    d2 = `${et}${tt2}`, u = [.../* @__PURE__ */ new Set([...We, ...Ze, ...Je])], g2 = m(a2.css, { dt: E });
  }
  return { primitive: { css: l2, tokens: o }, semantic: { css: c2, tokens: m$1 }, global: { css: d2, tokens: u }, style: g2 };
}, getPreset({ name: e = "", preset: t2 = {}, options: r, params: s2, set: i2, defaults: a2, selector: n }) {
  var f2, x2, p2;
  let l2, o, c2;
  if (s$2(t2) && r.transform !== "strict") {
    let y2 = e.replace("-directive", ""), m$1 = t2, { colorScheme: R2, extend: T2, css: j } = m$1, O = v(m$1, ["colorScheme", "extend", "css"]), d2 = T2 || {}, { colorScheme: M } = d2, z2 = v(d2, ["colorScheme"]), u = R2 || {}, { dark: V } = u, L = v(u, ["dark"]), g2 = M || {}, { dark: te } = g2, re2 = v(g2, ["dark"]), K2 = s$2(O) ? this._toVariables({ [y2]: h(h({}, O), z2) }, r) : {}, A2 = s$2(L) ? this._toVariables({ [y2]: h(h({}, L), re2) }, r) : {}, X = s$2(V) ? this._toVariables({ [y2]: h(h({}, V), te) }, r) : {}, [G2, U2] = [(f2 = K2.declarations) != null ? f2 : "", K2.tokens || []], [B, I] = [(x2 = A2.declarations) != null ? x2 : "", A2.tokens || []], [H2, W2] = [(p2 = X.declarations) != null ? p2 : "", X.tokens || []], q = this.transformCSS(y2, `${G2}${B}`, "light", "variable", r, i2, a2, n), Z = this.transformCSS(y2, H2, "dark", "variable", r, i2, a2, n);
    l2 = `${q}${Z}`, o = [.../* @__PURE__ */ new Set([...U2, ...I, ...W2])], c2 = m(j, { dt: E });
  }
  return { css: l2, tokens: o, style: c2 };
}, getPresetC({ name: e = "", theme: t2 = {}, params: r, set: s2, defaults: i2 }) {
  var o;
  let { preset: a2, options: n } = t2, l2 = (o = a2 == null ? void 0 : a2.components) == null ? void 0 : o[e];
  return this.getPreset({ name: e, preset: l2, options: n, params: r, set: s2, defaults: i2 });
}, getPresetD({ name: e = "", theme: t2 = {}, params: r, set: s2, defaults: i2 }) {
  var c2, m2;
  let a2 = e.replace("-directive", ""), { preset: n, options: l2 } = t2, o = ((c2 = n == null ? void 0 : n.components) == null ? void 0 : c2[a2]) || ((m2 = n == null ? void 0 : n.directives) == null ? void 0 : m2[a2]);
  return this.getPreset({ name: a2, preset: o, options: l2, params: r, set: s2, defaults: i2 });
}, applyDarkColorScheme(e) {
  return !(e.darkModeSelector === "none" || e.darkModeSelector === false);
}, getColorSchemeOption(e, t2) {
  var r;
  return this.applyDarkColorScheme(e) ? this.regex.resolve(e.darkModeSelector === true ? t2.options.darkModeSelector : (r = e.darkModeSelector) != null ? r : t2.options.darkModeSelector) : [];
}, getLayerOrder(e, t2 = {}, r, s2) {
  let { cssLayer: i2 } = t2;
  return i2 ? `@layer ${m(i2.order || i2.name || "primeui", r)}` : "";
}, getCommonStyleSheet({ name: e = "", theme: t2 = {}, params: r, props: s2 = {}, set: i$1, defaults: a2 }) {
  let n = this.getCommon({ name: e, theme: t2, params: r, set: i$1, defaults: a2 }), l2 = Object.entries(s2).reduce((o, [c2, m2]) => o.push(`${c2}="${m2}"`) && o, []).join(" ");
  return Object.entries(n || {}).reduce((o, [c2, m2]) => {
    if (i(m2) && Object.hasOwn(m2, "css")) {
      let d2 = Y$2(m2.css), u = `${c2}-variables`;
      o.push(`<style type="text/css" data-primevue-style-id="${u}" ${l2}>${d2}</style>`);
    }
    return o;
  }, []).join("");
}, getStyleSheet({ name: e = "", theme: t2 = {}, params: r, props: s2 = {}, set: i2, defaults: a2 }) {
  var c2;
  let n = { name: e, theme: t2, params: r, set: i2, defaults: a2 }, l2 = (c2 = e.includes("-directive") ? this.getPresetD(n) : this.getPresetC(n)) == null ? void 0 : c2.css, o = Object.entries(s2).reduce((m2, [d2, u]) => m2.push(`${d2}="${u}"`) && m2, []).join(" ");
  return l2 ? `<style type="text/css" data-primevue-style-id="${e}-variables" ${o}>${Y$2(l2)}</style>` : "";
}, createTokens(e = {}, t2, r = "", s2 = "", i$1 = {}) {
  let a2 = function(l$1, o = {}, c2 = []) {
    if (c2.includes(this.path)) return console.warn(`Circular reference detected at ${this.path}`), { colorScheme: l$1, path: this.path, paths: o, value: void 0 };
    c2.push(this.path), o.name = this.path, o.binding || (o.binding = {});
    let m2 = this.value;
    if (typeof this.value == "string" && k.test(this.value)) {
      let u = this.value.trim().replace(k, (g2) => {
        var y2;
        let f2 = g2.slice(1, -1), x2 = this.tokens[f2];
        if (!x2) return console.warn(`Token not found for path: ${f2}`), "__UNRESOLVED__";
        let p2 = x2.computed(l$1, o, c2);
        return Array.isArray(p2) && p2.length === 2 ? `light-dark(${p2[0].value},${p2[1].value})` : (y2 = p2 == null ? void 0 : p2.value) != null ? y2 : "__UNRESOLVED__";
      });
      m2 = ne.test(u.replace(ie, "0")) ? `calc(${u})` : u;
    }
    return l(o.binding) && delete o.binding, c2.pop(), { colorScheme: l$1, path: this.path, paths: o, value: m2.includes("__UNRESOLVED__") ? void 0 : m2 };
  }, n = (l2, o, c2) => {
    Object.entries(l2).forEach(([m2, d2]) => {
      let u = G(m2, t2.variable.excludedKeyRegex) ? o : o ? `${o}.${oe(m2)}` : oe(m2), g2 = c2 ? `${c2}.${m2}` : m2;
      i(d2) ? n(d2, u, g2) : (i$1[u] || (i$1[u] = { paths: [], computed: (f2, x2 = {}, p2 = []) => {
        if (i$1[u].paths.length === 1) return i$1[u].paths[0].computed(i$1[u].paths[0].scheme, x2.binding, p2);
        if (f2 && f2 !== "none") for (let y2 = 0; y2 < i$1[u].paths.length; y2++) {
          let R2 = i$1[u].paths[y2];
          if (R2.scheme === f2) return R2.computed(f2, x2.binding, p2);
        }
        return i$1[u].paths.map((y2) => y2.computed(y2.scheme, x2[y2.scheme], p2));
      } }), i$1[u].paths.push({ path: g2, value: d2, scheme: g2.includes("colorScheme.light") ? "light" : g2.includes("colorScheme.dark") ? "dark" : "none", computed: a2, tokens: i$1 }));
    });
  };
  return n(e, r, s2), i$1;
}, getTokenValue(e, t2, r) {
  var l2;
  let i2 = ((o) => o.split(".").filter((m2) => !G(m2.toLowerCase(), r.variable.excludedKeyRegex)).join("."))(t2), a2 = t2.includes("colorScheme.light") ? "light" : t2.includes("colorScheme.dark") ? "dark" : void 0, n = [(l2 = e[i2]) == null ? void 0 : l2.computed(a2)].flat().filter((o) => o);
  return n.length === 1 ? n[0].value : n.reduce((o = {}, c2) => {
    let u = c2, { colorScheme: m2 } = u, d2 = v(u, ["colorScheme"]);
    return o[m2] = d2, o;
  }, void 0);
}, getSelectorRule(e, t2, r, s2) {
  return r === "class" || r === "attr" ? C(s$2(t2) ? `${e}${t2},${e} ${t2}` : e, s2) : C(e, C(t2 != null ? t2 : ":root,:host", s2));
}, transformCSS(e, t2, r, s2, i$1 = {}, a2, n, l2) {
  if (s$2(t2)) {
    let { cssLayer: o } = i$1;
    if (s2 !== "style") {
      let c2 = this.getColorSchemeOption(i$1, n);
      t2 = r === "dark" ? c2.reduce((m2, { type: d2, selector: u }) => (s$2(u) && (m2 += u.includes("[CSS]") ? u.replace("[CSS]", t2) : this.getSelectorRule(u, l2, d2, t2)), m2), "") : C(l2 != null ? l2 : ":root,:host", t2);
    }
    if (o) {
      let c2 = { name: "primeui" };
      i(o) && (c2.name = m(o.name, { name: e, type: s2 })), s$2(c2.name) && (t2 = C(`@layer ${c2.name}`, t2), a2 == null || a2.layerNames(c2.name));
    }
    return t2;
  }
  return "";
} };
var S = { defaults: { variable: { prefix: "p", selector: ":root,:host", excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states|extend|css)$/gi }, options: { prefix: "p", darkModeSelector: "system", cssLayer: false } }, _theme: void 0, _layerNames: /* @__PURE__ */ new Set(), _loadedStyleNames: /* @__PURE__ */ new Set(), _loadingStyles: /* @__PURE__ */ new Set(), _tokens: {}, update(e = {}) {
  let { theme: t2 } = e;
  t2 && (this._theme = $(h({}, t2), { options: h(h({}, this.defaults.options), t2.options) }), this._tokens = b.createTokens(this.preset, this.defaults), this.clearLoadedStyleNames());
}, get theme() {
  return this._theme;
}, get preset() {
  var e;
  return ((e = this.theme) == null ? void 0 : e.preset) || {};
}, get options() {
  var e;
  return ((e = this.theme) == null ? void 0 : e.options) || {};
}, get tokens() {
  return this._tokens;
}, getTheme() {
  return this.theme;
}, setTheme(e) {
  this.update({ theme: e }), N.emit("theme:change", e);
}, getPreset() {
  return this.preset;
}, setPreset(e) {
  this._theme = $(h({}, this.theme), { preset: e }), this._tokens = b.createTokens(e, this.defaults), this.clearLoadedStyleNames(), N.emit("preset:change", e), N.emit("theme:change", this.theme);
}, getOptions() {
  return this.options;
}, setOptions(e) {
  this._theme = $(h({}, this.theme), { options: e }), this.clearLoadedStyleNames(), N.emit("options:change", e), N.emit("theme:change", this.theme);
}, getLayerNames() {
  return [...this._layerNames];
}, setLayerNames(e) {
  this._layerNames.add(e);
}, getLoadedStyleNames() {
  return this._loadedStyleNames;
}, isStyleNameLoaded(e) {
  return this._loadedStyleNames.has(e);
}, setLoadedStyleName(e) {
  this._loadedStyleNames.add(e);
}, deleteLoadedStyleName(e) {
  this._loadedStyleNames.delete(e);
}, clearLoadedStyleNames() {
  this._loadedStyleNames.clear();
}, getTokenValue(e) {
  return b.getTokenValue(this.tokens, e, this.defaults);
}, getCommon(e = "", t2) {
  return b.getCommon({ name: e, theme: this.theme, params: t2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, getComponent(e = "", t2) {
  let r = { name: e, theme: this.theme, params: t2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return b.getPresetC(r);
}, getDirective(e = "", t2) {
  let r = { name: e, theme: this.theme, params: t2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return b.getPresetD(r);
}, getCustomPreset(e = "", t2, r, s2) {
  let i2 = { name: e, preset: t2, options: this.options, selector: r, params: s2, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } };
  return b.getPreset(i2);
}, getLayerOrderCSS(e = "") {
  return b.getLayerOrder(e, this.options, { names: this.getLayerNames() }, this.defaults);
}, transformCSS(e = "", t2, r = "style", s2) {
  return b.transformCSS(e, t2, s2, r, this.options, { layerNames: this.setLayerNames.bind(this) }, this.defaults);
}, getCommonStyleSheet(e = "", t2, r = {}) {
  return b.getCommonStyleSheet({ name: e, theme: this.theme, params: t2, props: r, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, getStyleSheet(e, t2, r = {}) {
  return b.getStyleSheet({ name: e, theme: this.theme, params: t2, props: r, defaults: this.defaults, set: { layerNames: this.setLayerNames.bind(this) } });
}, onStyleMounted(e) {
  this._loadingStyles.add(e);
}, onStyleUpdated(e) {
  this._loadingStyles.add(e);
}, onStyleLoaded(e, { name: t2 }) {
  this._loadingStyles.size && (this._loadingStyles.delete(t2), N.emit(`theme:${t2}:load`, e), !this._loadingStyles.size && N.emit("theme:load"));
} };
var FilterMatchMode = {
  STARTS_WITH: "startsWith",
  CONTAINS: "contains",
  NOT_CONTAINS: "notContains",
  ENDS_WITH: "endsWith",
  EQUALS: "equals",
  NOT_EQUALS: "notEquals",
  LESS_THAN: "lt",
  LESS_THAN_OR_EQUAL_TO: "lte",
  GREATER_THAN: "gt",
  GREATER_THAN_OR_EQUAL_TO: "gte",
  DATE_IS: "dateIs",
  DATE_IS_NOT: "dateIsNot",
  DATE_BEFORE: "dateBefore",
  DATE_AFTER: "dateAfter"
};
var style$4 = "\n    *,\n    ::before,\n    ::after {\n        box-sizing: border-box;\n    }\n\n    .p-collapsible-enter-active {\n        animation: p-animate-collapsible-expand 0.2s ease-out;\n        overflow: hidden;\n    }\n\n    .p-collapsible-leave-active {\n        animation: p-animate-collapsible-collapse 0.2s ease-out;\n        overflow: hidden;\n    }\n\n    @keyframes p-animate-collapsible-expand {\n        from {\n            grid-template-rows: 0fr;\n        }\n        to {\n            grid-template-rows: 1fr;\n        }\n    }\n\n    @keyframes p-animate-collapsible-collapse {\n        from {\n            grid-template-rows: 1fr;\n        }\n        to {\n            grid-template-rows: 0fr;\n        }\n    }\n\n    .p-disabled,\n    .p-disabled * {\n        cursor: default;\n        pointer-events: none;\n        user-select: none;\n    }\n\n    .p-disabled,\n    .p-component:disabled {\n        opacity: dt('disabled.opacity');\n    }\n\n    .pi {\n        font-size: dt('icon.size');\n    }\n\n    .p-icon {\n        width: dt('icon.size');\n        height: dt('icon.size');\n    }\n\n    .p-overlay-mask {\n        background: var(--px-mask-background, dt('mask.background'));\n        color: dt('mask.color');\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n    .p-overlay-mask-enter-active {\n        animation: p-animate-overlay-mask-enter dt('mask.transition.duration') forwards;\n    }\n\n    .p-overlay-mask-leave-active {\n        animation: p-animate-overlay-mask-leave dt('mask.transition.duration') forwards;\n    }\n\n    @keyframes p-animate-overlay-mask-enter {\n        from {\n            background: transparent;\n        }\n        to {\n            background: var(--px-mask-background, dt('mask.background'));\n        }\n    }\n    @keyframes p-animate-overlay-mask-leave {\n        from {\n            background: var(--px-mask-background, dt('mask.background'));\n        }\n        to {\n            background: transparent;\n        }\n    }\n\n    .p-anchored-overlay-enter-active {\n        animation: p-animate-anchored-overlay-enter 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    .p-anchored-overlay-leave-active {\n        animation: p-animate-anchored-overlay-leave 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    @keyframes p-animate-anchored-overlay-enter {\n        from {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n\n    @keyframes p-animate-anchored-overlay-leave {\n        to {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n";
function _typeof$b(o) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$b(o);
}
function ownKeys$7(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$7(Object(t2), true).forEach(function(r2) {
      _defineProperty$b(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$7(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty$b(e, r, t2) {
  return (r = _toPropertyKey$b(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$b(t2) {
  var i2 = _toPrimitive$b(t2, "string");
  return "symbol" == _typeof$b(i2) ? i2 : i2 + "";
}
function _toPrimitive$b(t2, r) {
  if ("object" != _typeof$b(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$b(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
function tryOnMounted(fn) {
  var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance() && getCurrentInstance().components) onMounted(fn);
  else if (sync) fn();
  else nextTick(fn);
}
var _id = 0;
function useStyle(css3) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var isLoaded = ref(false);
  var cssRef = ref(css3);
  var styleRef = ref(null);
  var defaultDocument = tt() ? window.document : void 0;
  var _options$document = options.document, document2 = _options$document === void 0 ? defaultDocument : _options$document, _options$immediate = options.immediate, immediate = _options$immediate === void 0 ? true : _options$immediate, _options$manual = options.manual, manual = _options$manual === void 0 ? false : _options$manual, _options$name = options.name, name = _options$name === void 0 ? "style_".concat(++_id) : _options$name, _options$id = options.id, id = _options$id === void 0 ? void 0 : _options$id, _options$media = options.media, media = _options$media === void 0 ? void 0 : _options$media, _options$nonce = options.nonce, nonce = _options$nonce === void 0 ? void 0 : _options$nonce, _options$first = options.first, first = _options$first === void 0 ? false : _options$first, _options$onMounted = options.onMounted, onStyleMounted = _options$onMounted === void 0 ? void 0 : _options$onMounted, _options$onUpdated = options.onUpdated, onStyleUpdated = _options$onUpdated === void 0 ? void 0 : _options$onUpdated, _options$onLoad = options.onLoad, onStyleLoaded = _options$onLoad === void 0 ? void 0 : _options$onLoad, _options$props = options.props, props = _options$props === void 0 ? {} : _options$props;
  var stop = function stop2() {
  };
  var load2 = function load3(_css) {
    var _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!document2) return;
    var _styleProps = _objectSpread$7(_objectSpread$7({}, props), _props);
    var _name = _styleProps.name || name, _id2 = _styleProps.id || id, _nonce = _styleProps.nonce || nonce;
    styleRef.value = document2.querySelector('style[data-primevue-style-id="'.concat(_name, '"]')) || document2.getElementById(_id2) || document2.createElement("style");
    if (!styleRef.value.isConnected) {
      cssRef.value = _css || css3;
      A(styleRef.value, {
        type: "text/css",
        id: _id2,
        media,
        nonce: _nonce
      });
      first ? document2.head.prepend(styleRef.value) : document2.head.appendChild(styleRef.value);
      _t(styleRef.value, "data-primevue-style-id", _name);
      A(styleRef.value, _styleProps);
      styleRef.value.onload = function(event) {
        return onStyleLoaded === null || onStyleLoaded === void 0 ? void 0 : onStyleLoaded(event, {
          name: _name
        });
      };
      onStyleMounted === null || onStyleMounted === void 0 || onStyleMounted(_name);
    }
    if (isLoaded.value) return;
    stop = watch(cssRef, function(value) {
      styleRef.value.textContent = value;
      onStyleUpdated === null || onStyleUpdated === void 0 || onStyleUpdated(_name);
    }, {
      immediate: true
    });
    isLoaded.value = true;
  };
  var unload = function unload2() {
    if (!document2 || !isLoaded.value) return;
    stop();
    T(styleRef.value) && document2.head.removeChild(styleRef.value);
    isLoaded.value = false;
    styleRef.value = null;
  };
  if (immediate && !manual) tryOnMounted(load2);
  return {
    id,
    name,
    el: styleRef,
    css: cssRef,
    unload,
    load: load2,
    isLoaded: readonly(isLoaded)
  };
}
function _typeof$a(o) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$a(o);
}
var _templateObject, _templateObject2, _templateObject3, _templateObject4;
function _slicedToArray$2(r, e) {
  return _arrayWithHoles$2(r) || _iterableToArrayLimit$2(r, e) || _unsupportedIterableToArray$7(r, e) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$7(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$7(r, a2) : void 0;
  }
}
function _arrayLikeToArray$7(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$2(r, l2) {
  var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t2) {
    var e, n, i2, u, a2 = [], f2 = true, o = false;
    try {
      if (i2 = (t2 = t2.call(r)).next, 0 === l2) ;
      else for (; !(f2 = (e = i2.call(t2)).done) && (a2.push(e.value), a2.length !== l2); f2 = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u = t2["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$2(r) {
  if (Array.isArray(r)) return r;
}
function ownKeys$6(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$6(Object(t2), true).forEach(function(r2) {
      _defineProperty$a(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$6(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty$a(e, r, t2) {
  return (r = _toPropertyKey$a(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$a(t2) {
  var i2 = _toPrimitive$a(t2, "string");
  return "symbol" == _typeof$a(i2) ? i2 : i2 + "";
}
function _toPrimitive$a(t2, r) {
  if ("object" != _typeof$a(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$a(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
function _taggedTemplateLiteral(e, t2) {
  return t2 || (t2 = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t2) } }));
}
var css$1 = function css(_ref) {
  var dt2 = _ref.dt;
  return "\n.p-hidden-accessible {\n    border: 0;\n    clip: rect(0 0 0 0);\n    height: 1px;\n    margin: -1px;\n    opacity: 0;\n    overflow: hidden;\n    padding: 0;\n    pointer-events: none;\n    position: absolute;\n    white-space: nowrap;\n    width: 1px;\n}\n\n.p-overflow-hidden {\n    overflow: hidden;\n    padding-right: ".concat(dt2("scrollbar.width"), ";\n}\n");
};
var classes$4 = {};
var inlineStyles$1 = {};
var BaseStyle = {
  name: "base",
  css: css$1,
  style: style$4,
  classes: classes$4,
  inlineStyles: inlineStyles$1,
  load: function load(style2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var transform2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(cs) {
      return cs;
    };
    var computedStyle = transform2(ar(_templateObject || (_templateObject = _taggedTemplateLiteral(["", ""])), style2));
    return s$2(computedStyle) ? useStyle(Y$2(computedStyle), _objectSpread$6({
      name: this.name
    }, options)) : {};
  },
  loadCSS: function loadCSS() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.load(this.css, options);
  },
  loadStyle: function loadStyle() {
    var _this = this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var style2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return this.load(this.style, options, function() {
      var computedStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return S.transformCSS(options.name || _this.name, "".concat(computedStyle).concat(ar(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["", ""])), style2)));
    });
  },
  getCommonTheme: function getCommonTheme(params) {
    return S.getCommon(this.name, params);
  },
  getComponentTheme: function getComponentTheme(params) {
    return S.getComponent(this.name, params);
  },
  getDirectiveTheme: function getDirectiveTheme(params) {
    return S.getDirective(this.name, params);
  },
  getPresetTheme: function getPresetTheme(preset, selector, params) {
    return S.getCustomPreset(this.name, preset, selector, params);
  },
  getLayerOrderThemeCSS: function getLayerOrderThemeCSS() {
    return S.getLayerOrderCSS(this.name);
  },
  getStyleSheet: function getStyleSheet() {
    var extendedCSS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.css) {
      var _css = m(this.css, {
        dt: E
      }) || "";
      var _style = Y$2(ar(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["", "", ""])), _css, extendedCSS));
      var _props = Object.entries(props).reduce(function(acc, _ref2) {
        var _ref3 = _slicedToArray$2(_ref2, 2), k2 = _ref3[0], v2 = _ref3[1];
        return acc.push("".concat(k2, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      return s$2(_style) ? '<style type="text/css" data-primevue-style-id="'.concat(this.name, '" ').concat(_props, ">").concat(_style, "</style>") : "";
    }
    return "";
  },
  getCommonThemeStyleSheet: function getCommonThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return S.getCommonStyleSheet(this.name, params, props);
  },
  getThemeStyleSheet: function getThemeStyleSheet(params) {
    var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var css3 = [S.getStyleSheet(this.name, params, props)];
    if (this.style) {
      var name = this.name === "base" ? "global-style" : "".concat(this.name, "-style");
      var _css = ar(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["", ""])), m(this.style, {
        dt: E
      }));
      var _style = Y$2(S.transformCSS(name, _css));
      var _props = Object.entries(props).reduce(function(acc, _ref4) {
        var _ref5 = _slicedToArray$2(_ref4, 2), k2 = _ref5[0], v2 = _ref5[1];
        return acc.push("".concat(k2, '="').concat(v2, '"')) && acc;
      }, []).join(" ");
      s$2(_style) && css3.push('<style type="text/css" data-primevue-style-id="'.concat(name, '" ').concat(_props, ">").concat(_style, "</style>"));
    }
    return css3.join("");
  },
  extend: function extend2(inStyle) {
    return _objectSpread$6(_objectSpread$6({}, this), {}, {
      css: void 0,
      style: void 0
    }, inStyle);
  }
};
var PrimeVueService = s$1();
function _typeof$9(o) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$9(o);
}
function ownKeys$5(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$5(Object(t2), true).forEach(function(r2) {
      _defineProperty$9(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$5(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty$9(e, r, t2) {
  return (r = _toPropertyKey$9(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$9(t2) {
  var i2 = _toPrimitive$9(t2, "string");
  return "symbol" == _typeof$9(i2) ? i2 : i2 + "";
}
function _toPrimitive$9(t2, r) {
  if ("object" != _typeof$9(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$9(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var defaultOptions = {
  ripple: false,
  inputStyle: null,
  inputVariant: null,
  locale: {
    startsWith: "Starts with",
    contains: "Contains",
    notContains: "Not contains",
    endsWith: "Ends with",
    equals: "Equals",
    notEquals: "Not equals",
    noFilter: "No Filter",
    lt: "Less than",
    lte: "Less than or equal to",
    gt: "Greater than",
    gte: "Greater than or equal to",
    dateIs: "Date is",
    dateIsNot: "Date is not",
    dateBefore: "Date is before",
    dateAfter: "Date is after",
    clear: "Clear",
    apply: "Apply",
    matchAll: "Match All",
    matchAny: "Match Any",
    addRule: "Add Rule",
    removeRule: "Remove Rule",
    accept: "Yes",
    reject: "No",
    choose: "Choose",
    upload: "Upload",
    cancel: "Cancel",
    completed: "Completed",
    pending: "Pending",
    fileSizeTypes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    chooseYear: "Choose Year",
    chooseMonth: "Choose Month",
    chooseDate: "Choose Date",
    prevDecade: "Previous Decade",
    nextDecade: "Next Decade",
    prevYear: "Previous Year",
    nextYear: "Next Year",
    prevMonth: "Previous Month",
    nextMonth: "Next Month",
    prevHour: "Previous Hour",
    nextHour: "Next Hour",
    prevMinute: "Previous Minute",
    nextMinute: "Next Minute",
    prevSecond: "Previous Second",
    nextSecond: "Next Second",
    am: "am",
    pm: "pm",
    today: "Today",
    weekHeader: "Wk",
    firstDayOfWeek: 0,
    showMonthAfterYear: false,
    dateFormat: "mm/dd/yy",
    weak: "Weak",
    medium: "Medium",
    strong: "Strong",
    passwordPrompt: "Enter a password",
    emptyFilterMessage: "No results found",
    searchMessage: "{0} results are available",
    selectionMessage: "{0} items selected",
    emptySelectionMessage: "No selected item",
    emptySearchMessage: "No results found",
    fileChosenMessage: "{0} files",
    noFileChosenMessage: "No file chosen",
    emptyMessage: "No available options",
    aria: {
      trueLabel: "True",
      falseLabel: "False",
      nullLabel: "Not Selected",
      star: "1 star",
      stars: "{star} stars",
      selectAll: "All items selected",
      unselectAll: "All items unselected",
      close: "Close",
      previous: "Previous",
      next: "Next",
      navigation: "Navigation",
      scrollTop: "Scroll Top",
      moveTop: "Move Top",
      moveUp: "Move Up",
      moveDown: "Move Down",
      moveBottom: "Move Bottom",
      moveToTarget: "Move to Target",
      moveToSource: "Move to Source",
      moveAllToTarget: "Move All to Target",
      moveAllToSource: "Move All to Source",
      pageLabel: "Page {page}",
      firstPageLabel: "First Page",
      lastPageLabel: "Last Page",
      nextPageLabel: "Next Page",
      prevPageLabel: "Previous Page",
      rowsPerPageLabel: "Rows per page",
      jumpToPageDropdownLabel: "Jump to Page Dropdown",
      jumpToPageInputLabel: "Jump to Page Input",
      selectRow: "Row Selected",
      unselectRow: "Row Unselected",
      expandRow: "Row Expanded",
      collapseRow: "Row Collapsed",
      showFilterMenu: "Show Filter Menu",
      hideFilterMenu: "Hide Filter Menu",
      filterOperator: "Filter Operator",
      filterConstraint: "Filter Constraint",
      editRow: "Row Edit",
      saveEdit: "Save Edit",
      cancelEdit: "Cancel Edit",
      listView: "List View",
      gridView: "Grid View",
      slide: "Slide",
      slideNumber: "{slideNumber}",
      zoomImage: "Zoom Image",
      zoomIn: "Zoom In",
      zoomOut: "Zoom Out",
      rotateRight: "Rotate Right",
      rotateLeft: "Rotate Left",
      listLabel: "Option List"
    }
  },
  filterMatchModeOptions: {
    text: [FilterMatchMode.STARTS_WITH, FilterMatchMode.CONTAINS, FilterMatchMode.NOT_CONTAINS, FilterMatchMode.ENDS_WITH, FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS],
    numeric: [FilterMatchMode.EQUALS, FilterMatchMode.NOT_EQUALS, FilterMatchMode.LESS_THAN, FilterMatchMode.LESS_THAN_OR_EQUAL_TO, FilterMatchMode.GREATER_THAN, FilterMatchMode.GREATER_THAN_OR_EQUAL_TO],
    date: [FilterMatchMode.DATE_IS, FilterMatchMode.DATE_IS_NOT, FilterMatchMode.DATE_BEFORE, FilterMatchMode.DATE_AFTER]
  },
  zIndex: {
    modal: 1100,
    overlay: 1e3,
    menu: 1e3,
    tooltip: 1100
  },
  theme: void 0,
  unstyled: false,
  pt: void 0,
  ptOptions: {
    mergeSections: true,
    mergeProps: false
  },
  csp: {
    nonce: void 0
  }
};
var PrimeVueSymbol = Symbol();
function setup(app2, options) {
  var PrimeVue2 = {
    config: reactive(options)
  };
  app2.config.globalProperties.$primevue = PrimeVue2;
  app2.provide(PrimeVueSymbol, PrimeVue2);
  clearConfig();
  setupConfig(app2, PrimeVue2);
  return PrimeVue2;
}
var stopWatchers = [];
function clearConfig() {
  N.clear();
  stopWatchers.forEach(function(fn) {
    return fn === null || fn === void 0 ? void 0 : fn();
  });
  stopWatchers = [];
}
function setupConfig(app2, PrimeVue2) {
  var isThemeChanged = ref(false);
  var loadCommonTheme = function loadCommonTheme2() {
    var _PrimeVue$config;
    if (((_PrimeVue$config = PrimeVue2.config) === null || _PrimeVue$config === void 0 ? void 0 : _PrimeVue$config.theme) === "none") return;
    if (!S.isStyleNameLoaded("common")) {
      var _BaseStyle$getCommonT, _PrimeVue$config2;
      var _ref = ((_BaseStyle$getCommonT = BaseStyle.getCommonTheme) === null || _BaseStyle$getCommonT === void 0 ? void 0 : _BaseStyle$getCommonT.call(BaseStyle)) || {}, primitive = _ref.primitive, semantic = _ref.semantic, global2 = _ref.global, style2 = _ref.style;
      var styleOptions = {
        nonce: (_PrimeVue$config2 = PrimeVue2.config) === null || _PrimeVue$config2 === void 0 || (_PrimeVue$config2 = _PrimeVue$config2.csp) === null || _PrimeVue$config2 === void 0 ? void 0 : _PrimeVue$config2.nonce
      };
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$5({
        name: "primitive-variables"
      }, styleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$5({
        name: "semantic-variables"
      }, styleOptions));
      BaseStyle.load(global2 === null || global2 === void 0 ? void 0 : global2.css, _objectSpread$5({
        name: "global-variables"
      }, styleOptions));
      BaseStyle.loadStyle(_objectSpread$5({
        name: "global-style"
      }, styleOptions), style2);
      S.setLoadedStyleName("common");
    }
  };
  N.on("theme:change", function(newTheme) {
    if (!isThemeChanged.value) {
      app2.config.globalProperties.$primevue.config.theme = newTheme;
      isThemeChanged.value = true;
    }
  });
  var stopConfigWatcher = watch(PrimeVue2.config, function(newValue, oldValue) {
    PrimeVueService.emit("config:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopRippleWatcher = watch(function() {
    return PrimeVue2.config.ripple;
  }, function(newValue, oldValue) {
    PrimeVueService.emit("config:ripple:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  var stopThemeWatcher = watch(function() {
    return PrimeVue2.config.theme;
  }, function(newValue, oldValue) {
    if (!isThemeChanged.value) {
      S.setTheme(newValue);
    }
    if (!PrimeVue2.config.unstyled) {
      loadCommonTheme();
    }
    isThemeChanged.value = false;
    PrimeVueService.emit("config:theme:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: false
  });
  var stopUnstyledWatcher = watch(function() {
    return PrimeVue2.config.unstyled;
  }, function(newValue, oldValue) {
    if (!newValue && PrimeVue2.config.theme) {
      loadCommonTheme();
    }
    PrimeVueService.emit("config:unstyled:change", {
      newValue,
      oldValue
    });
  }, {
    immediate: true,
    deep: true
  });
  stopWatchers.push(stopConfigWatcher);
  stopWatchers.push(stopRippleWatcher);
  stopWatchers.push(stopThemeWatcher);
  stopWatchers.push(stopUnstyledWatcher);
}
var PrimeVue = {
  install: function install(app2, options) {
    var configOptions = H(defaultOptions, options);
    setup(app2, configOptions);
  }
};
/*!
  * shared v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function warn(msg, err2) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err2) {
      console.warn(err2.stack);
    }
  }
}
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$2 = Object.assign;
const _create = Object.create;
const create = (obj = null) => _create(obj);
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : create());
};
function escapeHtml(rawText) {
  return rawText.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2F;").replace(/=/g, "&#x3D;");
}
function escapeAttributeValue(value) {
  return value.replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function sanitizeTranslatedHtml(html) {
  html = html.replace(/(\w+)\s*=\s*"([^"]*)"/g, (_, attrName, attrValue) => `${attrName}="${escapeAttributeValue(attrValue)}"`);
  html = html.replace(/(\w+)\s*=\s*'([^']*)'/g, (_, attrName, attrValue) => `${attrName}='${escapeAttributeValue(attrValue)}'`);
  const eventHandlerPattern = /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi;
  if (eventHandlerPattern.test(html)) {
    html = html.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3");
  }
  const javascriptUrlPattern = [
    // In href, src, action, formaction attributes
    /(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi,
    // In style attributes within url()
    /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi
  ];
  javascriptUrlPattern.forEach((pattern) => {
    html = html.replace(pattern, "$1javascript&#58;");
  });
  return html;
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => {
  if (!isObject$1(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join$1(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
const isNotObjectOrIsArray = (val) => !isObject$1(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack2 = [{ src, des }];
  while (stack2.length) {
    const { src: src2, des: des2 } = stack2.pop();
    Object.keys(src2).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isObject$1(src2[key]) && !isObject$1(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : create();
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack2.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  return loc;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message, ...args) {
  if (args.length === 1 && isObject(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const assign$1 = Object.assign;
const isString = (val) => typeof val === "string";
const isObject = (val) => val !== null && typeof val === "object";
function join(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$1(warnMessages[code2], ...args || []);
  const message = { message: String(msg), code: code2 };
  if (loc) {
    message.location = loc;
  }
  return message;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options = {}) {
  const { domain, messages: messages2, args } = options;
  const msg = format$1((messages2 || errorMessages)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
  const isLF = (index2) => _buf[index2] === CHAR_LF;
  const isPS = (index2) => _buf[index2] === CHAR_PS;
  const isLS = (index2) => _buf[index2] === CHAR_LS;
  const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
  const index = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code2, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = location ? createLocation(ctx.startLoc, pos) : null;
      const err2 = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err2);
    }
  }
  function getToken(context2, type, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i2 = 0; i2 < digits; i2++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name = "";
    while (ch = takeIdentifierChar(scnr)) {
      name += ch;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn = (buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    };
    return fn("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    // eslint-disable-next-line no-useless-escape
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options = {}) {
  const location = options.location !== false;
  const { onError, onWarn } = options;
  function emitError(tokenzer, code2, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location ? createLocation(start, end) : null;
      const err2 = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err2);
    }
  }
  function emitWarn(tokenzer, code2, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onWarn) {
      const loc = location ? createLocation(start, end) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  function startNode(type, offset, loc) {
    const node = { type };
    if (location) {
      node.start = offset;
      node.end = offset;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset, pos, type) {
    if (location) {
      node.end = offset;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(5, offset, loc);
    node.index = parseInt(index, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(4, offset, loc);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(9, offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign$1({}, options));
    const context = tokenizer.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i2 = 0; i2 < nodes.length; i2++) {
    traverseNode(nodes[i2], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c2) => optimizeMessageNode(c2));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i2 = 0; i2 < message.items.length; i2++) {
      const item = message.items[i2];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join(values);
      for (let i2 = 0; i2 < message.items.length; i2++) {
        const item = message.items[i2];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i2 = 0; i2 < cases.length; i2++) {
        minify(cases[i2]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i2 = 0; i2 < items.length; i2++) {
        minify(items[i2]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
  const { filename, breakLineCode, needIndent: _needIndent } = options;
  const location = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code2, node) {
    _context.code += code2;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;
  for (let i2 = 0; i2 < length; i2++) {
    generateNode(generator, node.items[i2]);
    if (i2 === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;
    for (let i2 = 0; i2 < length; i2++) {
      generateNode(generator, node.cases[i2]);
      if (i2 === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
const generate = (ast, options = {}) => {
  const mode = isString(options.mode) ? options.mode : "normal";
  const filename = isString(options.filename) ? options.filename : "message.intl";
  !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    filename,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s2) => `${s2}: _${s2}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map } = generator.context();
  return {
    ast,
    code: code2,
    map: map ? map.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options = {}) {
  const assignedOptions = assign$1({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
function isMessageAST(val) {
  return isObject$1(val) && resolveType(val) === 0 && (hasOwn(val, "b") || hasOwn(val, "body"));
}
const PROPS_BODY = ["b", "body"];
function resolveBody(node) {
  return resolveProps(node, PROPS_BODY);
}
const PROPS_CASES = ["c", "cases"];
function resolveCases(node) {
  return resolveProps(node, PROPS_CASES, []);
}
const PROPS_STATIC = ["s", "static"];
function resolveStatic(node) {
  return resolveProps(node, PROPS_STATIC);
}
const PROPS_ITEMS = ["i", "items"];
function resolveItems(node) {
  return resolveProps(node, PROPS_ITEMS, []);
}
const PROPS_TYPE = ["t", "type"];
function resolveType(node) {
  return resolveProps(node, PROPS_TYPE);
}
const PROPS_VALUE = ["v", "value"];
function resolveValue$1(node, type) {
  const resolved = resolveProps(node, PROPS_VALUE);
  if (resolved != null) {
    return resolved;
  } else {
    throw createUnhandleNodeError(type);
  }
}
const PROPS_MODIFIER = ["m", "modifier"];
function resolveLinkedModifier(node) {
  return resolveProps(node, PROPS_MODIFIER);
}
const PROPS_KEY = ["k", "key"];
function resolveLinkedKey(node) {
  const resolved = resolveProps(node, PROPS_KEY);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(
      6
      /* NodeTypes.Linked */
    );
  }
}
function resolveProps(node, props, defaultValue) {
  for (let i2 = 0; i2 < props.length; i2++) {
    const prop = props[i2];
    if (hasOwn(node, prop) && node[prop] != null) {
      return node[prop];
    }
  }
  return defaultValue;
}
const AST_NODE_PROPS_KEYS = [
  ...PROPS_BODY,
  ...PROPS_CASES,
  ...PROPS_STATIC,
  ...PROPS_ITEMS,
  ...PROPS_KEY,
  ...PROPS_MODIFIER,
  ...PROPS_VALUE,
  ...PROPS_TYPE
];
function createUnhandleNodeError(type) {
  return new Error(`unhandled node type: ${type}`);
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a2 = str.charCodeAt(0);
  const b2 = str.charCodeAt(str.length - 1);
  return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    // [
    case 93:
    // ]
    case 46:
    // .
    case 34:
    // "
    case 39:
      return ch;
    case 95:
    // _
    case 36:
    // $
    case 45:
      return "i";
    case 9:
    // Tab (HT)
    case 10:
    // Newline (LF)
    case 13:
    // Return (CR)
    case 160:
    // No-break space (NBSP)
    case 65279:
    // Byte Order Mark (BOM)
    case 8232:
    // Line Separator (LS)
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse$1(path) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c2;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c2 = path[index];
    if (c2 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c2);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c2;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$1(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$1(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse$1(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i2 = 0;
  while (i2 < len) {
    const key = hit[i2];
    if (AST_NODE_PROPS_KEYS.includes(key) && isMessageAST(last)) {
      return null;
    }
    const val = last[key];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i2++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$1(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$1(options.pluralRules) && isString$1(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages2) => {
    return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || create();
  isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject$1(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$1(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$2(create(), _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString$1(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve2 = locale();
        if (isPromise(resolve2)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve2;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject$1(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults) ? [defaults] : defaults;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i2 = 0; i2 < block.length && isBoolean(follow); i2++) {
    const locale = block[i2];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i2], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.14.5";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$1(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version2 = isString$1(options.version) ? options.version : VERSION$1;
  const locale = isString$1(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages2 = isPlainObject(options.messages) ? options.messages : createResources(_locale);
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : createResources(_locale);
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : createResources(_locale);
  const modifiers = assign$2(create(), options.modifiers, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || create();
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$1(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$1(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$1(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$1(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
const createResources = (locale) => ({ [locale]: create() });
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index = locales.indexOf(targetLocale);
  if (index === -1) {
    return false;
  }
  for (let i2 = index + 1; i2 < locales.length; i2++) {
    if (isAlmostSameLocale(targetLocale, locales[i2])) {
      return true;
    }
  }
  return false;
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = resolveBody(ast);
  if (body == null) {
    throw createUnhandleNodeError(
      0
      /* NodeTypes.Resource */
    );
  }
  const type = resolveType(body);
  if (type === 1) {
    const plural = body;
    const cases = resolveCases(plural);
    return ctx.plural(cases.reduce((messages2, c2) => [
      ...messages2,
      formatMessageParts(ctx, c2)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const static_ = resolveStatic(node);
  if (static_ != null) {
    return ctx.type === "text" ? static_ : ctx.normalize([static_]);
  } else {
    const messages2 = resolveItems(node).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
    return ctx.normalize(messages2);
  }
}
function formatMessagePart(ctx, node) {
  const type = resolveType(node);
  switch (type) {
    case 3: {
      return resolveValue$1(node, type);
    }
    case 9: {
      return resolveValue$1(node, type);
    }
    case 4: {
      const named = node;
      if (hasOwn(named, "k") && named.k) {
        return ctx.interpolate(ctx.named(named.k));
      }
      if (hasOwn(named, "key") && named.key) {
        return ctx.interpolate(ctx.named(named.key));
      }
      throw createUnhandleNodeError(type);
    }
    case 5: {
      const list = node;
      if (hasOwn(list, "i") && isNumber$1(list.i)) {
        return ctx.interpolate(ctx.list(list.i));
      }
      if (hasOwn(list, "index") && isNumber$1(list.index)) {
        return ctx.interpolate(ctx.list(list.index));
      }
      throw createUnhandleNodeError(type);
    }
    case 6: {
      const linked = node;
      const modifier = resolveLinkedModifier(linked);
      const key = resolveLinkedKey(linked);
      return ctx.linked(formatMessagePart(ctx, key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      return resolveValue$1(node, type);
    }
    case 8: {
      return resolveValue$1(node, type);
    }
    default:
      throw new Error(`unhandled node on format message part: ${type}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = create();
function baseCompile(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err2) => {
    detectError = true;
    onError(err2);
  };
  return { ...baseCompile$1(message, options), detectError };
}
const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message, context) => {
  if (!isString$1(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code2, detectError } = baseCompile(message, context);
    const msg = new Function(`return ${code2}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message, context) {
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString$1(message)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: false,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message);
    } else {
      return format(message);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages2[locale] || create()
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  let ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (escapeParameter && isString$1(ret)) {
    ret = sanitizeTranslatedHtml(ret);
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$2({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$1(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = create();
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    message = messages2[targetLocale] || create();
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = (() => format2);
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = create();
  if (!isString$1(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$1(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber$1(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$2(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err2) => {
      onError && onError(err2);
      {
        throw err2;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber$1(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
    __datetimeFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  let value;
  if (isString$1(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber$1(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }
    context.__datetimeFormatters.delete(id);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
    __numberFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id)) {
      continue;
    }
    context.__numberFormatters.delete(id);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.14.5
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.14.5";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$1(obj)) {
    return obj;
  }
  if (isMessageAST(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$1(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i2 = 0; i2 < lastIndex; i2++) {
        if (subKeys[i2] === "__proto__") {
          throw new Error(`unsafe key: ${subKeys[i2]}`);
        }
        if (!(subKeys[i2] in currentObj)) {
          currentObj[subKeys[i2]] = create();
        }
        if (!isObject$1(currentObj[subKeys[i2]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i2]];
      }
      if (!hasStringValue) {
        if (!isMessageAST(currentObj)) {
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
        } else {
          if (!AST_NODE_PROPS_KEYS.includes(subKeys[lastIndex])) {
            delete obj[key];
          }
        }
      }
      if (!isMessageAST(currentObj)) {
        const target = currentObj[subKeys[lastIndex]];
        if (isObject$1(target)) {
          handleFlatJson(target);
        }
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages2) ? messages2 : isArray(__i18n) ? create() : { [locale]: create() };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || create();
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages2 = isObject$1(options.messages) ? options.messages : create();
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(gl.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages2[locale]);
    });
  }
  {
    if (isObject$1(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$1(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return ((ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  });
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler3) {
    _postTranslation = handler3;
    _context.postTranslation = handler3;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler3) {
    if (handler3 !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler3);
    }
    _missing = handler3;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) ;
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t2(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root4) => Reflect.apply(root4.t, root4, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt2(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$1(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t2(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
  }
  function d2(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root4) => Reflect.apply(root4.d, root4, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root4) => Reflect.apply(root4.n, root4, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values) {
    return values.map((val) => isString$1(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root4) => root4[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root4) => root4[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root4) => root4[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$1(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$1(resolved) : resolved != null;
    }, () => [key], "translate exists", (root4) => {
      return Reflect.apply(root4.te, root4, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages22 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i2 = 0; i2 < locales.length; i2++) {
      const targetLocaleMessages = _messages.value[locales[i2]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages22 = messageValue;
        break;
      }
    }
    return messages22;
  }
  function tm(key) {
    const messages22 = resolveMessages(key);
    return messages22 != null ? messages22 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$2(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$2(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt2;
    composer.te = te;
    composer.tm = tm;
    composer.d = d2;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  let messages2 = options.messages;
  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages2 = locales.reduce((messages22, locale2) => {
      const message = messages22[locale2] || (messages22[locale2] = {});
      assign$2(message, sharedMessages[locale2]);
      return messages22;
    }, messages2 || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages: messages2,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler3) {
        composer.setMissingHandler(handler3);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler3) {
        composer.setPostTranslationHandler(handler3);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isNumber$1(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format2) {
        composer.setDateTimeFormat(locale, format2);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format2) {
        composer.mergeDateTimeFormat(locale, format2);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format2) {
        composer.setNumberFormat(locale, format2);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format2) {
        composer.mergeNumberFormat(locale, format2);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, create());
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$2({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber$1(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs: attrs2 } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = create();
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$2(create(), attrs2);
      const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
      return h$2(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs: attrs2 } = context;
  return () => {
    const options = { part: true };
    let overrides = create();
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$1(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$2(create(), options2, { [prop]: props.format[prop] }) : options2;
      }, create());
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$1(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign$2(create(), attrs2);
    const tag = isString$1(props.tag) || isObject$1(props.tag) ? props.tag : getFragmentableTag();
    return h$2(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$2({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$2({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$1(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber$1(choice)) {
    options.plural = choice;
  }
  if (isNumber$1(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app2, i18n2, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n2.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n2.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n2.__setInstance(instance, this.$i18n);
    },
    mounted() {
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n2.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g2, options) {
  g2.locale = options.locale || g2.locale;
  g2.fallbackLocale = options.fallbackLocale || g2.fallbackLocale;
  g2.missing = options.missing || g2.missing;
  g2.silentTranslationWarn = options.silentTranslationWarn || g2.silentFallbackWarn;
  g2.silentFallbackWarn = options.silentFallbackWarn || g2.silentFallbackWarn;
  g2.formatFallbackMessages = options.formatFallbackMessages || g2.formatFallbackMessages;
  g2.postTranslation = options.postTranslation || g2.postTranslation;
  g2.warnHtmlInMessage = options.warnHtmlInMessage || g2.warnHtmlInMessage;
  g2.escapeParameterHtml = options.escapeParameterHtml || g2.escapeParameterHtml;
  g2.sync = options.sync || g2.sync;
  g2.__composer[SetPluralRulesSymbol](options.pluralizationRules || g2.pluralizationRules);
  const messages2 = getLocaleMessages(g2.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages2).forEach((locale) => g2.mergeLocaleMessage(locale, messages2[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g2.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g2;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options2) {
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app2, i18n2, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app2.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$2({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root4 = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root4 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n2, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n2.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root4, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString$1(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root4.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root4.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root4.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root4.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root4.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root4.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root4.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root4.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages2 = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler3) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler3);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler3) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler3);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t2(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt2(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d2(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format2);
      _datetimeFormats.value[locale2] = format2;
    }
  }
  function mergeDateTimeFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format2);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format2);
      _numberFormats.value[locale2] = format2;
    }
  }
  function mergeNumberFormat(locale2, format2) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format2);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages: messages2,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t: t2,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt: rt2,
    d: d2,
    n,
    tm,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
var Base = {
  _loadedStyleNames: /* @__PURE__ */ new Set(),
  getLoadedStyleNames: function getLoadedStyleNames() {
    return this._loadedStyleNames;
  },
  isStyleNameLoaded: function isStyleNameLoaded(name) {
    return this._loadedStyleNames.has(name);
  },
  setLoadedStyleName: function setLoadedStyleName(name) {
    this._loadedStyleNames.add(name);
  },
  deleteLoadedStyleName: function deleteLoadedStyleName(name) {
    this._loadedStyleNames["delete"](name);
  },
  clearLoadedStyleNames: function clearLoadedStyleNames() {
    this._loadedStyleNames.clear();
  }
};
function useAttrSelector() {
  var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pc";
  var idx = useId();
  return "".concat(prefix).concat(idx.replace("v-", "").replaceAll("-", "_"));
}
var BaseComponentStyle = BaseStyle.extend({
  name: "common"
});
function _typeof$8(o) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$8(o);
}
function _toArray(r) {
  return _arrayWithHoles$1(r) || _iterableToArray$5(r) || _unsupportedIterableToArray$6(r) || _nonIterableRest$1();
}
function _iterableToArray$5(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _slicedToArray$1(r, e) {
  return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$6(r, e) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$6(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$6(r, a2) : void 0;
  }
}
function _arrayLikeToArray$6(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit$1(r, l2) {
  var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t2) {
    var e, n, i2, u, a2 = [], f2 = true, o = false;
    try {
      if (i2 = (t2 = t2.call(r)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f2 = false;
      } else for (; !(f2 = (e = i2.call(t2)).done) && (a2.push(e.value), a2.length !== l2); f2 = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u = t2["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles$1(r) {
  if (Array.isArray(r)) return r;
}
function ownKeys$4(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$4(Object(t2), true).forEach(function(r2) {
      _defineProperty$8(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$4(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty$8(e, r, t2) {
  return (r = _toPropertyKey$8(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$8(t2) {
  var i2 = _toPrimitive$8(t2, "string");
  return "symbol" == _typeof$8(i2) ? i2 : i2 + "";
}
function _toPrimitive$8(t2, r) {
  if ("object" != _typeof$8(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$8(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var script$a = {
  name: "BaseComponent",
  props: {
    pt: {
      type: Object,
      "default": void 0
    },
    ptOptions: {
      type: Object,
      "default": void 0
    },
    unstyled: {
      type: Boolean,
      "default": void 0
    },
    dt: {
      type: Object,
      "default": void 0
    }
  },
  inject: {
    $parentInstance: {
      "default": void 0
    }
  },
  watch: {
    isUnstyled: {
      immediate: true,
      handler: function handler(newValue) {
        N.off("theme:change", this._loadCoreStyles);
        if (!newValue) {
          this._loadCoreStyles();
          this._themeChangeListener(this._loadCoreStyles);
        }
      }
    },
    dt: {
      immediate: true,
      handler: function handler2(newValue, oldValue) {
        var _this = this;
        N.off("theme:change", this._themeScopedListener);
        if (newValue) {
          this._loadScopedThemeStyles(newValue);
          this._themeScopedListener = function() {
            return _this._loadScopedThemeStyles(newValue);
          };
          this._themeChangeListener(this._themeScopedListener);
        } else {
          this._unloadScopedThemeStyles();
        }
      }
    }
  },
  scopedStyleEl: void 0,
  rootEl: void 0,
  uid: void 0,
  $attrSelector: void 0,
  beforeCreate: function beforeCreate() {
    var _this$pt, _this$pt2, _this$pt3, _ref, _ref$onBeforeCreate, _this$$primevueConfig, _this$$primevue, _this$$primevue2, _this$$primevue3, _ref2, _ref2$onBeforeCreate;
    var _usept = (_this$pt = this.pt) === null || _this$pt === void 0 ? void 0 : _this$pt["_usept"];
    var originalValue = _usept ? (_this$pt2 = this.pt) === null || _this$pt2 === void 0 || (_this$pt2 = _this$pt2.originalValue) === null || _this$pt2 === void 0 ? void 0 : _this$pt2[this.$.type.name] : void 0;
    var value = _usept ? (_this$pt3 = this.pt) === null || _this$pt3 === void 0 || (_this$pt3 = _this$pt3.value) === null || _this$pt3 === void 0 ? void 0 : _this$pt3[this.$.type.name] : this.pt;
    (_ref = value || originalValue) === null || _ref === void 0 || (_ref = _ref.hooks) === null || _ref === void 0 || (_ref$onBeforeCreate = _ref["onBeforeCreate"]) === null || _ref$onBeforeCreate === void 0 || _ref$onBeforeCreate.call(_ref);
    var _useptInConfig = (_this$$primevueConfig = this.$primevueConfig) === null || _this$$primevueConfig === void 0 || (_this$$primevueConfig = _this$$primevueConfig.pt) === null || _this$$primevueConfig === void 0 ? void 0 : _this$$primevueConfig["_usept"];
    var originalValueInConfig = _useptInConfig ? (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.pt) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.originalValue : void 0;
    var valueInConfig = _useptInConfig ? (_this$$primevue2 = this.$primevue) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.config) === null || _this$$primevue2 === void 0 || (_this$$primevue2 = _this$$primevue2.pt) === null || _this$$primevue2 === void 0 ? void 0 : _this$$primevue2.value : (_this$$primevue3 = this.$primevue) === null || _this$$primevue3 === void 0 || (_this$$primevue3 = _this$$primevue3.config) === null || _this$$primevue3 === void 0 ? void 0 : _this$$primevue3.pt;
    (_ref2 = valueInConfig || originalValueInConfig) === null || _ref2 === void 0 || (_ref2 = _ref2[this.$.type.name]) === null || _ref2 === void 0 || (_ref2 = _ref2.hooks) === null || _ref2 === void 0 || (_ref2$onBeforeCreate = _ref2["onBeforeCreate"]) === null || _ref2$onBeforeCreate === void 0 || _ref2$onBeforeCreate.call(_ref2);
    this.$attrSelector = useAttrSelector();
    this.uid = this.$attrs.id || this.$attrSelector.replace("pc", "pv_id_");
  },
  created: function created() {
    this._hook("onCreated");
  },
  beforeMount: function beforeMount() {
    var _this$$el;
    this.rootEl = z(c(this.$el) ? this.$el : (_this$$el = this.$el) === null || _this$$el === void 0 ? void 0 : _this$$el.parentElement, "[".concat(this.$attrSelector, "]"));
    if (this.rootEl) {
      this.rootEl.$pc = _objectSpread$4({
        name: this.$.type.name,
        attrSelector: this.$attrSelector
      }, this.$params);
    }
    this._loadStyles();
    this._hook("onBeforeMount");
  },
  mounted: function mounted() {
    this._hook("onMounted");
  },
  beforeUpdate: function beforeUpdate() {
    this._hook("onBeforeUpdate");
  },
  updated: function updated() {
    this._hook("onUpdated");
  },
  beforeUnmount: function beforeUnmount() {
    this._hook("onBeforeUnmount");
  },
  unmounted: function unmounted() {
    this._removeThemeListeners();
    this._unloadScopedThemeStyles();
    this._hook("onUnmounted");
  },
  methods: {
    _hook: function _hook(hookName) {
      if (!this.$options.hostName) {
        var selfHook = this._usePT(this._getPT(this.pt, this.$.type.name), this._getOptionValue, "hooks.".concat(hookName));
        var defaultHook = this._useDefaultPT(this._getOptionValue, "hooks.".concat(hookName));
        selfHook === null || selfHook === void 0 || selfHook();
        defaultHook === null || defaultHook === void 0 || defaultHook();
      }
    },
    _mergeProps: function _mergeProps(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return c$1(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
    },
    _load: function _load() {
      if (!Base.isStyleNameLoaded("base")) {
        BaseStyle.loadCSS(this.$styleOptions);
        this._loadGlobalStyles();
        Base.setLoadedStyleName("base");
      }
      this._loadThemeStyles();
    },
    _loadStyles: function _loadStyles() {
      this._load();
      this._themeChangeListener(this._load);
    },
    _loadCoreStyles: function _loadCoreStyles() {
      var _this$$style, _this$$style2;
      if (!Base.isStyleNameLoaded((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.name) && (_this$$style2 = this.$style) !== null && _this$$style2 !== void 0 && _this$$style2.name) {
        BaseComponentStyle.loadCSS(this.$styleOptions);
        this.$options.style && this.$style.loadCSS(this.$styleOptions);
        Base.setLoadedStyleName(this.$style.name);
      }
    },
    _loadGlobalStyles: function _loadGlobalStyles() {
      var globalCSS = this._useGlobalPT(this._getOptionValue, "global.css", this.$params);
      s$2(globalCSS) && BaseStyle.load(globalCSS, _objectSpread$4({
        name: "global"
      }, this.$styleOptions));
    },
    _loadThemeStyles: function _loadThemeStyles() {
      var _this$$style4, _this$$style5;
      if (this.isUnstyled || this.$theme === "none") return;
      if (!S.isStyleNameLoaded("common")) {
        var _this$$style3, _this$$style3$getComm;
        var _ref3 = ((_this$$style3 = this.$style) === null || _this$$style3 === void 0 || (_this$$style3$getComm = _this$$style3.getCommonTheme) === null || _this$$style3$getComm === void 0 ? void 0 : _this$$style3$getComm.call(_this$$style3)) || {}, primitive = _ref3.primitive, semantic = _ref3.semantic, global2 = _ref3.global, style2 = _ref3.style;
        BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$4({
          name: "primitive-variables"
        }, this.$styleOptions));
        BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$4({
          name: "semantic-variables"
        }, this.$styleOptions));
        BaseStyle.load(global2 === null || global2 === void 0 ? void 0 : global2.css, _objectSpread$4({
          name: "global-variables"
        }, this.$styleOptions));
        BaseStyle.loadStyle(_objectSpread$4({
          name: "global-style"
        }, this.$styleOptions), style2);
        S.setLoadedStyleName("common");
      }
      if (!S.isStyleNameLoaded((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.name) && (_this$$style5 = this.$style) !== null && _this$$style5 !== void 0 && _this$$style5.name) {
        var _this$$style6, _this$$style6$getComp, _this$$style7, _this$$style8;
        var _ref4 = ((_this$$style6 = this.$style) === null || _this$$style6 === void 0 || (_this$$style6$getComp = _this$$style6.getComponentTheme) === null || _this$$style6$getComp === void 0 ? void 0 : _this$$style6$getComp.call(_this$$style6)) || {}, css3 = _ref4.css, _style = _ref4.style;
        (_this$$style7 = this.$style) === null || _this$$style7 === void 0 || _this$$style7.load(css3, _objectSpread$4({
          name: "".concat(this.$style.name, "-variables")
        }, this.$styleOptions));
        (_this$$style8 = this.$style) === null || _this$$style8 === void 0 || _this$$style8.loadStyle(_objectSpread$4({
          name: "".concat(this.$style.name, "-style")
        }, this.$styleOptions), _style);
        S.setLoadedStyleName(this.$style.name);
      }
      if (!S.isStyleNameLoaded("layer-order")) {
        var _this$$style9, _this$$style9$getLaye;
        var layerOrder = (_this$$style9 = this.$style) === null || _this$$style9 === void 0 || (_this$$style9$getLaye = _this$$style9.getLayerOrderThemeCSS) === null || _this$$style9$getLaye === void 0 ? void 0 : _this$$style9$getLaye.call(_this$$style9);
        BaseStyle.load(layerOrder, _objectSpread$4({
          name: "layer-order",
          first: true
        }, this.$styleOptions));
        S.setLoadedStyleName("layer-order");
      }
    },
    _loadScopedThemeStyles: function _loadScopedThemeStyles(preset) {
      var _this$$style0, _this$$style0$getPres, _this$$style1;
      var _ref5 = ((_this$$style0 = this.$style) === null || _this$$style0 === void 0 || (_this$$style0$getPres = _this$$style0.getPresetTheme) === null || _this$$style0$getPres === void 0 ? void 0 : _this$$style0$getPres.call(_this$$style0, preset, "[".concat(this.$attrSelector, "]"))) || {}, css3 = _ref5.css;
      var scopedStyle = (_this$$style1 = this.$style) === null || _this$$style1 === void 0 ? void 0 : _this$$style1.load(css3, _objectSpread$4({
        name: "".concat(this.$attrSelector, "-").concat(this.$style.name)
      }, this.$styleOptions));
      this.scopedStyleEl = scopedStyle.el;
    },
    _unloadScopedThemeStyles: function _unloadScopedThemeStyles() {
      var _this$scopedStyleEl;
      (_this$scopedStyleEl = this.scopedStyleEl) === null || _this$scopedStyleEl === void 0 || (_this$scopedStyleEl = _this$scopedStyleEl.value) === null || _this$scopedStyleEl === void 0 || _this$scopedStyleEl.remove();
    },
    _themeChangeListener: function _themeChangeListener() {
      var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
      };
      Base.clearLoadedStyleNames();
      N.on("theme:change", callback);
    },
    _removeThemeListeners: function _removeThemeListeners() {
      N.off("theme:change", this._loadCoreStyles);
      N.off("theme:change", this._load);
      N.off("theme:change", this._themeScopedListener);
    },
    _getHostInstance: function _getHostInstance(instance) {
      return instance ? this.$options.hostName ? instance.$.type.name === this.$options.hostName ? instance : this._getHostInstance(instance.$parentInstance) : instance.$parentInstance : void 0;
    },
    _getPropValue: function _getPropValue(name) {
      var _this$_getHostInstanc;
      return this[name] || ((_this$_getHostInstanc = this._getHostInstance(this)) === null || _this$_getHostInstanc === void 0 ? void 0 : _this$_getHostInstanc[name]);
    },
    _getOptionValue: function _getOptionValue(options) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return F$2(options, key, params);
    },
    _getPTValue: function _getPTValue() {
      var _this$$primevueConfig2;
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var searchInDefaultPT = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var searchOut = /./g.test(key) && !!params[key.split(".")[0]];
      var _ref6 = this._getPropValue("ptOptions") || ((_this$$primevueConfig2 = this.$primevueConfig) === null || _this$$primevueConfig2 === void 0 ? void 0 : _this$$primevueConfig2.ptOptions) || {}, _ref6$mergeSections = _ref6.mergeSections, mergeSections = _ref6$mergeSections === void 0 ? true : _ref6$mergeSections, _ref6$mergeProps = _ref6.mergeProps, useMergeProps = _ref6$mergeProps === void 0 ? false : _ref6$mergeProps;
      var global2 = searchInDefaultPT ? searchOut ? this._useGlobalPT(this._getPTClassValue, key, params) : this._useDefaultPT(this._getPTClassValue, key, params) : void 0;
      var self2 = searchOut ? void 0 : this._getPTSelf(obj, this._getPTClassValue, key, _objectSpread$4(_objectSpread$4({}, params), {}, {
        global: global2 || {}
      }));
      var datasets = this._getPTDatasets(key);
      return mergeSections || !mergeSections && self2 ? useMergeProps ? this._mergeProps(useMergeProps, global2, self2, datasets) : _objectSpread$4(_objectSpread$4(_objectSpread$4({}, global2), self2), datasets) : _objectSpread$4(_objectSpread$4({}, self2), datasets);
    },
    _getPTSelf: function _getPTSelf() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return mergeProps(
        this._usePT.apply(this, [this._getPT(obj, this.$name)].concat(args)),
        // Exp; <component :pt="{}"
        this._usePT.apply(this, [this.$_attrsPT].concat(args))
        // Exp; <component :pt:[passthrough_key]:[attribute]="{value}" or <component :pt:[passthrough_key]="() =>{value}"
      );
    },
    _getPTDatasets: function _getPTDatasets() {
      var _this$pt4, _this$pt5;
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var datasetPrefix = "data-pc-";
      var isExtended = key === "root" && s$2((_this$pt4 = this.pt) === null || _this$pt4 === void 0 ? void 0 : _this$pt4["data-pc-section"]);
      return key !== "transition" && _objectSpread$4(_objectSpread$4({}, key === "root" && _objectSpread$4(_objectSpread$4(_defineProperty$8({}, "".concat(datasetPrefix, "name"), g$1(isExtended ? (_this$pt5 = this.pt) === null || _this$pt5 === void 0 ? void 0 : _this$pt5["data-pc-section"] : this.$.type.name)), isExtended && _defineProperty$8({}, "".concat(datasetPrefix, "extend"), g$1(this.$.type.name))), {}, _defineProperty$8({}, "".concat(this.$attrSelector), ""))), {}, _defineProperty$8({}, "".concat(datasetPrefix, "section"), g$1(key)));
    },
    _getPTClassValue: function _getPTClassValue() {
      var value = this._getOptionValue.apply(this, arguments);
      return a(value) || C$2(value) ? {
        "class": value
      } : value;
    },
    _getPT: function _getPT(pt) {
      var _this2 = this;
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var callback = arguments.length > 2 ? arguments[2] : void 0;
      var getValue = function getValue2(value) {
        var _ref8;
        var checkSameKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var computedValue = callback ? callback(value) : value;
        var _key = g$1(key);
        var _cKey = g$1(_this2.$name);
        return (_ref8 = checkSameKey ? _key !== _cKey ? computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key] : void 0 : computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _ref8 !== void 0 ? _ref8 : computedValue;
      };
      return pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept") ? {
        _usept: pt["_usept"],
        originalValue: getValue(pt.originalValue),
        value: getValue(pt.value)
      } : getValue(pt, true);
    },
    _usePT: function _usePT(pt, callback, key, params) {
      var fn = function fn2(value2) {
        return callback(value2, key, params);
      };
      if (pt !== null && pt !== void 0 && pt.hasOwnProperty("_usept")) {
        var _this$$primevueConfig3;
        var _ref9 = pt["_usept"] || ((_this$$primevueConfig3 = this.$primevueConfig) === null || _this$$primevueConfig3 === void 0 ? void 0 : _this$$primevueConfig3.ptOptions) || {}, _ref9$mergeSections = _ref9.mergeSections, mergeSections = _ref9$mergeSections === void 0 ? true : _ref9$mergeSections, _ref9$mergeProps = _ref9.mergeProps, useMergeProps = _ref9$mergeProps === void 0 ? false : _ref9$mergeProps;
        var originalValue = fn(pt.originalValue);
        var value = fn(pt.value);
        if (originalValue === void 0 && value === void 0) return void 0;
        else if (a(value)) return value;
        else if (a(originalValue)) return originalValue;
        return mergeSections || !mergeSections && value ? useMergeProps ? this._mergeProps(useMergeProps, originalValue, value) : _objectSpread$4(_objectSpread$4({}, originalValue), value) : value;
      }
      return fn(pt);
    },
    _useGlobalPT: function _useGlobalPT(callback, key, params) {
      return this._usePT(this.globalPT, callback, key, params);
    },
    _useDefaultPT: function _useDefaultPT(callback, key, params) {
      return this._usePT(this.defaultPT, callback, key, params);
    },
    ptm: function ptm() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._getPTValue(this.pt, key, _objectSpread$4(_objectSpread$4({}, this.$params), params));
    },
    ptmi: function ptmi() {
      var _attrs$id;
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var attrs2 = mergeProps(this.$_attrsWithoutPT, this.ptm(key, params));
      (attrs2 === null || attrs2 === void 0 ? void 0 : attrs2.hasOwnProperty("id")) && ((_attrs$id = attrs2.id) !== null && _attrs$id !== void 0 ? _attrs$id : attrs2.id = this.$id);
      return attrs2;
    },
    ptmo: function ptmo() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._getPTValue(obj, key, _objectSpread$4({
        instance: this
      }, params), false);
    },
    cx: function cx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return !this.isUnstyled ? this._getOptionValue(this.$style.classes, key, _objectSpread$4(_objectSpread$4({}, this.$params), params)) : void 0;
    },
    sx: function sx() {
      var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (when) {
        var self2 = this._getOptionValue(this.$style.inlineStyles, key, _objectSpread$4(_objectSpread$4({}, this.$params), params));
        var base = this._getOptionValue(BaseComponentStyle.inlineStyles, key, _objectSpread$4(_objectSpread$4({}, this.$params), params));
        return [base, self2];
      }
      return void 0;
    }
  },
  computed: {
    globalPT: function globalPT() {
      var _this$$primevueConfig4, _this3 = this;
      return this._getPT((_this$$primevueConfig4 = this.$primevueConfig) === null || _this$$primevueConfig4 === void 0 ? void 0 : _this$$primevueConfig4.pt, void 0, function(value) {
        return m(value, {
          instance: _this3
        });
      });
    },
    defaultPT: function defaultPT() {
      var _this$$primevueConfig5, _this4 = this;
      return this._getPT((_this$$primevueConfig5 = this.$primevueConfig) === null || _this$$primevueConfig5 === void 0 ? void 0 : _this$$primevueConfig5.pt, void 0, function(value) {
        return _this4._getOptionValue(value, _this4.$name, _objectSpread$4({}, _this4.$params)) || m(value, _objectSpread$4({}, _this4.$params));
      });
    },
    isUnstyled: function isUnstyled() {
      var _this$$primevueConfig6;
      return this.unstyled !== void 0 ? this.unstyled : (_this$$primevueConfig6 = this.$primevueConfig) === null || _this$$primevueConfig6 === void 0 ? void 0 : _this$$primevueConfig6.unstyled;
    },
    $id: function $id() {
      return this.$attrs.id || this.uid;
    },
    $inProps: function $inProps() {
      var _this$$$vnode;
      var nodePropKeys = Object.keys(((_this$$$vnode = this.$.vnode) === null || _this$$$vnode === void 0 ? void 0 : _this$$$vnode.props) || {});
      return Object.fromEntries(Object.entries(this.$props).filter(function(_ref0) {
        var _ref1 = _slicedToArray$1(_ref0, 1), k2 = _ref1[0];
        return nodePropKeys === null || nodePropKeys === void 0 ? void 0 : nodePropKeys.includes(k2);
      }));
    },
    $theme: function $theme() {
      var _this$$primevueConfig7;
      return (_this$$primevueConfig7 = this.$primevueConfig) === null || _this$$primevueConfig7 === void 0 ? void 0 : _this$$primevueConfig7.theme;
    },
    $style: function $style() {
      return _objectSpread$4(_objectSpread$4({
        classes: void 0,
        inlineStyles: void 0,
        load: function load2() {
        },
        loadCSS: function loadCSS2() {
        },
        loadStyle: function loadStyle2() {
        }
      }, (this._getHostInstance(this) || {}).$style), this.$options.style);
    },
    $styleOptions: function $styleOptions() {
      var _this$$primevueConfig8;
      return {
        nonce: (_this$$primevueConfig8 = this.$primevueConfig) === null || _this$$primevueConfig8 === void 0 || (_this$$primevueConfig8 = _this$$primevueConfig8.csp) === null || _this$$primevueConfig8 === void 0 ? void 0 : _this$$primevueConfig8.nonce
      };
    },
    $primevueConfig: function $primevueConfig() {
      var _this$$primevue4;
      return (_this$$primevue4 = this.$primevue) === null || _this$$primevue4 === void 0 ? void 0 : _this$$primevue4.config;
    },
    $name: function $name() {
      return this.$options.hostName || this.$.type.name;
    },
    $params: function $params() {
      var parentInstance = this._getHostInstance(this) || this.$parent;
      return {
        instance: this,
        props: this.$props,
        state: this.$data,
        attrs: this.$attrs,
        parent: {
          instance: parentInstance,
          props: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$props,
          state: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$data,
          attrs: parentInstance === null || parentInstance === void 0 ? void 0 : parentInstance.$attrs
        }
      };
    },
    $_attrsPT: function $_attrsPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref10) {
        var _ref11 = _slicedToArray$1(_ref10, 1), key = _ref11[0];
        return key === null || key === void 0 ? void 0 : key.startsWith("pt:");
      }).reduce(function(result, _ref12) {
        var _ref13 = _slicedToArray$1(_ref12, 2), key = _ref13[0], value = _ref13[1];
        var _key$split = key.split(":"), _key$split2 = _toArray(_key$split), rest = _arrayLikeToArray$6(_key$split2).slice(1);
        rest === null || rest === void 0 || rest.reduce(function(currentObj, nestedKey, index, array) {
          !currentObj[nestedKey] && (currentObj[nestedKey] = index === array.length - 1 ? value : {});
          return currentObj[nestedKey];
        }, result);
        return result;
      }, {});
    },
    $_attrsWithoutPT: function $_attrsWithoutPT() {
      return Object.entries(this.$attrs || {}).filter(function(_ref14) {
        var _ref15 = _slicedToArray$1(_ref14, 1), key = _ref15[0];
        return !(key !== null && key !== void 0 && key.startsWith("pt:"));
      }).reduce(function(acc, _ref16) {
        var _ref17 = _slicedToArray$1(_ref16, 2), key = _ref17[0], value = _ref17[1];
        acc[key] = value;
        return acc;
      }, {});
    }
  }
};
var css2 = "\n.p-icon {\n    display: inline-block;\n    vertical-align: baseline;\n    flex-shrink: 0;\n}\n\n.p-icon-spin {\n    -webkit-animation: p-icon-spin 2s infinite linear;\n    animation: p-icon-spin 2s infinite linear;\n}\n\n@-webkit-keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n\n@keyframes p-icon-spin {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n    100% {\n        -webkit-transform: rotate(359deg);\n        transform: rotate(359deg);\n    }\n}\n";
var BaseIconStyle = BaseStyle.extend({
  name: "baseicon",
  css: css2
});
function _typeof$7(o) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$7(o);
}
function ownKeys$3(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$3(Object(t2), true).forEach(function(r2) {
      _defineProperty$7(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$3(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty$7(e, r, t2) {
  return (r = _toPropertyKey$7(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$7(t2) {
  var i2 = _toPrimitive$7(t2, "string");
  return "symbol" == _typeof$7(i2) ? i2 : i2 + "";
}
function _toPrimitive$7(t2, r) {
  if ("object" != _typeof$7(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$7(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var script$9 = {
  name: "BaseIcon",
  "extends": script$a,
  props: {
    label: {
      type: String,
      "default": void 0
    },
    spin: {
      type: Boolean,
      "default": false
    }
  },
  style: BaseIconStyle,
  provide: function provide2() {
    return {
      $pcIcon: this,
      $parentInstance: this
    };
  },
  methods: {
    pti: function pti() {
      var isLabelEmpty = l(this.label);
      return _objectSpread$3(_objectSpread$3({}, !this.isUnstyled && {
        "class": ["p-icon", {
          "p-icon-spin": this.spin
        }]
      }), {}, {
        role: !isLabelEmpty ? "img" : void 0,
        "aria-label": !isLabelEmpty ? this.label : void 0,
        "aria-hidden": isLabelEmpty
      });
    }
  }
};
var script$8 = {
  name: "TimesIcon",
  "extends": script$9
};
function _toConsumableArray$4(r) {
  return _arrayWithoutHoles$4(r) || _iterableToArray$4(r) || _unsupportedIterableToArray$5(r) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$5(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$5(r, a2) : void 0;
  }
}
function _iterableToArray$4(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$4(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$5(r);
}
function _arrayLikeToArray$5(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$4(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    d: "M8.01186 7.00933L12.27 2.75116C12.341 2.68501 12.398 2.60524 12.4375 2.51661C12.4769 2.42798 12.4982 2.3323 12.4999 2.23529C12.5016 2.13827 12.4838 2.0419 12.4474 1.95194C12.4111 1.86197 12.357 1.78024 12.2884 1.71163C12.2198 1.64302 12.138 1.58893 12.0481 1.55259C11.9581 1.51625 11.8617 1.4984 11.7647 1.50011C11.6677 1.50182 11.572 1.52306 11.4834 1.56255C11.3948 1.60204 11.315 1.65898 11.2488 1.72997L6.99067 5.98814L2.7325 1.72997C2.59553 1.60234 2.41437 1.53286 2.22718 1.53616C2.03999 1.53946 1.8614 1.61529 1.72901 1.74767C1.59663 1.88006 1.5208 2.05865 1.5175 2.24584C1.5142 2.43303 1.58368 2.61419 1.71131 2.75116L5.96948 7.00933L1.71131 11.2675C1.576 11.403 1.5 11.5866 1.5 11.7781C1.5 11.9696 1.576 12.1532 1.71131 12.2887C1.84679 12.424 2.03043 12.5 2.2219 12.5C2.41338 12.5 2.59702 12.424 2.7325 12.2887L6.99067 8.03052L11.2488 12.2887C11.3843 12.424 11.568 12.5 11.7594 12.5C11.9509 12.5 12.1346 12.424 12.27 12.2887C12.4053 12.1532 12.4813 11.9696 12.4813 11.7781C12.4813 11.5866 12.4053 11.403 12.27 11.2675L8.01186 7.00933Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$8.render = render$7;
var script$7 = {
  name: "WindowMaximizeIcon",
  "extends": script$9
};
function _toConsumableArray$3(r) {
  return _arrayWithoutHoles$3(r) || _iterableToArray$3(r) || _unsupportedIterableToArray$4(r) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$4(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$4(r, a2) : void 0;
  }
}
function _iterableToArray$3(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$3(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$4(r);
}
function _arrayLikeToArray$4(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$3(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14ZM9.77805 7.42192C9.89013 7.534 10.0415 7.59788 10.2 7.59995C10.3585 7.59788 10.5099 7.534 10.622 7.42192C10.7341 7.30985 10.798 7.15844 10.8 6.99995V3.94242C10.8066 3.90505 10.8096 3.86689 10.8089 3.82843C10.8079 3.77159 10.7988 3.7157 10.7824 3.6623C10.756 3.55552 10.701 3.45698 10.622 3.37798C10.5099 3.2659 10.3585 3.20202 10.2 3.19995H7.00002C6.84089 3.19995 6.68828 3.26317 6.57576 3.37569C6.46324 3.48821 6.40002 3.64082 6.40002 3.79995C6.40002 3.95908 6.46324 4.11169 6.57576 4.22422C6.68828 4.33674 6.84089 4.39995 7.00002 4.39995H8.80006L6.19997 7.00005C6.10158 7.11005 6.04718 7.25246 6.04718 7.40005C6.04718 7.54763 6.10158 7.69004 6.19997 7.80005C6.30202 7.91645 6.44561 7.98824 6.59997 8.00005C6.75432 7.98824 6.89791 7.91645 6.99997 7.80005L9.60002 5.26841V6.99995C9.6021 7.15844 9.66598 7.30985 9.77805 7.42192ZM1.4 14H3.8C4.17066 13.9979 4.52553 13.8498 4.78763 13.5877C5.04973 13.3256 5.1979 12.9707 5.2 12.6V10.2C5.1979 9.82939 5.04973 9.47452 4.78763 9.21242C4.52553 8.95032 4.17066 8.80215 3.8 8.80005H1.4C1.02934 8.80215 0.674468 8.95032 0.412371 9.21242C0.150274 9.47452 0.00210008 9.82939 0 10.2V12.6C0.00210008 12.9707 0.150274 13.3256 0.412371 13.5877C0.674468 13.8498 1.02934 13.9979 1.4 14ZM1.25858 10.0586C1.29609 10.0211 1.34696 10 1.4 10H3.8C3.85304 10 3.90391 10.0211 3.94142 10.0586C3.97893 10.0961 4 10.147 4 10.2V12.6C4 12.6531 3.97893 12.704 3.94142 12.7415C3.90391 12.779 3.85304 12.8 3.8 12.8H1.4C1.34696 12.8 1.29609 12.779 1.25858 12.7415C1.22107 12.704 1.2 12.6531 1.2 12.6V10.2C1.2 10.147 1.22107 10.0961 1.25858 10.0586Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$7.render = render$6;
var script$6 = {
  name: "WindowMinimizeIcon",
  "extends": script$9
};
function _toConsumableArray$2(r) {
  return _arrayWithoutHoles$2(r) || _iterableToArray$2(r) || _unsupportedIterableToArray$3(r) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$3(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$3(r, a2) : void 0;
  }
}
function _iterableToArray$2(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$2(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$3(r);
}
function _arrayLikeToArray$3(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$2(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M11.8 0H2.2C1.61652 0 1.05694 0.231785 0.644365 0.644365C0.231785 1.05694 0 1.61652 0 2.2V7C0 7.15913 0.063214 7.31174 0.175736 7.42426C0.288258 7.53679 0.44087 7.6 0.6 7.6C0.75913 7.6 0.911742 7.53679 1.02426 7.42426C1.13679 7.31174 1.2 7.15913 1.2 7V2.2C1.2 1.93478 1.30536 1.68043 1.49289 1.49289C1.68043 1.30536 1.93478 1.2 2.2 1.2H11.8C12.0652 1.2 12.3196 1.30536 12.5071 1.49289C12.6946 1.68043 12.8 1.93478 12.8 2.2V11.8C12.8 12.0652 12.6946 12.3196 12.5071 12.5071C12.3196 12.6946 12.0652 12.8 11.8 12.8H7C6.84087 12.8 6.68826 12.8632 6.57574 12.9757C6.46321 13.0883 6.4 13.2409 6.4 13.4C6.4 13.5591 6.46321 13.7117 6.57574 13.8243C6.68826 13.9368 6.84087 14 7 14H11.8C12.3835 14 12.9431 13.7682 13.3556 13.3556C13.7682 12.9431 14 12.3835 14 11.8V2.2C14 1.61652 13.7682 1.05694 13.3556 0.644365C12.9431 0.231785 12.3835 0 11.8 0ZM6.368 7.952C6.44137 7.98326 6.52025 7.99958 6.6 8H9.8C9.95913 8 10.1117 7.93678 10.2243 7.82426C10.3368 7.71174 10.4 7.55913 10.4 7.4C10.4 7.24087 10.3368 7.08826 10.2243 6.97574C10.1117 6.86321 9.95913 6.8 9.8 6.8H8.048L10.624 4.224C10.73 4.11026 10.7877 3.95982 10.7849 3.80438C10.7822 3.64894 10.7192 3.50063 10.6093 3.3907C10.4994 3.28077 10.3511 3.2178 10.1956 3.21506C10.0402 3.21232 9.88974 3.27002 9.776 3.376L7.2 5.952V4.2C7.2 4.04087 7.13679 3.88826 7.02426 3.77574C6.91174 3.66321 6.75913 3.6 6.6 3.6C6.44087 3.6 6.28826 3.66321 6.17574 3.77574C6.06321 3.88826 6 4.04087 6 4.2V7.4C6.00042 7.47975 6.01674 7.55862 6.048 7.632C6.07656 7.70442 6.11971 7.7702 6.17475 7.82524C6.2298 7.88029 6.29558 7.92344 6.368 7.952ZM1.4 8.80005H3.8C4.17066 8.80215 4.52553 8.95032 4.78763 9.21242C5.04973 9.47452 5.1979 9.82939 5.2 10.2V12.6C5.1979 12.9707 5.04973 13.3256 4.78763 13.5877C4.52553 13.8498 4.17066 13.9979 3.8 14H1.4C1.02934 13.9979 0.674468 13.8498 0.412371 13.5877C0.150274 13.3256 0.00210008 12.9707 0 12.6V10.2C0.00210008 9.82939 0.150274 9.47452 0.412371 9.21242C0.674468 8.95032 1.02934 8.80215 1.4 8.80005ZM3.94142 12.7415C3.97893 12.704 4 12.6531 4 12.6V10.2C4 10.147 3.97893 10.0961 3.94142 10.0586C3.90391 10.0211 3.85304 10 3.8 10H1.4C1.34696 10 1.29609 10.0211 1.25858 10.0586C1.22107 10.0961 1.2 10.147 1.2 10.2V12.6C1.2 12.6531 1.22107 12.704 1.25858 12.7415C1.29609 12.779 1.34696 12.8 1.4 12.8H3.8C3.85304 12.8 3.90391 12.779 3.94142 12.7415Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$6.render = render$5;
var script$5 = {
  name: "SpinnerIcon",
  "extends": script$9
};
function _toConsumableArray$1(r) {
  return _arrayWithoutHoles$1(r) || _iterableToArray$1(r) || _unsupportedIterableToArray$2(r) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$2(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$2(r, a2) : void 0;
  }
}
function _iterableToArray$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$2(r);
}
function _arrayLikeToArray$2(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", mergeProps({
    width: "14",
    height: "14",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _ctx.pti()), _toConsumableArray$1(_cache[0] || (_cache[0] = [createBaseVNode("path", {
    d: "M6.99701 14C5.85441 13.999 4.72939 13.7186 3.72012 13.1832C2.71084 12.6478 1.84795 11.8737 1.20673 10.9284C0.565504 9.98305 0.165424 8.89526 0.041387 7.75989C-0.0826496 6.62453 0.073125 5.47607 0.495122 4.4147C0.917119 3.35333 1.59252 2.4113 2.46241 1.67077C3.33229 0.930247 4.37024 0.413729 5.4857 0.166275C6.60117 -0.0811796 7.76026 -0.0520535 8.86188 0.251112C9.9635 0.554278 10.9742 1.12227 11.8057 1.90555C11.915 2.01493 11.9764 2.16319 11.9764 2.31778C11.9764 2.47236 11.915 2.62062 11.8057 2.73C11.7521 2.78503 11.688 2.82877 11.6171 2.85864C11.5463 2.8885 11.4702 2.90389 11.3933 2.90389C11.3165 2.90389 11.2404 2.8885 11.1695 2.85864C11.0987 2.82877 11.0346 2.78503 10.9809 2.73C9.9998 1.81273 8.73246 1.26138 7.39226 1.16876C6.05206 1.07615 4.72086 1.44794 3.62279 2.22152C2.52471 2.99511 1.72683 4.12325 1.36345 5.41602C1.00008 6.70879 1.09342 8.08723 1.62775 9.31926C2.16209 10.5513 3.10478 11.5617 4.29713 12.1803C5.48947 12.7989 6.85865 12.988 8.17414 12.7157C9.48963 12.4435 10.6711 11.7264 11.5196 10.6854C12.3681 9.64432 12.8319 8.34282 12.8328 7C12.8328 6.84529 12.8943 6.69692 13.0038 6.58752C13.1132 6.47812 13.2616 6.41667 13.4164 6.41667C13.5712 6.41667 13.7196 6.47812 13.8291 6.58752C13.9385 6.69692 14 6.84529 14 7C14 8.85651 13.2622 10.637 11.9489 11.9497C10.6356 13.2625 8.85432 14 6.99701 14Z",
    fill: "currentColor"
  }, null, -1)])), 16);
}
script$5.render = render$4;
var style$3 = "\n    .p-badge {\n        display: inline-flex;\n        border-radius: dt('badge.border.radius');\n        align-items: center;\n        justify-content: center;\n        padding: dt('badge.padding');\n        background: dt('badge.primary.background');\n        color: dt('badge.primary.color');\n        font-size: dt('badge.font.size');\n        font-weight: dt('badge.font.weight');\n        min-width: dt('badge.min.width');\n        height: dt('badge.height');\n    }\n\n    .p-badge-dot {\n        width: dt('badge.dot.size');\n        min-width: dt('badge.dot.size');\n        height: dt('badge.dot.size');\n        border-radius: 50%;\n        padding: 0;\n    }\n\n    .p-badge-circle {\n        padding: 0;\n        border-radius: 50%;\n    }\n\n    .p-badge-secondary {\n        background: dt('badge.secondary.background');\n        color: dt('badge.secondary.color');\n    }\n\n    .p-badge-success {\n        background: dt('badge.success.background');\n        color: dt('badge.success.color');\n    }\n\n    .p-badge-info {\n        background: dt('badge.info.background');\n        color: dt('badge.info.color');\n    }\n\n    .p-badge-warn {\n        background: dt('badge.warn.background');\n        color: dt('badge.warn.color');\n    }\n\n    .p-badge-danger {\n        background: dt('badge.danger.background');\n        color: dt('badge.danger.color');\n    }\n\n    .p-badge-contrast {\n        background: dt('badge.contrast.background');\n        color: dt('badge.contrast.color');\n    }\n\n    .p-badge-sm {\n        font-size: dt('badge.sm.font.size');\n        min-width: dt('badge.sm.min.width');\n        height: dt('badge.sm.height');\n    }\n\n    .p-badge-lg {\n        font-size: dt('badge.lg.font.size');\n        min-width: dt('badge.lg.min.width');\n        height: dt('badge.lg.height');\n    }\n\n    .p-badge-xl {\n        font-size: dt('badge.xl.font.size');\n        min-width: dt('badge.xl.min.width');\n        height: dt('badge.xl.height');\n    }\n";
var classes$3 = {
  root: function root(_ref) {
    var props = _ref.props, instance = _ref.instance;
    return ["p-badge p-component", {
      "p-badge-circle": s$2(props.value) && String(props.value).length === 1,
      "p-badge-dot": l(props.value) && !instance.$slots["default"],
      "p-badge-sm": props.size === "small",
      "p-badge-lg": props.size === "large",
      "p-badge-xl": props.size === "xlarge",
      "p-badge-info": props.severity === "info",
      "p-badge-success": props.severity === "success",
      "p-badge-warn": props.severity === "warn",
      "p-badge-danger": props.severity === "danger",
      "p-badge-secondary": props.severity === "secondary",
      "p-badge-contrast": props.severity === "contrast"
    }];
  }
};
var BadgeStyle = BaseStyle.extend({
  name: "badge",
  style: style$3,
  classes: classes$3
});
var script$1$2 = {
  name: "BaseBadge",
  "extends": script$a,
  props: {
    value: {
      type: [String, Number],
      "default": null
    },
    severity: {
      type: String,
      "default": null
    },
    size: {
      type: String,
      "default": null
    }
  },
  style: BadgeStyle,
  provide: function provide3() {
    return {
      $pcBadge: this,
      $parentInstance: this
    };
  }
};
function _typeof$6(o) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$6(o);
}
function _defineProperty$6(e, r, t2) {
  return (r = _toPropertyKey$6(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$6(t2) {
  var i2 = _toPrimitive$6(t2, "string");
  return "symbol" == _typeof$6(i2) ? i2 : i2 + "";
}
function _toPrimitive$6(t2, r) {
  if ("object" != _typeof$6(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var script$4 = {
  name: "Badge",
  "extends": script$1$2,
  inheritAttrs: false,
  computed: {
    dataP: function dataP() {
      return f(_defineProperty$6(_defineProperty$6({
        circle: this.value != null && String(this.value).length === 1,
        empty: this.value == null && !this.$slots["default"]
      }, this.severity, this.severity), this.size, this.size));
    }
  }
};
var _hoisted_1$3 = ["data-p"];
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps({
    "class": _ctx.cx("root"),
    "data-p": $options.dataP
  }, _ctx.ptmi("root")), [renderSlot(_ctx.$slots, "default", {}, function() {
    return [createTextVNode(toDisplayString$1(_ctx.value), 1)];
  })], 16, _hoisted_1$3);
}
script$4.render = render$3;
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$1(r, a2) : void 0;
  }
}
function _arrayLikeToArray$1(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit(r, l2) {
  var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t2) {
    var e, n, i2, u, a2 = [], f2 = true, o = false;
    try {
      if (i2 = (t2 = t2.call(r)).next, 0 === l2) ;
      else for (; !(f2 = (e = i2.call(t2)).done) && (a2.push(e.value), a2.length !== l2); f2 = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u = t2["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function ownKeys$2(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2(Object(t2), true).forEach(function(r2) {
      _defineProperty$5(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty$5(e, r, t2) {
  return (r = _toPropertyKey$5(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$5(t2) {
  var i2 = _toPrimitive$5(t2, "string");
  return "symbol" == _typeof$5(i2) ? i2 : i2 + "";
}
function _toPrimitive$5(t2, r) {
  if ("object" != _typeof$5(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var BaseDirective = {
  _getMeta: function _getMeta() {
    return [i(arguments.length <= 0 ? void 0 : arguments[0]) ? void 0 : arguments.length <= 0 ? void 0 : arguments[0], m(i(arguments.length <= 0 ? void 0 : arguments[0]) ? arguments.length <= 0 ? void 0 : arguments[0] : arguments.length <= 1 ? void 0 : arguments[1])];
  },
  _getConfig: function _getConfig(binding, vnode) {
    var _ref, _binding$instance, _vnode$ctx;
    return (_ref = (binding === null || binding === void 0 || (_binding$instance = binding.instance) === null || _binding$instance === void 0 ? void 0 : _binding$instance.$primevue) || (vnode === null || vnode === void 0 || (_vnode$ctx = vnode.ctx) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.appContext) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.config) === null || _vnode$ctx === void 0 || (_vnode$ctx = _vnode$ctx.globalProperties) === null || _vnode$ctx === void 0 ? void 0 : _vnode$ctx.$primevue)) === null || _ref === void 0 ? void 0 : _ref.config;
  },
  _getOptionValue: F$2,
  _getPTValue: function _getPTValue2() {
    var _instance$binding, _instance$$primevueCo;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var obj = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    var params = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var searchInDefaultPT = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var getValue = function getValue2() {
      var value = BaseDirective._getOptionValue.apply(BaseDirective, arguments);
      return a(value) || C$2(value) ? {
        "class": value
      } : value;
    };
    var _ref2 = ((_instance$binding = instance.binding) === null || _instance$binding === void 0 || (_instance$binding = _instance$binding.value) === null || _instance$binding === void 0 ? void 0 : _instance$binding.ptOptions) || ((_instance$$primevueCo = instance.$primevueConfig) === null || _instance$$primevueCo === void 0 ? void 0 : _instance$$primevueCo.ptOptions) || {}, _ref2$mergeSections = _ref2.mergeSections, mergeSections = _ref2$mergeSections === void 0 ? true : _ref2$mergeSections, _ref2$mergeProps = _ref2.mergeProps, useMergeProps = _ref2$mergeProps === void 0 ? false : _ref2$mergeProps;
    var global2 = searchInDefaultPT ? BaseDirective._useDefaultPT(instance, instance.defaultPT(), getValue, key, params) : void 0;
    var self2 = BaseDirective._usePT(instance, BaseDirective._getPT(obj, instance.$name), getValue, key, _objectSpread$2(_objectSpread$2({}, params), {}, {
      global: global2 || {}
    }));
    var datasets = BaseDirective._getPTDatasets(instance, key);
    return mergeSections || !mergeSections && self2 ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, global2, self2, datasets) : _objectSpread$2(_objectSpread$2(_objectSpread$2({}, global2), self2), datasets) : _objectSpread$2(_objectSpread$2({}, self2), datasets);
  },
  _getPTDatasets: function _getPTDatasets2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var datasetPrefix = "data-pc-";
    return _objectSpread$2(_objectSpread$2({}, key === "root" && _defineProperty$5({}, "".concat(datasetPrefix, "name"), g$1(instance.$name))), {}, _defineProperty$5({}, "".concat(datasetPrefix, "section"), g$1(key)));
  },
  _getPT: function _getPT2(pt) {
    var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var getValue = function getValue2(value) {
      var _computedValue$_key;
      var computedValue = callback ? callback(value) : value;
      var _key = g$1(key);
      return (_computedValue$_key = computedValue === null || computedValue === void 0 ? void 0 : computedValue[_key]) !== null && _computedValue$_key !== void 0 ? _computedValue$_key : computedValue;
    };
    return pt && Object.hasOwn(pt, "_usept") ? {
      _usept: pt["_usept"],
      originalValue: getValue(pt.originalValue),
      value: getValue(pt.value)
    } : getValue(pt);
  },
  _usePT: function _usePT2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var pt = arguments.length > 1 ? arguments[1] : void 0;
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    var fn = function fn2(value2) {
      return callback(value2, key, params);
    };
    if (pt && Object.hasOwn(pt, "_usept")) {
      var _instance$$primevueCo2;
      var _ref4 = pt["_usept"] || ((_instance$$primevueCo2 = instance.$primevueConfig) === null || _instance$$primevueCo2 === void 0 ? void 0 : _instance$$primevueCo2.ptOptions) || {}, _ref4$mergeSections = _ref4.mergeSections, mergeSections = _ref4$mergeSections === void 0 ? true : _ref4$mergeSections, _ref4$mergeProps = _ref4.mergeProps, useMergeProps = _ref4$mergeProps === void 0 ? false : _ref4$mergeProps;
      var originalValue = fn(pt.originalValue);
      var value = fn(pt.value);
      if (originalValue === void 0 && value === void 0) return void 0;
      else if (a(value)) return value;
      else if (a(originalValue)) return originalValue;
      return mergeSections || !mergeSections && value ? useMergeProps ? BaseDirective._mergeProps(instance, useMergeProps, originalValue, value) : _objectSpread$2(_objectSpread$2({}, originalValue), value) : value;
    }
    return fn(pt);
  },
  _useDefaultPT: function _useDefaultPT2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaultPT2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var callback = arguments.length > 2 ? arguments[2] : void 0;
    var key = arguments.length > 3 ? arguments[3] : void 0;
    var params = arguments.length > 4 ? arguments[4] : void 0;
    return BaseDirective._usePT(instance, defaultPT2, callback, key, params);
  },
  _loadStyles: function _loadStyles2() {
    var _config$csp;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var binding = arguments.length > 1 ? arguments[1] : void 0;
    var vnode = arguments.length > 2 ? arguments[2] : void 0;
    var config = BaseDirective._getConfig(binding, vnode);
    var useStyleOptions = {
      nonce: config === null || config === void 0 || (_config$csp = config.csp) === null || _config$csp === void 0 ? void 0 : _config$csp.nonce
    };
    BaseDirective._loadCoreStyles(instance, useStyleOptions);
    BaseDirective._loadThemeStyles(instance, useStyleOptions);
    BaseDirective._loadScopedThemeStyles(instance, useStyleOptions);
    BaseDirective._removeThemeListeners(instance);
    instance.$loadStyles = function() {
      return BaseDirective._loadThemeStyles(instance, useStyleOptions);
    };
    BaseDirective._themeChangeListener(instance.$loadStyles);
  },
  _loadCoreStyles: function _loadCoreStyles2() {
    var _instance$$style, _instance$$style2;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (!Base.isStyleNameLoaded((_instance$$style = instance.$style) === null || _instance$$style === void 0 ? void 0 : _instance$$style.name) && (_instance$$style2 = instance.$style) !== null && _instance$$style2 !== void 0 && _instance$$style2.name) {
      var _instance$$style3;
      BaseStyle.loadCSS(useStyleOptions);
      (_instance$$style3 = instance.$style) === null || _instance$$style3 === void 0 || _instance$$style3.loadCSS(useStyleOptions);
      Base.setLoadedStyleName(instance.$style.name);
    }
  },
  _loadThemeStyles: function _loadThemeStyles2() {
    var _instance$theme, _instance$$style5, _instance$$style6;
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    if (instance !== null && instance !== void 0 && instance.isUnstyled() || (instance === null || instance === void 0 || (_instance$theme = instance.theme) === null || _instance$theme === void 0 ? void 0 : _instance$theme.call(instance)) === "none") return;
    if (!S.isStyleNameLoaded("common")) {
      var _instance$$style4, _instance$$style4$get;
      var _ref5 = ((_instance$$style4 = instance.$style) === null || _instance$$style4 === void 0 || (_instance$$style4$get = _instance$$style4.getCommonTheme) === null || _instance$$style4$get === void 0 ? void 0 : _instance$$style4$get.call(_instance$$style4)) || {}, primitive = _ref5.primitive, semantic = _ref5.semantic, global2 = _ref5.global, style2 = _ref5.style;
      BaseStyle.load(primitive === null || primitive === void 0 ? void 0 : primitive.css, _objectSpread$2({
        name: "primitive-variables"
      }, useStyleOptions));
      BaseStyle.load(semantic === null || semantic === void 0 ? void 0 : semantic.css, _objectSpread$2({
        name: "semantic-variables"
      }, useStyleOptions));
      BaseStyle.load(global2 === null || global2 === void 0 ? void 0 : global2.css, _objectSpread$2({
        name: "global-variables"
      }, useStyleOptions));
      BaseStyle.loadStyle(_objectSpread$2({
        name: "global-style"
      }, useStyleOptions), style2);
      S.setLoadedStyleName("common");
    }
    if (!S.isStyleNameLoaded((_instance$$style5 = instance.$style) === null || _instance$$style5 === void 0 ? void 0 : _instance$$style5.name) && (_instance$$style6 = instance.$style) !== null && _instance$$style6 !== void 0 && _instance$$style6.name) {
      var _instance$$style7, _instance$$style7$get, _instance$$style8, _instance$$style9;
      var _ref6 = ((_instance$$style7 = instance.$style) === null || _instance$$style7 === void 0 || (_instance$$style7$get = _instance$$style7.getDirectiveTheme) === null || _instance$$style7$get === void 0 ? void 0 : _instance$$style7$get.call(_instance$$style7)) || {}, css3 = _ref6.css, _style = _ref6.style;
      (_instance$$style8 = instance.$style) === null || _instance$$style8 === void 0 || _instance$$style8.load(css3, _objectSpread$2({
        name: "".concat(instance.$style.name, "-variables")
      }, useStyleOptions));
      (_instance$$style9 = instance.$style) === null || _instance$$style9 === void 0 || _instance$$style9.loadStyle(_objectSpread$2({
        name: "".concat(instance.$style.name, "-style")
      }, useStyleOptions), _style);
      S.setLoadedStyleName(instance.$style.name);
    }
    if (!S.isStyleNameLoaded("layer-order")) {
      var _instance$$style0, _instance$$style0$get;
      var layerOrder = (_instance$$style0 = instance.$style) === null || _instance$$style0 === void 0 || (_instance$$style0$get = _instance$$style0.getLayerOrderThemeCSS) === null || _instance$$style0$get === void 0 ? void 0 : _instance$$style0$get.call(_instance$$style0);
      BaseStyle.load(layerOrder, _objectSpread$2({
        name: "layer-order",
        first: true
      }, useStyleOptions));
      S.setLoadedStyleName("layer-order");
    }
  },
  _loadScopedThemeStyles: function _loadScopedThemeStyles2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var useStyleOptions = arguments.length > 1 ? arguments[1] : void 0;
    var preset = instance.preset();
    if (preset && instance.$attrSelector) {
      var _instance$$style1, _instance$$style1$get, _instance$$style10;
      var _ref7 = ((_instance$$style1 = instance.$style) === null || _instance$$style1 === void 0 || (_instance$$style1$get = _instance$$style1.getPresetTheme) === null || _instance$$style1$get === void 0 ? void 0 : _instance$$style1$get.call(_instance$$style1, preset, "[".concat(instance.$attrSelector, "]"))) || {}, css3 = _ref7.css;
      var scopedStyle = (_instance$$style10 = instance.$style) === null || _instance$$style10 === void 0 ? void 0 : _instance$$style10.load(css3, _objectSpread$2({
        name: "".concat(instance.$attrSelector, "-").concat(instance.$style.name)
      }, useStyleOptions));
      instance.scopedStyleEl = scopedStyle.el;
    }
  },
  _themeChangeListener: function _themeChangeListener2() {
    var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    Base.clearLoadedStyleNames();
    N.on("theme:change", callback);
  },
  _removeThemeListeners: function _removeThemeListeners2() {
    var instance = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    N.off("theme:change", instance.$loadStyles);
    instance.$loadStyles = void 0;
  },
  _hook: function _hook2(directiveName, hookName, el, binding, vnode, prevVnode) {
    var _binding$value, _config$pt;
    var name = "on".concat(ne$1(hookName));
    var config = BaseDirective._getConfig(binding, vnode);
    var instance = el === null || el === void 0 ? void 0 : el.$instance;
    var selfHook = BaseDirective._usePT(instance, BaseDirective._getPT(binding === null || binding === void 0 || (_binding$value = binding.value) === null || _binding$value === void 0 ? void 0 : _binding$value.pt, directiveName), BaseDirective._getOptionValue, "hooks.".concat(name));
    var defaultHook = BaseDirective._useDefaultPT(instance, config === null || config === void 0 || (_config$pt = config.pt) === null || _config$pt === void 0 || (_config$pt = _config$pt.directives) === null || _config$pt === void 0 ? void 0 : _config$pt[directiveName], BaseDirective._getOptionValue, "hooks.".concat(name));
    var options = {
      el,
      binding,
      vnode,
      prevVnode
    };
    selfHook === null || selfHook === void 0 || selfHook(instance, options);
    defaultHook === null || defaultHook === void 0 || defaultHook(instance, options);
  },
  /* eslint-disable-next-line no-unused-vars */
  _mergeProps: function _mergeProps2() {
    var fn = arguments.length > 1 ? arguments[1] : void 0;
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }
    return c$1(fn) ? fn.apply(void 0, args) : mergeProps.apply(void 0, args);
  },
  _extend: function _extend(name) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var handleHook = function handleHook2(hook, el, binding, vnode, prevVnode) {
      var _el$$pd, _el$$instance$hook, _el$$instance, _el$$pd2;
      el._$instances = el._$instances || {};
      var config = BaseDirective._getConfig(binding, vnode);
      var $prevInstance = el._$instances[name] || {};
      var $options = l($prevInstance) ? _objectSpread$2(_objectSpread$2({}, options), options === null || options === void 0 ? void 0 : options.methods) : {};
      el._$instances[name] = _objectSpread$2(_objectSpread$2({}, $prevInstance), {}, {
        /* new instance variables to pass in directive methods */
        $name: name,
        $host: el,
        $binding: binding,
        $modifiers: binding === null || binding === void 0 ? void 0 : binding.modifiers,
        $value: binding === null || binding === void 0 ? void 0 : binding.value,
        $el: $prevInstance["$el"] || el || void 0,
        $style: _objectSpread$2({
          classes: void 0,
          inlineStyles: void 0,
          load: function load2() {
          },
          loadCSS: function loadCSS2() {
          },
          loadStyle: function loadStyle2() {
          }
        }, options === null || options === void 0 ? void 0 : options.style),
        $primevueConfig: config,
        $attrSelector: (_el$$pd = el.$pd) === null || _el$$pd === void 0 || (_el$$pd = _el$$pd[name]) === null || _el$$pd === void 0 ? void 0 : _el$$pd.attrSelector,
        /* computed instance variables */
        defaultPT: function defaultPT2() {
          return BaseDirective._getPT(config === null || config === void 0 ? void 0 : config.pt, void 0, function(value) {
            var _value$directives;
            return value === null || value === void 0 || (_value$directives = value.directives) === null || _value$directives === void 0 ? void 0 : _value$directives[name];
          });
        },
        isUnstyled: function isUnstyled2() {
          var _el$_$instances$name, _el$_$instances$name2;
          return ((_el$_$instances$name = el._$instances[name]) === null || _el$_$instances$name === void 0 || (_el$_$instances$name = _el$_$instances$name.$binding) === null || _el$_$instances$name === void 0 || (_el$_$instances$name = _el$_$instances$name.value) === null || _el$_$instances$name === void 0 ? void 0 : _el$_$instances$name.unstyled) !== void 0 ? (_el$_$instances$name2 = el._$instances[name]) === null || _el$_$instances$name2 === void 0 || (_el$_$instances$name2 = _el$_$instances$name2.$binding) === null || _el$_$instances$name2 === void 0 || (_el$_$instances$name2 = _el$_$instances$name2.value) === null || _el$_$instances$name2 === void 0 ? void 0 : _el$_$instances$name2.unstyled : config === null || config === void 0 ? void 0 : config.unstyled;
        },
        theme: function theme() {
          var _el$_$instances$name3;
          return (_el$_$instances$name3 = el._$instances[name]) === null || _el$_$instances$name3 === void 0 || (_el$_$instances$name3 = _el$_$instances$name3.$primevueConfig) === null || _el$_$instances$name3 === void 0 ? void 0 : _el$_$instances$name3.theme;
        },
        preset: function preset() {
          var _el$_$instances$name4;
          return (_el$_$instances$name4 = el._$instances[name]) === null || _el$_$instances$name4 === void 0 || (_el$_$instances$name4 = _el$_$instances$name4.$binding) === null || _el$_$instances$name4 === void 0 || (_el$_$instances$name4 = _el$_$instances$name4.value) === null || _el$_$instances$name4 === void 0 ? void 0 : _el$_$instances$name4.dt;
        },
        /* instance's methods */
        ptm: function ptm2() {
          var _el$_$instances$name5;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return BaseDirective._getPTValue(el._$instances[name], (_el$_$instances$name5 = el._$instances[name]) === null || _el$_$instances$name5 === void 0 || (_el$_$instances$name5 = _el$_$instances$name5.$binding) === null || _el$_$instances$name5 === void 0 || (_el$_$instances$name5 = _el$_$instances$name5.value) === null || _el$_$instances$name5 === void 0 ? void 0 : _el$_$instances$name5.pt, key, _objectSpread$2({}, params));
        },
        ptmo: function ptmo2() {
          var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return BaseDirective._getPTValue(el._$instances[name], obj, key, params, false);
        },
        cx: function cx2() {
          var _el$_$instances$name6, _el$_$instances$name7;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return !((_el$_$instances$name6 = el._$instances[name]) !== null && _el$_$instances$name6 !== void 0 && _el$_$instances$name6.isUnstyled()) ? BaseDirective._getOptionValue((_el$_$instances$name7 = el._$instances[name]) === null || _el$_$instances$name7 === void 0 || (_el$_$instances$name7 = _el$_$instances$name7.$style) === null || _el$_$instances$name7 === void 0 ? void 0 : _el$_$instances$name7.classes, key, _objectSpread$2({}, params)) : void 0;
        },
        sx: function sx2() {
          var _el$_$instances$name8;
          var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var when = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return when ? BaseDirective._getOptionValue((_el$_$instances$name8 = el._$instances[name]) === null || _el$_$instances$name8 === void 0 || (_el$_$instances$name8 = _el$_$instances$name8.$style) === null || _el$_$instances$name8 === void 0 ? void 0 : _el$_$instances$name8.inlineStyles, key, _objectSpread$2({}, params)) : void 0;
        }
      }, $options);
      el.$instance = el._$instances[name];
      (_el$$instance$hook = (_el$$instance = el.$instance)[hook]) === null || _el$$instance$hook === void 0 || _el$$instance$hook.call(_el$$instance, el, binding, vnode, prevVnode);
      el["$".concat(name)] = el.$instance;
      BaseDirective._hook(name, hook, el, binding, vnode, prevVnode);
      el.$pd || (el.$pd = {});
      el.$pd[name] = _objectSpread$2(_objectSpread$2({}, (_el$$pd2 = el.$pd) === null || _el$$pd2 === void 0 ? void 0 : _el$$pd2[name]), {}, {
        name,
        instance: el._$instances[name]
      });
    };
    var handleWatchers = function handleWatchers2(el) {
      var _watchers$config2, _watchers$configRipp2, _instance$$primevueCo3;
      var instance = el._$instances[name];
      var watchers = instance === null || instance === void 0 ? void 0 : instance.watch;
      var handleWatchConfig = function handleWatchConfig2(_ref8) {
        var _watchers$config;
        var newValue = _ref8.newValue, oldValue = _ref8.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$config = watchers["config"]) === null || _watchers$config === void 0 ? void 0 : _watchers$config.call(instance, newValue, oldValue);
      };
      var handleWatchConfigRipple = function handleWatchConfigRipple2(_ref9) {
        var _watchers$configRipp;
        var newValue = _ref9.newValue, oldValue = _ref9.oldValue;
        return watchers === null || watchers === void 0 || (_watchers$configRipp = watchers["config.ripple"]) === null || _watchers$configRipp === void 0 ? void 0 : _watchers$configRipp.call(instance, newValue, oldValue);
      };
      instance.$watchersCallback = {
        config: handleWatchConfig,
        "config.ripple": handleWatchConfigRipple
      };
      watchers === null || watchers === void 0 || (_watchers$config2 = watchers["config"]) === null || _watchers$config2 === void 0 || _watchers$config2.call(instance, instance === null || instance === void 0 ? void 0 : instance.$primevueConfig);
      PrimeVueService.on("config:change", handleWatchConfig);
      watchers === null || watchers === void 0 || (_watchers$configRipp2 = watchers["config.ripple"]) === null || _watchers$configRipp2 === void 0 || _watchers$configRipp2.call(instance, instance === null || instance === void 0 || (_instance$$primevueCo3 = instance.$primevueConfig) === null || _instance$$primevueCo3 === void 0 ? void 0 : _instance$$primevueCo3.ripple);
      PrimeVueService.on("config:ripple:change", handleWatchConfigRipple);
    };
    var stopWatchers2 = function stopWatchers3(el) {
      var watchers = el._$instances[name].$watchersCallback;
      if (watchers) {
        PrimeVueService.off("config:change", watchers.config);
        PrimeVueService.off("config:ripple:change", watchers["config.ripple"]);
        el._$instances[name].$watchersCallback = void 0;
      }
    };
    return {
      created: function created2(el, binding, vnode, prevVnode) {
        el.$pd || (el.$pd = {});
        el.$pd[name] = {
          name,
          attrSelector: s("pd")
        };
        handleHook("created", el, binding, vnode, prevVnode);
      },
      beforeMount: function beforeMount2(el, binding, vnode, prevVnode) {
        var _el$$pd$name;
        BaseDirective._loadStyles((_el$$pd$name = el.$pd[name]) === null || _el$$pd$name === void 0 ? void 0 : _el$$pd$name.instance, binding, vnode);
        handleHook("beforeMount", el, binding, vnode, prevVnode);
        handleWatchers(el);
      },
      mounted: function mounted5(el, binding, vnode, prevVnode) {
        var _el$$pd$name2;
        BaseDirective._loadStyles((_el$$pd$name2 = el.$pd[name]) === null || _el$$pd$name2 === void 0 ? void 0 : _el$$pd$name2.instance, binding, vnode);
        handleHook("mounted", el, binding, vnode, prevVnode);
      },
      beforeUpdate: function beforeUpdate2(el, binding, vnode, prevVnode) {
        handleHook("beforeUpdate", el, binding, vnode, prevVnode);
      },
      updated: function updated4(el, binding, vnode, prevVnode) {
        var _el$$pd$name3;
        BaseDirective._loadStyles((_el$$pd$name3 = el.$pd[name]) === null || _el$$pd$name3 === void 0 ? void 0 : _el$$pd$name3.instance, binding, vnode);
        handleHook("updated", el, binding, vnode, prevVnode);
      },
      beforeUnmount: function beforeUnmount3(el, binding, vnode, prevVnode) {
        var _el$$pd$name4;
        stopWatchers2(el);
        BaseDirective._removeThemeListeners((_el$$pd$name4 = el.$pd[name]) === null || _el$$pd$name4 === void 0 ? void 0 : _el$$pd$name4.instance);
        handleHook("beforeUnmount", el, binding, vnode, prevVnode);
      },
      unmounted: function unmounted4(el, binding, vnode, prevVnode) {
        var _el$$pd$name5;
        (_el$$pd$name5 = el.$pd[name]) === null || _el$$pd$name5 === void 0 || (_el$$pd$name5 = _el$$pd$name5.instance) === null || _el$$pd$name5 === void 0 || (_el$$pd$name5 = _el$$pd$name5.scopedStyleEl) === null || _el$$pd$name5 === void 0 || (_el$$pd$name5 = _el$$pd$name5.value) === null || _el$$pd$name5 === void 0 || _el$$pd$name5.remove();
        handleHook("unmounted", el, binding, vnode, prevVnode);
      }
    };
  },
  extend: function extend3() {
    var _BaseDirective$_getMe = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe2 = _slicedToArray(_BaseDirective$_getMe, 2), name = _BaseDirective$_getMe2[0], options = _BaseDirective$_getMe2[1];
    return _objectSpread$2({
      extend: function extend4() {
        var _BaseDirective$_getMe3 = BaseDirective._getMeta.apply(BaseDirective, arguments), _BaseDirective$_getMe4 = _slicedToArray(_BaseDirective$_getMe3, 2), _name = _BaseDirective$_getMe4[0], _options = _BaseDirective$_getMe4[1];
        return BaseDirective.extend(_name, _objectSpread$2(_objectSpread$2(_objectSpread$2({}, options), options === null || options === void 0 ? void 0 : options.methods), _options));
      }
    }, BaseDirective._extend(name, options));
  }
};
var style$2 = "\n    .p-ink {\n        display: block;\n        position: absolute;\n        background: dt('ripple.background');\n        border-radius: 100%;\n        transform: scale(0);\n        pointer-events: none;\n    }\n\n    .p-ink-active {\n        animation: ripple 0.4s linear;\n    }\n\n    @keyframes ripple {\n        100% {\n            opacity: 0;\n            transform: scale(2.5);\n        }\n    }\n";
var classes$2 = {
  root: "p-ink"
};
var RippleStyle = BaseStyle.extend({
  name: "ripple-directive",
  style: style$2,
  classes: classes$2
});
var BaseRipple = BaseDirective.extend({
  style: RippleStyle
});
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r, a2) : void 0;
  }
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _arrayLikeToArray(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
function _defineProperty$4(e, r, t2) {
  return (r = _toPropertyKey$4(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$4(t2) {
  var i2 = _toPrimitive$4(t2, "string");
  return "symbol" == _typeof$4(i2) ? i2 : i2 + "";
}
function _toPrimitive$4(t2, r) {
  if ("object" != _typeof$4(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$4(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var Ripple = BaseRipple.extend("ripple", {
  watch: {
    "config.ripple": function configRipple(newValue) {
      if (newValue) {
        this.createRipple(this.$host);
        this.bindEvents(this.$host);
        this.$host.setAttribute("data-pd-ripple", true);
        this.$host.style["overflow"] = "hidden";
        this.$host.style["position"] = "relative";
      } else {
        this.remove(this.$host);
        this.$host.removeAttribute("data-pd-ripple");
      }
    }
  },
  unmounted: function unmounted2(el) {
    this.remove(el);
  },
  timeout: void 0,
  methods: {
    bindEvents: function bindEvents(el) {
      el.addEventListener("mousedown", this.onMouseDown.bind(this));
    },
    unbindEvents: function unbindEvents(el) {
      el.removeEventListener("mousedown", this.onMouseDown.bind(this));
    },
    createRipple: function createRipple(el) {
      var ink = this.getInk(el);
      if (!ink) {
        ink = U("span", _defineProperty$4(_defineProperty$4({
          role: "presentation",
          "aria-hidden": true,
          "data-p-ink": true,
          "data-p-ink-active": false,
          "class": !this.isUnstyled() && this.cx("root"),
          onAnimationEnd: this.onAnimationEnd.bind(this)
        }, this.$attrSelector, ""), "p-bind", this.ptm("root")));
        el.appendChild(ink);
        this.$el = ink;
      }
    },
    remove: function remove2(el) {
      var ink = this.getInk(el);
      if (ink) {
        this.$host.style["overflow"] = "";
        this.$host.style["position"] = "";
        this.unbindEvents(el);
        ink.removeEventListener("animationend", this.onAnimationEnd);
        ink.remove();
      }
    },
    onMouseDown: function onMouseDown(event) {
      var _this = this;
      var target = event.currentTarget;
      var ink = this.getInk(target);
      if (!ink || getComputedStyle(ink, null).display === "none") {
        return;
      }
      !this.isUnstyled() && P(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "false");
      if (!Tt(ink) && !Rt(ink)) {
        var d2 = Math.max(v$1(target), C$1(target));
        ink.style.height = d2 + "px";
        ink.style.width = d2 + "px";
      }
      var offset = K(target);
      var x2 = event.pageX - offset.left + document.body.scrollTop - Rt(ink) / 2;
      var y2 = event.pageY - offset.top + document.body.scrollLeft - Tt(ink) / 2;
      ink.style.top = y2 + "px";
      ink.style.left = x2 + "px";
      !this.isUnstyled() && W(ink, "p-ink-active");
      ink.setAttribute("data-p-ink-active", "true");
      this.timeout = setTimeout(function() {
        if (ink) {
          !_this.isUnstyled() && P(ink, "p-ink-active");
          ink.setAttribute("data-p-ink-active", "false");
        }
      }, 401);
    },
    onAnimationEnd: function onAnimationEnd(event) {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      !this.isUnstyled() && P(event.currentTarget, "p-ink-active");
      event.currentTarget.setAttribute("data-p-ink-active", "false");
    },
    getInk: function getInk(el) {
      return el && el.children ? _toConsumableArray(el.children).find(function(child) {
        return Q$1(child, "data-pc-name") === "ripple";
      }) : void 0;
    }
  }
});
var style$1 = `
    .p-button {
        display: inline-flex;
        cursor: pointer;
        user-select: none;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        color: dt('button.primary.color');
        background: dt('button.primary.background');
        border: 1px solid dt('button.primary.border.color');
        padding: dt('button.padding.y') dt('button.padding.x');
        font-size: 1rem;
        font-family: inherit;
        font-feature-settings: inherit;
        transition:
            background dt('button.transition.duration'),
            color dt('button.transition.duration'),
            border-color dt('button.transition.duration'),
            outline-color dt('button.transition.duration'),
            box-shadow dt('button.transition.duration');
        border-radius: dt('button.border.radius');
        outline-color: transparent;
        gap: dt('button.gap');
    }

    .p-button:disabled {
        cursor: default;
    }

    .p-button-icon-right {
        order: 1;
    }

    .p-button-icon-right:dir(rtl) {
        order: -1;
    }

    .p-button:not(.p-button-vertical) .p-button-icon:not(.p-button-icon-right):dir(rtl) {
        order: 1;
    }

    .p-button-icon-bottom {
        order: 2;
    }

    .p-button-icon-only {
        width: dt('button.icon.only.width');
        padding-inline-start: 0;
        padding-inline-end: 0;
        gap: 0;
    }

    .p-button-icon-only.p-button-rounded {
        border-radius: 50%;
        height: dt('button.icon.only.width');
    }

    .p-button-icon-only .p-button-label {
        visibility: hidden;
        width: 0;
    }

    .p-button-icon-only::after {
        content: "\0A0";
        visibility: hidden;
        width: 0;
    }

    .p-button-sm {
        font-size: dt('button.sm.font.size');
        padding: dt('button.sm.padding.y') dt('button.sm.padding.x');
    }

    .p-button-sm .p-button-icon {
        font-size: dt('button.sm.font.size');
    }

    .p-button-sm.p-button-icon-only {
        width: dt('button.sm.icon.only.width');
    }

    .p-button-sm.p-button-icon-only.p-button-rounded {
        height: dt('button.sm.icon.only.width');
    }

    .p-button-lg {
        font-size: dt('button.lg.font.size');
        padding: dt('button.lg.padding.y') dt('button.lg.padding.x');
    }

    .p-button-lg .p-button-icon {
        font-size: dt('button.lg.font.size');
    }

    .p-button-lg.p-button-icon-only {
        width: dt('button.lg.icon.only.width');
    }

    .p-button-lg.p-button-icon-only.p-button-rounded {
        height: dt('button.lg.icon.only.width');
    }

    .p-button-vertical {
        flex-direction: column;
    }

    .p-button-label {
        font-weight: dt('button.label.font.weight');
    }

    .p-button-fluid {
        width: 100%;
    }

    .p-button-fluid.p-button-icon-only {
        width: dt('button.icon.only.width');
    }

    .p-button:not(:disabled):hover {
        background: dt('button.primary.hover.background');
        border: 1px solid dt('button.primary.hover.border.color');
        color: dt('button.primary.hover.color');
    }

    .p-button:not(:disabled):active {
        background: dt('button.primary.active.background');
        border: 1px solid dt('button.primary.active.border.color');
        color: dt('button.primary.active.color');
    }

    .p-button:focus-visible {
        box-shadow: dt('button.primary.focus.ring.shadow');
        outline: dt('button.focus.ring.width') dt('button.focus.ring.style') dt('button.primary.focus.ring.color');
        outline-offset: dt('button.focus.ring.offset');
    }

    .p-button .p-badge {
        min-width: dt('button.badge.size');
        height: dt('button.badge.size');
        line-height: dt('button.badge.size');
    }

    .p-button-raised {
        box-shadow: dt('button.raised.shadow');
    }

    .p-button-rounded {
        border-radius: dt('button.rounded.border.radius');
    }

    .p-button-secondary {
        background: dt('button.secondary.background');
        border: 1px solid dt('button.secondary.border.color');
        color: dt('button.secondary.color');
    }

    .p-button-secondary:not(:disabled):hover {
        background: dt('button.secondary.hover.background');
        border: 1px solid dt('button.secondary.hover.border.color');
        color: dt('button.secondary.hover.color');
    }

    .p-button-secondary:not(:disabled):active {
        background: dt('button.secondary.active.background');
        border: 1px solid dt('button.secondary.active.border.color');
        color: dt('button.secondary.active.color');
    }

    .p-button-secondary:focus-visible {
        outline-color: dt('button.secondary.focus.ring.color');
        box-shadow: dt('button.secondary.focus.ring.shadow');
    }

    .p-button-success {
        background: dt('button.success.background');
        border: 1px solid dt('button.success.border.color');
        color: dt('button.success.color');
    }

    .p-button-success:not(:disabled):hover {
        background: dt('button.success.hover.background');
        border: 1px solid dt('button.success.hover.border.color');
        color: dt('button.success.hover.color');
    }

    .p-button-success:not(:disabled):active {
        background: dt('button.success.active.background');
        border: 1px solid dt('button.success.active.border.color');
        color: dt('button.success.active.color');
    }

    .p-button-success:focus-visible {
        outline-color: dt('button.success.focus.ring.color');
        box-shadow: dt('button.success.focus.ring.shadow');
    }

    .p-button-info {
        background: dt('button.info.background');
        border: 1px solid dt('button.info.border.color');
        color: dt('button.info.color');
    }

    .p-button-info:not(:disabled):hover {
        background: dt('button.info.hover.background');
        border: 1px solid dt('button.info.hover.border.color');
        color: dt('button.info.hover.color');
    }

    .p-button-info:not(:disabled):active {
        background: dt('button.info.active.background');
        border: 1px solid dt('button.info.active.border.color');
        color: dt('button.info.active.color');
    }

    .p-button-info:focus-visible {
        outline-color: dt('button.info.focus.ring.color');
        box-shadow: dt('button.info.focus.ring.shadow');
    }

    .p-button-warn {
        background: dt('button.warn.background');
        border: 1px solid dt('button.warn.border.color');
        color: dt('button.warn.color');
    }

    .p-button-warn:not(:disabled):hover {
        background: dt('button.warn.hover.background');
        border: 1px solid dt('button.warn.hover.border.color');
        color: dt('button.warn.hover.color');
    }

    .p-button-warn:not(:disabled):active {
        background: dt('button.warn.active.background');
        border: 1px solid dt('button.warn.active.border.color');
        color: dt('button.warn.active.color');
    }

    .p-button-warn:focus-visible {
        outline-color: dt('button.warn.focus.ring.color');
        box-shadow: dt('button.warn.focus.ring.shadow');
    }

    .p-button-help {
        background: dt('button.help.background');
        border: 1px solid dt('button.help.border.color');
        color: dt('button.help.color');
    }

    .p-button-help:not(:disabled):hover {
        background: dt('button.help.hover.background');
        border: 1px solid dt('button.help.hover.border.color');
        color: dt('button.help.hover.color');
    }

    .p-button-help:not(:disabled):active {
        background: dt('button.help.active.background');
        border: 1px solid dt('button.help.active.border.color');
        color: dt('button.help.active.color');
    }

    .p-button-help:focus-visible {
        outline-color: dt('button.help.focus.ring.color');
        box-shadow: dt('button.help.focus.ring.shadow');
    }

    .p-button-danger {
        background: dt('button.danger.background');
        border: 1px solid dt('button.danger.border.color');
        color: dt('button.danger.color');
    }

    .p-button-danger:not(:disabled):hover {
        background: dt('button.danger.hover.background');
        border: 1px solid dt('button.danger.hover.border.color');
        color: dt('button.danger.hover.color');
    }

    .p-button-danger:not(:disabled):active {
        background: dt('button.danger.active.background');
        border: 1px solid dt('button.danger.active.border.color');
        color: dt('button.danger.active.color');
    }

    .p-button-danger:focus-visible {
        outline-color: dt('button.danger.focus.ring.color');
        box-shadow: dt('button.danger.focus.ring.shadow');
    }

    .p-button-contrast {
        background: dt('button.contrast.background');
        border: 1px solid dt('button.contrast.border.color');
        color: dt('button.contrast.color');
    }

    .p-button-contrast:not(:disabled):hover {
        background: dt('button.contrast.hover.background');
        border: 1px solid dt('button.contrast.hover.border.color');
        color: dt('button.contrast.hover.color');
    }

    .p-button-contrast:not(:disabled):active {
        background: dt('button.contrast.active.background');
        border: 1px solid dt('button.contrast.active.border.color');
        color: dt('button.contrast.active.color');
    }

    .p-button-contrast:focus-visible {
        outline-color: dt('button.contrast.focus.ring.color');
        box-shadow: dt('button.contrast.focus.ring.shadow');
    }

    .p-button-outlined {
        background: transparent;
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined:not(:disabled):hover {
        background: dt('button.outlined.primary.hover.background');
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined:not(:disabled):active {
        background: dt('button.outlined.primary.active.background');
        border-color: dt('button.outlined.primary.border.color');
        color: dt('button.outlined.primary.color');
    }

    .p-button-outlined.p-button-secondary {
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-secondary:not(:disabled):hover {
        background: dt('button.outlined.secondary.hover.background');
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-secondary:not(:disabled):active {
        background: dt('button.outlined.secondary.active.background');
        border-color: dt('button.outlined.secondary.border.color');
        color: dt('button.outlined.secondary.color');
    }

    .p-button-outlined.p-button-success {
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-success:not(:disabled):hover {
        background: dt('button.outlined.success.hover.background');
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-success:not(:disabled):active {
        background: dt('button.outlined.success.active.background');
        border-color: dt('button.outlined.success.border.color');
        color: dt('button.outlined.success.color');
    }

    .p-button-outlined.p-button-info {
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-info:not(:disabled):hover {
        background: dt('button.outlined.info.hover.background');
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-info:not(:disabled):active {
        background: dt('button.outlined.info.active.background');
        border-color: dt('button.outlined.info.border.color');
        color: dt('button.outlined.info.color');
    }

    .p-button-outlined.p-button-warn {
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-warn:not(:disabled):hover {
        background: dt('button.outlined.warn.hover.background');
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-warn:not(:disabled):active {
        background: dt('button.outlined.warn.active.background');
        border-color: dt('button.outlined.warn.border.color');
        color: dt('button.outlined.warn.color');
    }

    .p-button-outlined.p-button-help {
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-help:not(:disabled):hover {
        background: dt('button.outlined.help.hover.background');
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-help:not(:disabled):active {
        background: dt('button.outlined.help.active.background');
        border-color: dt('button.outlined.help.border.color');
        color: dt('button.outlined.help.color');
    }

    .p-button-outlined.p-button-danger {
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-danger:not(:disabled):hover {
        background: dt('button.outlined.danger.hover.background');
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-danger:not(:disabled):active {
        background: dt('button.outlined.danger.active.background');
        border-color: dt('button.outlined.danger.border.color');
        color: dt('button.outlined.danger.color');
    }

    .p-button-outlined.p-button-contrast {
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-contrast:not(:disabled):hover {
        background: dt('button.outlined.contrast.hover.background');
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-contrast:not(:disabled):active {
        background: dt('button.outlined.contrast.active.background');
        border-color: dt('button.outlined.contrast.border.color');
        color: dt('button.outlined.contrast.color');
    }

    .p-button-outlined.p-button-plain {
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-outlined.p-button-plain:not(:disabled):hover {
        background: dt('button.outlined.plain.hover.background');
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-outlined.p-button-plain:not(:disabled):active {
        background: dt('button.outlined.plain.active.background');
        border-color: dt('button.outlined.plain.border.color');
        color: dt('button.outlined.plain.color');
    }

    .p-button-text {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text:not(:disabled):hover {
        background: dt('button.text.primary.hover.background');
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text:not(:disabled):active {
        background: dt('button.text.primary.active.background');
        border-color: transparent;
        color: dt('button.text.primary.color');
    }

    .p-button-text.p-button-secondary {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-secondary:not(:disabled):hover {
        background: dt('button.text.secondary.hover.background');
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-secondary:not(:disabled):active {
        background: dt('button.text.secondary.active.background');
        border-color: transparent;
        color: dt('button.text.secondary.color');
    }

    .p-button-text.p-button-success {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-success:not(:disabled):hover {
        background: dt('button.text.success.hover.background');
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-success:not(:disabled):active {
        background: dt('button.text.success.active.background');
        border-color: transparent;
        color: dt('button.text.success.color');
    }

    .p-button-text.p-button-info {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-info:not(:disabled):hover {
        background: dt('button.text.info.hover.background');
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-info:not(:disabled):active {
        background: dt('button.text.info.active.background');
        border-color: transparent;
        color: dt('button.text.info.color');
    }

    .p-button-text.p-button-warn {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-warn:not(:disabled):hover {
        background: dt('button.text.warn.hover.background');
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-warn:not(:disabled):active {
        background: dt('button.text.warn.active.background');
        border-color: transparent;
        color: dt('button.text.warn.color');
    }

    .p-button-text.p-button-help {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-help:not(:disabled):hover {
        background: dt('button.text.help.hover.background');
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-help:not(:disabled):active {
        background: dt('button.text.help.active.background');
        border-color: transparent;
        color: dt('button.text.help.color');
    }

    .p-button-text.p-button-danger {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-danger:not(:disabled):hover {
        background: dt('button.text.danger.hover.background');
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-danger:not(:disabled):active {
        background: dt('button.text.danger.active.background');
        border-color: transparent;
        color: dt('button.text.danger.color');
    }

    .p-button-text.p-button-contrast {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-contrast:not(:disabled):hover {
        background: dt('button.text.contrast.hover.background');
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-contrast:not(:disabled):active {
        background: dt('button.text.contrast.active.background');
        border-color: transparent;
        color: dt('button.text.contrast.color');
    }

    .p-button-text.p-button-plain {
        background: transparent;
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-text.p-button-plain:not(:disabled):hover {
        background: dt('button.text.plain.hover.background');
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-text.p-button-plain:not(:disabled):active {
        background: dt('button.text.plain.active.background');
        border-color: transparent;
        color: dt('button.text.plain.color');
    }

    .p-button-link {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.color');
    }

    .p-button-link:not(:disabled):hover {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.hover.color');
    }

    .p-button-link:not(:disabled):hover .p-button-label {
        text-decoration: underline;
    }

    .p-button-link:not(:disabled):active {
        background: transparent;
        border-color: transparent;
        color: dt('button.link.active.color');
    }
`;
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
function _defineProperty$3(e, r, t2) {
  return (r = _toPropertyKey$3(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$3(t2) {
  var i2 = _toPrimitive$3(t2, "string");
  return "symbol" == _typeof$3(i2) ? i2 : i2 + "";
}
function _toPrimitive$3(t2, r) {
  if ("object" != _typeof$3(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$3(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var classes$1 = {
  root: function root2(_ref) {
    var instance = _ref.instance, props = _ref.props;
    return ["p-button p-component", _defineProperty$3(_defineProperty$3(_defineProperty$3(_defineProperty$3(_defineProperty$3(_defineProperty$3(_defineProperty$3(_defineProperty$3(_defineProperty$3({
      "p-button-icon-only": instance.hasIcon && !props.label && !props.badge,
      "p-button-vertical": (props.iconPos === "top" || props.iconPos === "bottom") && props.label,
      "p-button-loading": props.loading,
      "p-button-link": props.link || props.variant === "link"
    }, "p-button-".concat(props.severity), props.severity), "p-button-raised", props.raised), "p-button-rounded", props.rounded), "p-button-text", props.text || props.variant === "text"), "p-button-outlined", props.outlined || props.variant === "outlined"), "p-button-sm", props.size === "small"), "p-button-lg", props.size === "large"), "p-button-plain", props.plain), "p-button-fluid", instance.hasFluid)];
  },
  loadingIcon: "p-button-loading-icon",
  icon: function icon(_ref3) {
    var props = _ref3.props;
    return ["p-button-icon", _defineProperty$3({}, "p-button-icon-".concat(props.iconPos), props.label)];
  },
  label: "p-button-label"
};
var ButtonStyle = BaseStyle.extend({
  name: "button",
  style: style$1,
  classes: classes$1
});
var script$1$1 = {
  name: "BaseButton",
  "extends": script$a,
  props: {
    label: {
      type: String,
      "default": null
    },
    icon: {
      type: String,
      "default": null
    },
    iconPos: {
      type: String,
      "default": "left"
    },
    iconClass: {
      type: [String, Object],
      "default": null
    },
    badge: {
      type: String,
      "default": null
    },
    badgeClass: {
      type: [String, Object],
      "default": null
    },
    badgeSeverity: {
      type: String,
      "default": "secondary"
    },
    loading: {
      type: Boolean,
      "default": false
    },
    loadingIcon: {
      type: String,
      "default": void 0
    },
    as: {
      type: [String, Object],
      "default": "BUTTON"
    },
    asChild: {
      type: Boolean,
      "default": false
    },
    link: {
      type: Boolean,
      "default": false
    },
    severity: {
      type: String,
      "default": null
    },
    raised: {
      type: Boolean,
      "default": false
    },
    rounded: {
      type: Boolean,
      "default": false
    },
    text: {
      type: Boolean,
      "default": false
    },
    outlined: {
      type: Boolean,
      "default": false
    },
    size: {
      type: String,
      "default": null
    },
    variant: {
      type: String,
      "default": null
    },
    plain: {
      type: Boolean,
      "default": false
    },
    fluid: {
      type: Boolean,
      "default": null
    }
  },
  style: ButtonStyle,
  provide: function provide4() {
    return {
      $pcButton: this,
      $parentInstance: this
    };
  }
};
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
function _defineProperty$2(e, r, t2) {
  return (r = _toPropertyKey$2(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$2(t2) {
  var i2 = _toPrimitive$2(t2, "string");
  return "symbol" == _typeof$2(i2) ? i2 : i2 + "";
}
function _toPrimitive$2(t2, r) {
  if ("object" != _typeof$2(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$2(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var script$3 = {
  name: "Button",
  "extends": script$1$1,
  inheritAttrs: false,
  inject: {
    $pcFluid: {
      "default": null
    }
  },
  methods: {
    getPTOptions: function getPTOptions(key) {
      var _ptm = key === "root" ? this.ptmi : this.ptm;
      return _ptm(key, {
        context: {
          disabled: this.disabled
        }
      });
    }
  },
  computed: {
    disabled: function disabled() {
      return this.$attrs.disabled || this.$attrs.disabled === "" || this.loading;
    },
    defaultAriaLabel: function defaultAriaLabel() {
      return this.label ? this.label + (this.badge ? " " + this.badge : "") : this.$attrs.ariaLabel;
    },
    hasIcon: function hasIcon() {
      return this.icon || this.$slots.icon;
    },
    attrs: function attrs() {
      return mergeProps(this.asAttrs, this.a11yAttrs, this.getPTOptions("root"));
    },
    asAttrs: function asAttrs() {
      return this.as === "BUTTON" ? {
        type: "button",
        disabled: this.disabled
      } : void 0;
    },
    a11yAttrs: function a11yAttrs() {
      return {
        "aria-label": this.defaultAriaLabel,
        "data-pc-name": "button",
        "data-p-disabled": this.disabled,
        "data-p-severity": this.severity
      };
    },
    hasFluid: function hasFluid() {
      return l(this.fluid) ? !!this.$pcFluid : this.fluid;
    },
    dataP: function dataP2() {
      return f(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2(_defineProperty$2({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge), "loading", this.loading), "fluid", this.hasFluid), "rounded", this.rounded), "raised", this.raised), "outlined", this.outlined || this.variant === "outlined"), "text", this.text || this.variant === "text"), "link", this.link || this.variant === "link"), "vertical", (this.iconPos === "top" || this.iconPos === "bottom") && this.label));
    },
    dataIconP: function dataIconP() {
      return f(_defineProperty$2(_defineProperty$2({}, this.iconPos, this.iconPos), this.size, this.size));
    },
    dataLabelP: function dataLabelP() {
      return f(_defineProperty$2(_defineProperty$2({}, this.size, this.size), "icon-only", this.hasIcon && !this.label && !this.badge));
    }
  },
  components: {
    SpinnerIcon: script$5,
    Badge: script$4
  },
  directives: {
    ripple: Ripple
  }
};
var _hoisted_1$2 = ["data-p"];
var _hoisted_2$2 = ["data-p"];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SpinnerIcon = resolveComponent("SpinnerIcon");
  var _component_Badge = resolveComponent("Badge");
  var _directive_ripple = resolveDirective("ripple");
  return !_ctx.asChild ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.as), mergeProps({
    key: 0,
    "class": _ctx.cx("root"),
    "data-p": $options.dataP
  }, $options.attrs), {
    "default": withCtx(function() {
      return [renderSlot(_ctx.$slots, "default", {}, function() {
        return [_ctx.loading ? renderSlot(_ctx.$slots, "loadingicon", mergeProps({
          key: 0,
          "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon")]
        }, _ctx.ptm("loadingIcon")), function() {
          return [_ctx.loadingIcon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon"), _ctx.loadingIcon]
          }, _ctx.ptm("loadingIcon")), null, 16)) : (openBlock(), createBlock(_component_SpinnerIcon, mergeProps({
            key: 1,
            "class": [_ctx.cx("loadingIcon"), _ctx.cx("icon")],
            spin: ""
          }, _ctx.ptm("loadingIcon")), null, 16, ["class"]))];
        }) : renderSlot(_ctx.$slots, "icon", mergeProps({
          key: 1,
          "class": [_ctx.cx("icon")]
        }, _ctx.ptm("icon")), function() {
          return [_ctx.icon ? (openBlock(), createElementBlock("span", mergeProps({
            key: 0,
            "class": [_ctx.cx("icon"), _ctx.icon, _ctx.iconClass],
            "data-p": $options.dataIconP
          }, _ctx.ptm("icon")), null, 16, _hoisted_1$2)) : createCommentVNode("", true)];
        }), _ctx.label ? (openBlock(), createElementBlock("span", mergeProps({
          key: 2,
          "class": _ctx.cx("label")
        }, _ctx.ptm("label"), {
          "data-p": $options.dataLabelP
        }), toDisplayString$1(_ctx.label), 17, _hoisted_2$2)) : createCommentVNode("", true), _ctx.badge ? (openBlock(), createBlock(_component_Badge, {
          key: 3,
          value: _ctx.badge,
          "class": normalizeClass(_ctx.badgeClass),
          severity: _ctx.badgeSeverity,
          unstyled: _ctx.unstyled,
          pt: _ctx.ptm("pcBadge")
        }, null, 8, ["value", "class", "severity", "unstyled", "pt"])) : createCommentVNode("", true)];
      })];
    }),
    _: 3
  }, 16, ["class", "data-p"])), [[_directive_ripple]]) : renderSlot(_ctx.$slots, "default", {
    key: 1,
    "class": normalizeClass(_ctx.cx("root")),
    a11yAttrs: $options.a11yAttrs
  });
}
script$3.render = render$2;
var FocusTrapStyle = BaseStyle.extend({
  name: "focustrap-directive"
});
var BaseFocusTrap = BaseDirective.extend({
  style: FocusTrapStyle
});
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function ownKeys$1(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t2), true).forEach(function(r2) {
      _defineProperty$1(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty$1(e, r, t2) {
  return (r = _toPropertyKey$1(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey$1(t2) {
  var i2 = _toPrimitive$1(t2, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
function _toPrimitive$1(t2, r) {
  if ("object" != _typeof$1(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var FocusTrap = BaseFocusTrap.extend("focustrap", {
  mounted: function mounted2(el, binding) {
    var _ref = binding.value || {}, disabled2 = _ref.disabled;
    if (!disabled2) {
      this.createHiddenFocusableElements(el, binding);
      this.bind(el, binding);
      this.autoElementFocus(el, binding);
    }
    el.setAttribute("data-pd-focustrap", true);
    this.$el = el;
  },
  updated: function updated2(el, binding) {
    var _ref2 = binding.value || {}, disabled2 = _ref2.disabled;
    disabled2 && this.unbind(el);
  },
  unmounted: function unmounted3(el) {
    this.unbind(el);
  },
  methods: {
    getComputedSelector: function getComputedSelector(selector) {
      return ':not(.p-hidden-focusable):not([data-p-hidden-focusable="true"])'.concat(selector !== null && selector !== void 0 ? selector : "");
    },
    bind: function bind(el, binding) {
      var _this = this;
      var _ref3 = binding.value || {}, onFocusIn = _ref3.onFocusIn, onFocusOut = _ref3.onFocusOut;
      el.$_pfocustrap_mutationobserver = new MutationObserver(function(mutationList) {
        mutationList.forEach(function(mutation) {
          if (mutation.type === "childList" && !el.contains(document.activeElement)) {
            var _findNextFocusableElement = function findNextFocusableElement(_el) {
              var focusableElement = It(_el) ? It(_el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) ? _el : vt(el, _this.getComputedSelector(el.$_pfocustrap_focusableselector)) : vt(_el);
              return s$2(focusableElement) ? focusableElement : _el.nextSibling && _findNextFocusableElement(_el.nextSibling);
            };
            bt(_findNextFocusableElement(mutation.nextSibling));
          }
        });
      });
      el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_mutationobserver.observe(el, {
        childList: true
      });
      el.$_pfocustrap_focusinlistener = function(event) {
        return onFocusIn && onFocusIn(event);
      };
      el.$_pfocustrap_focusoutlistener = function(event) {
        return onFocusOut && onFocusOut(event);
      };
      el.addEventListener("focusin", el.$_pfocustrap_focusinlistener);
      el.addEventListener("focusout", el.$_pfocustrap_focusoutlistener);
    },
    unbind: function unbind(el) {
      el.$_pfocustrap_mutationobserver && el.$_pfocustrap_mutationobserver.disconnect();
      el.$_pfocustrap_focusinlistener && el.removeEventListener("focusin", el.$_pfocustrap_focusinlistener) && (el.$_pfocustrap_focusinlistener = null);
      el.$_pfocustrap_focusoutlistener && el.removeEventListener("focusout", el.$_pfocustrap_focusoutlistener) && (el.$_pfocustrap_focusoutlistener = null);
    },
    autoFocus: function autoFocus(options) {
      this.autoElementFocus(this.$el, {
        value: _objectSpread$1(_objectSpread$1({}, options), {}, {
          autoFocus: true
        })
      });
    },
    autoElementFocus: function autoElementFocus(el, binding) {
      var _ref4 = binding.value || {}, _ref4$autoFocusSelect = _ref4.autoFocusSelector, autoFocusSelector = _ref4$autoFocusSelect === void 0 ? "" : _ref4$autoFocusSelect, _ref4$firstFocusableS = _ref4.firstFocusableSelector, firstFocusableSelector = _ref4$firstFocusableS === void 0 ? "" : _ref4$firstFocusableS, _ref4$autoFocus = _ref4.autoFocus, autoFocus2 = _ref4$autoFocus === void 0 ? false : _ref4$autoFocus;
      var focusableElement = vt(el, "[autofocus]".concat(this.getComputedSelector(autoFocusSelector)));
      autoFocus2 && !focusableElement && (focusableElement = vt(el, this.getComputedSelector(firstFocusableSelector)));
      bt(focusableElement);
    },
    onFirstHiddenElementFocus: function onFirstHiddenElementFocus(event) {
      var _this$$el;
      var currentTarget = event.currentTarget, relatedTarget = event.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_lasthiddenfocusableelement || !((_this$$el = this.$el) !== null && _this$$el !== void 0 && _this$$el.contains(relatedTarget)) ? vt(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_lasthiddenfocusableelement;
      bt(focusableElement);
    },
    onLastHiddenElementFocus: function onLastHiddenElementFocus(event) {
      var _this$$el2;
      var currentTarget = event.currentTarget, relatedTarget = event.relatedTarget;
      var focusableElement = relatedTarget === currentTarget.$_pfocustrap_firsthiddenfocusableelement || !((_this$$el2 = this.$el) !== null && _this$$el2 !== void 0 && _this$$el2.contains(relatedTarget)) ? Lt(currentTarget.parentElement, this.getComputedSelector(currentTarget.$_pfocustrap_focusableselector)) : currentTarget.$_pfocustrap_firsthiddenfocusableelement;
      bt(focusableElement);
    },
    createHiddenFocusableElements: function createHiddenFocusableElements(el, binding) {
      var _this2 = this;
      var _ref5 = binding.value || {}, _ref5$tabIndex = _ref5.tabIndex, tabIndex = _ref5$tabIndex === void 0 ? 0 : _ref5$tabIndex, _ref5$firstFocusableS = _ref5.firstFocusableSelector, firstFocusableSelector = _ref5$firstFocusableS === void 0 ? "" : _ref5$firstFocusableS, _ref5$lastFocusableSe = _ref5.lastFocusableSelector, lastFocusableSelector = _ref5$lastFocusableSe === void 0 ? "" : _ref5$lastFocusableSe;
      var createFocusableElement = function createFocusableElement2(onFocus) {
        return U("span", {
          "class": "p-hidden-accessible p-hidden-focusable",
          tabIndex,
          role: "presentation",
          "aria-hidden": true,
          "data-p-hidden-accessible": true,
          "data-p-hidden-focusable": true,
          onFocus: onFocus === null || onFocus === void 0 ? void 0 : onFocus.bind(_this2)
        });
      };
      var firstFocusableElement = createFocusableElement(this.onFirstHiddenElementFocus);
      var lastFocusableElement = createFocusableElement(this.onLastHiddenElementFocus);
      firstFocusableElement.$_pfocustrap_lasthiddenfocusableelement = lastFocusableElement;
      firstFocusableElement.$_pfocustrap_focusableselector = firstFocusableSelector;
      firstFocusableElement.setAttribute("data-pc-section", "firstfocusableelement");
      lastFocusableElement.$_pfocustrap_firsthiddenfocusableelement = firstFocusableElement;
      lastFocusableElement.$_pfocustrap_focusableselector = lastFocusableSelector;
      lastFocusableElement.setAttribute("data-pc-section", "lastfocusableelement");
      el.prepend(firstFocusableElement);
      el.append(lastFocusableElement);
    }
  }
});
var script$2 = {
  name: "Portal",
  props: {
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  data: function data() {
    return {
      mounted: false
    };
  },
  mounted: function mounted3() {
    this.mounted = tt();
  },
  computed: {
    inline: function inline() {
      return this.disabled || this.appendTo === "self";
    }
  }
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.inline ? renderSlot(_ctx.$slots, "default", {
    key: 0
  }) : $data.mounted ? (openBlock(), createBlock(Teleport, {
    key: 1,
    to: $props.appendTo
  }, [renderSlot(_ctx.$slots, "default")], 8, ["to"])) : createCommentVNode("", true);
}
script$2.render = render$1;
function blockBodyScroll() {
  st$1({
    variableName: rr("scrollbar.width").name
  });
}
function unblockBodyScroll() {
  dt$1({
    variableName: rr("scrollbar.width").name
  });
}
var style = "\n    .p-dialog {\n        max-height: 90%;\n        transform: scale(1);\n        border-radius: dt('dialog.border.radius');\n        box-shadow: dt('dialog.shadow');\n        background: dt('dialog.background');\n        border: 1px solid dt('dialog.border.color');\n        color: dt('dialog.color');\n        will-change: transform;\n    }\n\n    .p-dialog-content {\n        overflow-y: auto;\n        padding: dt('dialog.content.padding');\n    }\n\n    .p-dialog-header {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        flex-shrink: 0;\n        padding: dt('dialog.header.padding');\n    }\n\n    .p-dialog-title {\n        font-weight: dt('dialog.title.font.weight');\n        font-size: dt('dialog.title.font.size');\n    }\n\n    .p-dialog-footer {\n        flex-shrink: 0;\n        padding: dt('dialog.footer.padding');\n        display: flex;\n        justify-content: flex-end;\n        gap: dt('dialog.footer.gap');\n    }\n\n    .p-dialog-header-actions {\n        display: flex;\n        align-items: center;\n        gap: dt('dialog.header.gap');\n    }\n\n    .p-dialog-top .p-dialog,\n    .p-dialog-bottom .p-dialog,\n    .p-dialog-left .p-dialog,\n    .p-dialog-right .p-dialog,\n    .p-dialog-topleft .p-dialog,\n    .p-dialog-topright .p-dialog,\n    .p-dialog-bottomleft .p-dialog,\n    .p-dialog-bottomright .p-dialog {\n        margin: 1rem;\n    }\n\n    .p-dialog-maximized {\n        width: 100vw !important;\n        height: 100vh !important;\n        top: 0px !important;\n        left: 0px !important;\n        max-height: 100%;\n        height: 100%;\n        border-radius: 0;\n    }\n\n    .p-dialog-maximized .p-dialog-content {\n        flex-grow: 1;\n    }\n\n    .p-dialog .p-resizable-handle {\n        position: absolute;\n        font-size: 0.1px;\n        display: block;\n        cursor: se-resize;\n        width: 12px;\n        height: 12px;\n        right: 1px;\n        bottom: 1px;\n    }\n\n    .p-dialog-enter-active {\n        animation: p-animate-dialog-enter 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    .p-dialog-leave-active {\n        animation: p-animate-dialog-leave 300ms cubic-bezier(.19,1,.22,1);\n    }\n\n    @keyframes p-animate-dialog-enter {\n        from {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n\n    @keyframes p-animate-dialog-leave {\n        to {\n            opacity: 0;\n            transform: scale(0.93);\n        }\n    }\n";
var inlineStyles = {
  mask: function mask(_ref) {
    var position = _ref.position, modal = _ref.modal;
    return {
      position: "fixed",
      height: "100%",
      width: "100%",
      left: 0,
      top: 0,
      display: "flex",
      justifyContent: position === "left" || position === "topleft" || position === "bottomleft" ? "flex-start" : position === "right" || position === "topright" || position === "bottomright" ? "flex-end" : "center",
      alignItems: position === "top" || position === "topleft" || position === "topright" ? "flex-start" : position === "bottom" || position === "bottomleft" || position === "bottomright" ? "flex-end" : "center",
      pointerEvents: modal ? "auto" : "none"
    };
  },
  root: {
    display: "flex",
    flexDirection: "column",
    pointerEvents: "auto"
  }
};
var classes = {
  mask: function mask2(_ref2) {
    var props = _ref2.props;
    var positions = ["left", "right", "top", "topleft", "topright", "bottom", "bottomleft", "bottomright"];
    var pos = positions.find(function(item) {
      return item === props.position;
    });
    return ["p-dialog-mask", {
      "p-overlay-mask p-overlay-mask-enter-active": props.modal
    }, pos ? "p-dialog-".concat(pos) : ""];
  },
  root: function root3(_ref3) {
    var props = _ref3.props, instance = _ref3.instance;
    return ["p-dialog p-component", {
      "p-dialog-maximized": props.maximizable && instance.maximized
    }];
  },
  header: "p-dialog-header",
  title: "p-dialog-title",
  headerActions: "p-dialog-header-actions",
  pcMaximizeButton: "p-dialog-maximize-button",
  pcCloseButton: "p-dialog-close-button",
  content: "p-dialog-content",
  footer: "p-dialog-footer"
};
var DialogStyle = BaseStyle.extend({
  name: "dialog",
  style,
  classes,
  inlineStyles
});
var script$1 = {
  name: "BaseDialog",
  "extends": script$a,
  props: {
    header: {
      type: null,
      "default": null
    },
    footer: {
      type: null,
      "default": null
    },
    visible: {
      type: Boolean,
      "default": false
    },
    modal: {
      type: Boolean,
      "default": null
    },
    contentStyle: {
      type: null,
      "default": null
    },
    contentClass: {
      type: String,
      "default": null
    },
    contentProps: {
      type: null,
      "default": null
    },
    maximizable: {
      type: Boolean,
      "default": false
    },
    dismissableMask: {
      type: Boolean,
      "default": false
    },
    closable: {
      type: Boolean,
      "default": true
    },
    closeOnEscape: {
      type: Boolean,
      "default": true
    },
    showHeader: {
      type: Boolean,
      "default": true
    },
    blockScroll: {
      type: Boolean,
      "default": false
    },
    baseZIndex: {
      type: Number,
      "default": 0
    },
    autoZIndex: {
      type: Boolean,
      "default": true
    },
    position: {
      type: String,
      "default": "center"
    },
    breakpoints: {
      type: Object,
      "default": null
    },
    draggable: {
      type: Boolean,
      "default": true
    },
    keepInViewport: {
      type: Boolean,
      "default": true
    },
    minX: {
      type: Number,
      "default": 0
    },
    minY: {
      type: Number,
      "default": 0
    },
    appendTo: {
      type: [String, Object],
      "default": "body"
    },
    closeIcon: {
      type: String,
      "default": void 0
    },
    maximizeIcon: {
      type: String,
      "default": void 0
    },
    minimizeIcon: {
      type: String,
      "default": void 0
    },
    closeButtonProps: {
      type: Object,
      "default": function _default() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }
    },
    maximizeButtonProps: {
      type: Object,
      "default": function _default2() {
        return {
          severity: "secondary",
          text: true,
          rounded: true
        };
      }
    },
    _instance: null
  },
  style: DialogStyle,
  provide: function provide5() {
    return {
      $pcDialog: this,
      $parentInstance: this
    };
  }
};
var script = {
  name: "Dialog",
  "extends": script$1,
  inheritAttrs: false,
  emits: ["update:visible", "show", "hide", "after-hide", "maximize", "unmaximize", "dragstart", "dragend"],
  provide: function provide6() {
    var _this = this;
    return {
      dialogRef: computed(function() {
        return _this._instance;
      })
    };
  },
  data: function data2() {
    return {
      containerVisible: this.visible,
      maximized: false,
      focusableMax: null,
      focusableClose: null,
      target: null
    };
  },
  documentKeydownListener: null,
  container: null,
  mask: null,
  content: null,
  headerContainer: null,
  footerContainer: null,
  maximizableButton: null,
  closeButton: null,
  styleElement: null,
  dragging: null,
  documentDragListener: null,
  documentDragEndListener: null,
  lastPageX: null,
  lastPageY: null,
  maskMouseDownTarget: null,
  updated: function updated3() {
    if (this.visible) {
      this.containerVisible = this.visible;
    }
  },
  beforeUnmount: function beforeUnmount2() {
    this.unbindDocumentState();
    this.unbindGlobalListeners();
    this.destroyStyle();
    if (this.mask && this.autoZIndex) {
      x.clear(this.mask);
    }
    this.container = null;
    this.mask = null;
  },
  mounted: function mounted4() {
    if (this.breakpoints) {
      this.createStyle();
    }
  },
  methods: {
    close: function close() {
      this.$emit("update:visible", false);
    },
    onEnter: function onEnter() {
      this.$emit("show");
      this.target = document.activeElement;
      this.enableDocumentSettings();
      this.bindGlobalListeners();
      if (this.autoZIndex) {
        x.set("modal", this.mask, this.baseZIndex + this.$primevue.config.zIndex.modal);
      }
    },
    onAfterEnter: function onAfterEnter() {
      this.focus();
    },
    onBeforeLeave: function onBeforeLeave() {
      if (this.modal) {
        !this.isUnstyled && W(this.mask, "p-overlay-mask-leave-active");
      }
      if (this.dragging && this.documentDragEndListener) {
        this.documentDragEndListener();
      }
    },
    onLeave: function onLeave() {
      this.$emit("hide");
      bt(this.target);
      this.target = null;
      this.focusableClose = null;
      this.focusableMax = null;
    },
    onAfterLeave: function onAfterLeave() {
      if (this.autoZIndex) {
        x.clear(this.mask);
      }
      this.containerVisible = false;
      this.unbindDocumentState();
      this.unbindGlobalListeners();
      this.$emit("after-hide");
    },
    onMaskMouseDown: function onMaskMouseDown(event) {
      this.maskMouseDownTarget = event.target;
    },
    onMaskMouseUp: function onMaskMouseUp() {
      if (this.dismissableMask && this.modal && this.mask === this.maskMouseDownTarget) {
        this.close();
      }
    },
    focus: function focus$1() {
      var findFocusableElement = function findFocusableElement2(container) {
        return container && container.querySelector("[autofocus]");
      };
      var focusTarget = this.$slots.footer && findFocusableElement(this.footerContainer);
      if (!focusTarget) {
        focusTarget = this.$slots.header && findFocusableElement(this.headerContainer);
        if (!focusTarget) {
          focusTarget = this.$slots["default"] && findFocusableElement(this.content);
          if (!focusTarget) {
            if (this.maximizable) {
              this.focusableMax = true;
              focusTarget = this.maximizableButton;
            } else {
              this.focusableClose = true;
              focusTarget = this.closeButton;
            }
          }
        }
      }
      if (focusTarget) {
        bt(focusTarget, {
          focusVisible: true
        });
      }
    },
    maximize: function maximize(event) {
      if (this.maximized) {
        this.maximized = false;
        this.$emit("unmaximize", event);
      } else {
        this.maximized = true;
        this.$emit("maximize", event);
      }
      if (!this.modal) {
        this.maximized ? blockBodyScroll() : unblockBodyScroll();
      }
    },
    enableDocumentSettings: function enableDocumentSettings() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        blockBodyScroll();
      }
    },
    unbindDocumentState: function unbindDocumentState() {
      if (this.modal || !this.modal && this.blockScroll || this.maximizable && this.maximized) {
        unblockBodyScroll();
      }
    },
    onKeyDown: function onKeyDown(event) {
      if (event.code === "Escape" && this.closeOnEscape) {
        this.close();
      }
    },
    bindDocumentKeyDownListener: function bindDocumentKeyDownListener() {
      if (!this.documentKeydownListener) {
        this.documentKeydownListener = this.onKeyDown.bind(this);
        window.document.addEventListener("keydown", this.documentKeydownListener);
      }
    },
    unbindDocumentKeyDownListener: function unbindDocumentKeyDownListener() {
      if (this.documentKeydownListener) {
        window.document.removeEventListener("keydown", this.documentKeydownListener);
        this.documentKeydownListener = null;
      }
    },
    containerRef: function containerRef(el) {
      this.container = el;
    },
    maskRef: function maskRef(el) {
      this.mask = el;
    },
    contentRef: function contentRef(el) {
      this.content = el;
    },
    headerContainerRef: function headerContainerRef(el) {
      this.headerContainer = el;
    },
    footerContainerRef: function footerContainerRef(el) {
      this.footerContainer = el;
    },
    maximizableRef: function maximizableRef(el) {
      this.maximizableButton = el ? el.$el : void 0;
    },
    closeButtonRef: function closeButtonRef(el) {
      this.closeButton = el ? el.$el : void 0;
    },
    createStyle: function createStyle() {
      if (!this.styleElement && !this.isUnstyled) {
        var _this$$primevue;
        this.styleElement = document.createElement("style");
        this.styleElement.type = "text/css";
        _t(this.styleElement, "nonce", (_this$$primevue = this.$primevue) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.config) === null || _this$$primevue === void 0 || (_this$$primevue = _this$$primevue.csp) === null || _this$$primevue === void 0 ? void 0 : _this$$primevue.nonce);
        document.head.appendChild(this.styleElement);
        var innerHTML = "";
        for (var breakpoint in this.breakpoints) {
          innerHTML += "\n                        @media screen and (max-width: ".concat(breakpoint, ") {\n                            .p-dialog[").concat(this.$attrSelector, "] {\n                                width: ").concat(this.breakpoints[breakpoint], " !important;\n                            }\n                        }\n                    ");
        }
        this.styleElement.innerHTML = innerHTML;
      }
    },
    destroyStyle: function destroyStyle() {
      if (this.styleElement) {
        document.head.removeChild(this.styleElement);
        this.styleElement = null;
      }
    },
    initDrag: function initDrag(event) {
      if (event.target.closest("div").getAttribute("data-pc-section") === "headeractions") {
        return;
      }
      if (this.draggable) {
        this.dragging = true;
        this.lastPageX = event.pageX;
        this.lastPageY = event.pageY;
        this.container.style.margin = "0";
        document.body.setAttribute("data-p-unselectable-text", "true");
        !this.isUnstyled && S$1(document.body, {
          "user-select": "none"
        });
        this.$emit("dragstart", event);
      }
    },
    bindGlobalListeners: function bindGlobalListeners() {
      if (this.draggable) {
        this.bindDocumentDragListener();
        this.bindDocumentDragEndListener();
      }
      if (this.closeOnEscape) {
        this.bindDocumentKeyDownListener();
      }
    },
    unbindGlobalListeners: function unbindGlobalListeners() {
      this.unbindDocumentDragListener();
      this.unbindDocumentDragEndListener();
      this.unbindDocumentKeyDownListener();
    },
    bindDocumentDragListener: function bindDocumentDragListener() {
      var _this2 = this;
      this.documentDragListener = function(event) {
        if (_this2.dragging) {
          var width = v$1(_this2.container);
          var height = C$1(_this2.container);
          var deltaX = event.pageX - _this2.lastPageX;
          var deltaY = event.pageY - _this2.lastPageY;
          var offset = _this2.container.getBoundingClientRect();
          var leftPos = offset.left + deltaX;
          var topPos = offset.top + deltaY;
          var viewport = h$1();
          var containerComputedStyle = getComputedStyle(_this2.container);
          var marginLeft = parseFloat(containerComputedStyle.marginLeft);
          var marginTop = parseFloat(containerComputedStyle.marginTop);
          _this2.container.style.position = "fixed";
          if (_this2.keepInViewport) {
            if (leftPos >= _this2.minX && leftPos + width < viewport.width) {
              _this2.lastPageX = event.pageX;
              _this2.container.style.left = leftPos - marginLeft + "px";
            }
            if (topPos >= _this2.minY && topPos + height < viewport.height) {
              _this2.lastPageY = event.pageY;
              _this2.container.style.top = topPos - marginTop + "px";
            }
          } else {
            _this2.lastPageX = event.pageX;
            _this2.container.style.left = leftPos - marginLeft + "px";
            _this2.lastPageY = event.pageY;
            _this2.container.style.top = topPos - marginTop + "px";
          }
        }
      };
      window.document.addEventListener("mousemove", this.documentDragListener);
    },
    unbindDocumentDragListener: function unbindDocumentDragListener() {
      if (this.documentDragListener) {
        window.document.removeEventListener("mousemove", this.documentDragListener);
        this.documentDragListener = null;
      }
    },
    bindDocumentDragEndListener: function bindDocumentDragEndListener() {
      var _this3 = this;
      this.documentDragEndListener = function(event) {
        if (_this3.dragging) {
          _this3.dragging = false;
          document.body.removeAttribute("data-p-unselectable-text");
          !_this3.isUnstyled && (document.body.style["user-select"] = "");
          _this3.$emit("dragend", event);
        }
      };
      window.document.addEventListener("mouseup", this.documentDragEndListener);
    },
    unbindDocumentDragEndListener: function unbindDocumentDragEndListener() {
      if (this.documentDragEndListener) {
        window.document.removeEventListener("mouseup", this.documentDragEndListener);
        this.documentDragEndListener = null;
      }
    }
  },
  computed: {
    maximizeIconComponent: function maximizeIconComponent() {
      return this.maximized ? this.minimizeIcon ? "span" : "WindowMinimizeIcon" : this.maximizeIcon ? "span" : "WindowMaximizeIcon";
    },
    ariaLabelledById: function ariaLabelledById() {
      return this.header != null || this.$attrs["aria-labelledby"] !== null ? this.$id + "_header" : null;
    },
    closeAriaLabel: function closeAriaLabel() {
      return this.$primevue.config.locale.aria ? this.$primevue.config.locale.aria.close : void 0;
    },
    dataP: function dataP3() {
      return f({
        maximized: this.maximized,
        modal: this.modal
      });
    }
  },
  directives: {
    ripple: Ripple,
    focustrap: FocusTrap
  },
  components: {
    Button: script$3,
    Portal: script$2,
    WindowMinimizeIcon: script$6,
    WindowMaximizeIcon: script$7,
    TimesIcon: script$8
  }
};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function ownKeys(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty(e, r, t2) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t2, enumerable: true, configurable: true, writable: true }) : e[r] = t2, e;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _toPrimitive(t2, r) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t2, r);
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}
var _hoisted_1$1 = ["data-p"];
var _hoisted_2$1 = ["aria-labelledby", "aria-modal", "data-p"];
var _hoisted_3$1 = ["id"];
var _hoisted_4$1 = ["data-p"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Button = resolveComponent("Button");
  var _component_Portal = resolveComponent("Portal");
  var _directive_focustrap = resolveDirective("focustrap");
  return openBlock(), createBlock(_component_Portal, {
    appendTo: _ctx.appendTo
  }, {
    "default": withCtx(function() {
      return [$data.containerVisible ? (openBlock(), createElementBlock("div", mergeProps({
        key: 0,
        ref: $options.maskRef,
        "class": _ctx.cx("mask"),
        style: _ctx.sx("mask", true, {
          position: _ctx.position,
          modal: _ctx.modal
        }),
        onMousedown: _cache[1] || (_cache[1] = function() {
          return $options.onMaskMouseDown && $options.onMaskMouseDown.apply($options, arguments);
        }),
        onMouseup: _cache[2] || (_cache[2] = function() {
          return $options.onMaskMouseUp && $options.onMaskMouseUp.apply($options, arguments);
        }),
        "data-p": $options.dataP
      }, _ctx.ptm("mask")), [createVNode(Transition, mergeProps({
        name: "p-dialog",
        onEnter: $options.onEnter,
        onAfterEnter: $options.onAfterEnter,
        onBeforeLeave: $options.onBeforeLeave,
        onLeave: $options.onLeave,
        onAfterLeave: $options.onAfterLeave,
        appear: ""
      }, _ctx.ptm("transition")), {
        "default": withCtx(function() {
          return [_ctx.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.containerRef,
            "class": _ctx.cx("root"),
            style: _ctx.sx("root"),
            role: "dialog",
            "aria-labelledby": $options.ariaLabelledById,
            "aria-modal": _ctx.modal,
            "data-p": $options.dataP
          }, _ctx.ptmi("root")), [_ctx.$slots.container ? renderSlot(_ctx.$slots, "container", {
            key: 0,
            closeCallback: $options.close,
            maximizeCallback: function maximizeCallback(event) {
              return $options.maximize(event);
            },
            initDragCallback: $options.initDrag
          }) : (openBlock(), createElementBlock(Fragment, {
            key: 1
          }, [_ctx.showHeader ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: $options.headerContainerRef,
            "class": _ctx.cx("header"),
            onMousedown: _cache[0] || (_cache[0] = function() {
              return $options.initDrag && $options.initDrag.apply($options, arguments);
            })
          }, _ctx.ptm("header")), [renderSlot(_ctx.$slots, "header", {
            "class": normalizeClass(_ctx.cx("title"))
          }, function() {
            return [_ctx.header ? (openBlock(), createElementBlock("span", mergeProps({
              key: 0,
              id: $options.ariaLabelledById,
              "class": _ctx.cx("title")
            }, _ctx.ptm("title")), toDisplayString$1(_ctx.header), 17, _hoisted_3$1)) : createCommentVNode("", true)];
          }), createBaseVNode("div", mergeProps({
            "class": _ctx.cx("headerActions")
          }, _ctx.ptm("headerActions")), [_ctx.maximizable ? renderSlot(_ctx.$slots, "maximizebutton", {
            key: 0,
            maximized: $data.maximized,
            maximizeCallback: function maximizeCallback(event) {
              return $options.maximize(event);
            }
          }, function() {
            return [createVNode(_component_Button, mergeProps({
              ref: $options.maximizableRef,
              autofocus: $data.focusableMax,
              "class": _ctx.cx("pcMaximizeButton"),
              onClick: $options.maximize,
              tabindex: _ctx.maximizable ? "0" : "-1",
              unstyled: _ctx.unstyled
            }, _ctx.maximizeButtonProps, {
              pt: _ctx.ptm("pcMaximizeButton"),
              "data-pc-group-section": "headericon"
            }), {
              icon: withCtx(function(slotProps) {
                return [renderSlot(_ctx.$slots, "maximizeicon", {
                  maximized: $data.maximized
                }, function() {
                  return [(openBlock(), createBlock(resolveDynamicComponent($options.maximizeIconComponent), mergeProps({
                    "class": [slotProps["class"], $data.maximized ? _ctx.minimizeIcon : _ctx.maximizeIcon]
                  }, _ctx.ptm("pcMaximizeButton")["icon"]), null, 16, ["class"]))];
                })];
              }),
              _: 3
            }, 16, ["autofocus", "class", "onClick", "tabindex", "unstyled", "pt"])];
          }) : createCommentVNode("", true), _ctx.closable ? renderSlot(_ctx.$slots, "closebutton", {
            key: 1,
            closeCallback: $options.close
          }, function() {
            return [createVNode(_component_Button, mergeProps({
              ref: $options.closeButtonRef,
              autofocus: $data.focusableClose,
              "class": _ctx.cx("pcCloseButton"),
              onClick: $options.close,
              "aria-label": $options.closeAriaLabel,
              unstyled: _ctx.unstyled
            }, _ctx.closeButtonProps, {
              pt: _ctx.ptm("pcCloseButton"),
              "data-pc-group-section": "headericon"
            }), {
              icon: withCtx(function(slotProps) {
                return [renderSlot(_ctx.$slots, "closeicon", {}, function() {
                  return [(openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon ? "span" : "TimesIcon"), mergeProps({
                    "class": [_ctx.closeIcon, slotProps["class"]]
                  }, _ctx.ptm("pcCloseButton")["icon"]), null, 16, ["class"]))];
                })];
              }),
              _: 3
            }, 16, ["autofocus", "class", "onClick", "aria-label", "unstyled", "pt"])];
          }) : createCommentVNode("", true)], 16)], 16)) : createCommentVNode("", true), createBaseVNode("div", mergeProps({
            ref: $options.contentRef,
            "class": [_ctx.cx("content"), _ctx.contentClass],
            style: _ctx.contentStyle,
            "data-p": $options.dataP
          }, _objectSpread(_objectSpread({}, _ctx.contentProps), _ctx.ptm("content"))), [renderSlot(_ctx.$slots, "default")], 16, _hoisted_4$1), _ctx.footer || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", mergeProps({
            key: 1,
            ref: $options.footerContainerRef,
            "class": _ctx.cx("footer")
          }, _ctx.ptm("footer")), [renderSlot(_ctx.$slots, "footer", {}, function() {
            return [createTextVNode(toDisplayString$1(_ctx.footer), 1)];
          })], 16)) : createCommentVNode("", true)], 64))], 16, _hoisted_2$1)), [[_directive_focustrap, {
            disabled: !_ctx.modal
          }]]) : createCommentVNode("", true)];
        }),
        _: 3
      }, 16, ["onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"])], 16, _hoisted_1$1)) : createCommentVNode("", true)];
    }),
    _: 3
  }, 8, ["appendTo"]);
}
script.render = render;
const _hoisted_1 = { class: "polotno-wrapper h-full w-full flex" };
const _hoisted_2 = { class: "flex-1 relative" };
const _hoisted_3 = {
  key: 0,
  class: "polotno-loading"
};
const _hoisted_4 = ["src"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "PolotnoEditor",
  props: {
    apiKey: {},
    initialImageUrls: {},
    width: {},
    height: {},
    theme: {}
  },
  emits: ["ready", "save"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const iframeRef = ref(null);
    const ready = ref(false);
    let pendingImageUrls = [];
    let exportResolve = null;
    let exportPSDResolve = null;
    const iframeSrc = computed(() => {
      const params = new URLSearchParams();
      if (props.apiKey) {
        params.set("apiKey", props.apiKey);
      }
      params.set("width", String(props.width || 1024));
      params.set("height", String(props.height || 1024));
      params.set("theme", props.theme || "dark");
      return `/polotno?${params.toString()}`;
    });
    function handleMessage(event) {
      const { type, dataUrl, data: data3, message, width, height, count } = event.data || {};
      switch (type) {
        case "ready":
          ready.value = true;
          emit2("ready");
          if (pendingImageUrls.length > 0) {
            loadImagesToCanvas(pendingImageUrls);
            pendingImageUrls = [];
          }
          break;
        case "exportResult":
          if (exportResolve) {
            exportResolve(dataUrl);
            exportResolve = null;
          } else {
            emit2("save", dataUrl);
          }
          break;
        case "exportPSDResult":
          if (exportPSDResolve) {
            const binary = atob(data3);
            const bytes = new Uint8Array(binary.length);
            for (let i2 = 0; i2 < binary.length; i2++) {
              bytes[i2] = binary.charCodeAt(i2);
            }
            exportPSDResolve(bytes.buffer);
            exportPSDResolve = null;
          }
          break;
        case "imageLoaded":
          console.log("[Polotno] Image loaded:", width, "x", height);
          break;
        case "imagesLoaded":
          console.log("[Polotno] Loaded", count, "images as layers");
          break;
        case "error":
          console.error("[Polotno] Error:", message);
          if (exportResolve) {
            exportResolve(null);
            exportResolve = null;
          }
          if (exportPSDResolve) {
            exportPSDResolve(null);
            exportPSDResolve = null;
          }
          break;
      }
    }
    function postMessage(message) {
      var _a;
      if ((_a = iframeRef.value) == null ? void 0 : _a.contentWindow) {
        iframeRef.value.contentWindow.postMessage(message, "*");
      }
    }
    function loadImagesToCanvas(imageUrls) {
      if (!ready.value) {
        pendingImageUrls = imageUrls;
        return;
      }
      postMessage({ type: "loadImages", data: { urls: imageUrls } });
    }
    function loadImageToCanvas(imageUrl) {
      loadImagesToCanvas([imageUrl]);
    }
    function exportImage() {
      return new Promise((resolve2) => {
        if (!ready.value) {
          resolve2(null);
          return;
        }
        exportResolve = resolve2;
        postMessage({ type: "exportImage" });
        setTimeout(() => {
          if (exportResolve) {
            exportResolve(null);
            exportResolve = null;
          }
        }, 1e4);
      });
    }
    function exportPSD() {
      return new Promise((resolve2) => {
        if (!ready.value) {
          resolve2(null);
          return;
        }
        exportPSDResolve = resolve2;
        postMessage({ type: "exportPSD" });
        setTimeout(() => {
          if (exportPSDResolve) {
            exportPSDResolve(null);
            exportPSDResolve = null;
          }
        }, 3e4);
      });
    }
    function clear() {
      postMessage({ type: "clear" });
    }
    function setSize(width, height) {
      postMessage({ type: "setSize", data: { width, height } });
    }
    onMounted(() => {
      window.addEventListener("message", handleMessage);
      if (props.initialImageUrls && props.initialImageUrls.length > 0) {
        pendingImageUrls = [...props.initialImageUrls];
      }
    });
    onUnmounted(() => {
      window.removeEventListener("message", handleMessage);
    });
    __expose({
      exportImage,
      exportPSD,
      loadImageToCanvas,
      loadImagesToCanvas,
      clear,
      setSize
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          !ready.value ? (openBlock(), createElementBlock("div", _hoisted_3, " Loading Polotno Editor... ")) : createCommentVNode("", true),
          createBaseVNode("iframe", {
            ref_key: "iframeRef",
            ref: iframeRef,
            src: iframeSrc.value,
            class: "polotno-iframe h-full w-full"
          }, null, 8, _hoisted_4)
        ])
      ]);
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const PolotnoEditor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-87280f44"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "Root",
  setup(__props, { expose: __expose }) {
    const visible = ref(false);
    const currentImageUrls = ref([]);
    const currentNode = ref(null);
    const editorReady = ref(false);
    const polotnoEditorRef = ref(null);
    const apiKey = ref("");
    const canvasWidth = ref(1024);
    const canvasHeight = ref(1024);
    const theme = ref("dark");
    let saveCallback = null;
    onMounted(() => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      apiKey.value = ((_b = (_a = app.ui) == null ? void 0 : _a.settings) == null ? void 0 : _b.getSettingValue("Comfy.PolotnoCanvasEditor.ApiKey")) || "";
      canvasWidth.value = ((_d = (_c = app.ui) == null ? void 0 : _c.settings) == null ? void 0 : _d.getSettingValue("Comfy.PolotnoCanvasEditor.DefaultWidth")) || 1024;
      canvasHeight.value = ((_f = (_e = app.ui) == null ? void 0 : _e.settings) == null ? void 0 : _f.getSettingValue("Comfy.PolotnoCanvasEditor.DefaultHeight")) || 1024;
      const colorPalette = ((_h = (_g = app.ui) == null ? void 0 : _g.settings) == null ? void 0 : _h.getSettingValue("Comfy.ColorPalette")) || "";
      theme.value = colorPalette.includes("light") ? "light" : "dark";
    });
    function open() {
      visible.value = true;
    }
    function close2() {
      visible.value = false;
    }
    function loadImages(imageUrls, node) {
      currentImageUrls.value = imageUrls;
      currentNode.value = node || null;
      visible.value = true;
    }
    function openNew(node) {
      currentImageUrls.value = [];
      currentNode.value = node || null;
      visible.value = true;
    }
    function setSaveCallback(callback) {
      saveCallback = callback;
    }
    function handleEditorReady() {
      editorReady.value = true;
    }
    function handleClose() {
      editorReady.value = false;
      currentImageUrls.value = [];
      currentNode.value = null;
    }
    async function handleSave(dataUrl) {
      if (!saveCallback) return;
      try {
        await saveCallback(dataUrl, currentNode.value);
        close2();
      } catch (error) {
        console.error("[Polotno] Save failed:", error);
      }
    }
    __expose({
      open,
      close: close2,
      loadImages,
      openNew,
      setSaveCallback
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(script), {
        visible: visible.value,
        "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => visible.value = $event),
        header: _ctx.$t("dialog.title"),
        style: { width: "95vw", height: "95vh" },
        maximizable: true,
        modal: true,
        closable: true,
        draggable: false,
        "content-class": "h-full",
        onHide: handleClose
      }, {
        default: withCtx(() => [
          visible.value ? (openBlock(), createBlock(PolotnoEditor, {
            key: 0,
            ref_key: "polotnoEditorRef",
            ref: polotnoEditorRef,
            "api-key": apiKey.value,
            "initial-image-urls": currentImageUrls.value,
            width: canvasWidth.value,
            height: canvasHeight.value,
            theme: theme.value,
            onReady: handleEditorReady,
            onSave: handleSave
          }, null, 8, ["api-key", "initial-image-urls", "width", "height", "theme"])) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["visible", "header"]);
    };
  }
});
const dialog$1 = { "title": "Polotno Canvas Editor", "save": "Save to ComfyUI", "cancel": "Cancel", "saveSuccess": "Image saved successfully", "saveFailed": "Failed to save image" };
const editor$1 = { "loading": "Loading editor...", "noImage": "No image loaded. Add elements from the side panel.", "exportFailed": "Failed to export image" };
const settings$1 = { "apiKey": "Polotno API Key", "apiKeyTooltip": "Your Polotno API key. Get one from https://polotno.com", "defaultWidth": "Default Canvas Width", "defaultHeight": "Default Canvas Height" };
const en = {
  dialog: dialog$1,
  editor: editor$1,
  settings: settings$1
};
const dialog = { "title": "Polotno ", "save": " ComfyUI", "cancel": "", "saveSuccess": "", "saveFailed": "" };
const editor = { "loading": "...", "noImage": "", "exportFailed": "" };
const settings = { "apiKey": "Polotno API ", "apiKeyTooltip": " Polotno API  https://polotno.com ", "defaultWidth": "", "defaultHeight": "" };
const zh = {
  dialog,
  editor,
  settings
};
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s2, w2) => {
  s2.pending_buf[s2.pending++] = w2 & 255;
  s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
};
const send_bits = (s2, value, length) => {
  if (s2.bi_valid > Buf_size - length) {
    s2.bi_buf |= value << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value >> Buf_size - s2.bi_valid;
    s2.bi_valid += length - Buf_size;
  } else {
    s2.bi_buf |= value << s2.bi_valid & 65535;
    s2.bi_valid += length;
  }
};
const send_code = (s2, c2, tree) => {
  send_bits(
    s2,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code2, len) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s2) => {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
};
const gen_bitlen = (s2, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h2;
  let n, m2;
  let bits;
  let xbits;
  let f2;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s2.bl_count[bits] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
    n = s2.heap[h2];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s2.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f2 = tree[n * 2];
    s2.opt_len += f2 * (bits + xbits);
    if (has_stree) {
      s2.static_len += f2 * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s2.bl_count[bits] === 0) {
      bits--;
    }
    s2.bl_count[bits]--;
    s2.bl_count[bits + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s2.bl_count[bits];
    while (n !== 0) {
      m2 = s2.heap[--h2];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code2 = code2 + bl_count[bits - 1] << 1;
    next_code[bits] = code2;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code2;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length;
    for (n = 0; n < 1 << extra_lbits[code2]; n++) {
      _length_code[length++] = code2;
    }
  }
  _length_code[length - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n = 0; n < 1 << extra_dbits[code2]; n++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s2) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s2.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s2.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s2.bl_tree[n * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.sym_next = s2.matches = 0;
};
const bi_windup = (s2) => {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
};
const smaller = (tree, n, m2, depth) => {
  const _n2 = n * 2;
  const _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
};
const pqdownheap = (s2, tree, k2) => {
  const v2 = s2.heap[k2];
  let j = k2 << 1;
  while (j <= s2.heap_len) {
    if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
      j++;
    }
    if (smaller(tree, v2, s2.heap[j], s2.depth)) {
      break;
    }
    s2.heap[k2] = s2.heap[j];
    k2 = j;
    j <<= 1;
  }
  s2.heap[k2] = v2;
};
const compress_block = (s2, ltree, dtree) => {
  let dist;
  let lc;
  let sx2 = 0;
  let code2;
  let extra;
  if (s2.sym_next !== 0) {
    do {
      dist = s2.pending_buf[s2.sym_buf + sx2++] & 255;
      dist += (s2.pending_buf[s2.sym_buf + sx2++] & 255) << 8;
      lc = s2.pending_buf[s2.sym_buf + sx2++];
      if (dist === 0) {
        send_code(s2, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s2, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s2, lc, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s2, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s2, dist, extra);
        }
      }
    } while (sx2 < s2.sym_next);
  }
  send_code(s2, END_BLOCK, ltree);
};
const build_tree = (s2, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m2;
  let max_code = -1;
  let node;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n;
      s2.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s2.depth[node] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s2.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s2, tree, n);
  }
  node = elems;
  do {
    n = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[
      1
      /*SMALLEST*/
    ] = s2.heap[s2.heap_len--];
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[--s2.heap_max] = n;
    s2.heap[--s2.heap_max] = m2;
    tree[node * 2] = tree[n * 2] + tree[m2 * 2];
    s2.depth[node] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
    tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
    s2.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
};
const scan_tree = (s2, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s2, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s2) => {
  let max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s2, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s2) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s2.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s2) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
};
const _tr_stored_block$1 = (s2, buf, stored_len, last) => {
  send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s2);
  put_short(s2, stored_len);
  put_short(s2, ~stored_len);
  if (stored_len) {
    s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
  }
  s2.pending += stored_len;
};
const _tr_align$1 = (s2) => {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
};
const _tr_flush_block$1 = (s2, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s2, buf, stored_len, last);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last) {
    bi_windup(s2);
  }
};
const _tr_tally$1 = (s2, dist, lc) => {
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc;
  if (dist === 0) {
    s2.dyn_ltree[lc * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.sym_next === s2.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c2, table = [];
  for (var n = 0; n < 256; n++) {
    c2 = n;
    for (var k2 = 0; k2 < 8; k2++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n] = c2;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t2 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f2) => {
  return f2 * 2 - (f2 > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s2) => {
  let n, m2;
  let p2;
  let wsize = s2.w_size;
  n = s2.hash_size;
  p2 = n;
  do {
    m2 = s2.head[--p2];
    s2.head[p2] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n);
  n = wsize;
  p2 = n;
  do {
    m2 = s2.prev[--p2];
    s2.prev[p2] = m2 >= wsize ? m2 - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s2, prev, data3) => (prev << s2.hash_shift ^ data3) & s2.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s2 = strm.state;
  let len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
};
const flush_block_only = (s2, last) => {
  _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
};
const put_byte = (s2, b2) => {
  s2.pending_buf[s2.pending++] = b2;
};
const putShortMSB = (s2, b2) => {
  s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b2 & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s2, cur_match) => {
  let chain_length = s2.max_chain_length;
  let scan = s2.strstart;
  let match;
  let len;
  let best_len = s2.prev_length;
  let nice_match = s2.nice_match;
  const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s2.window;
  const wmask = s2.w_mask;
  const prev = s2.prev;
  const strend = s2.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
};
const fill_window = (s2) => {
  const _w_size = s2.w_size;
  let n, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      if (s2.insert > s2.strstart) {
        s2.insert = s2.strstart;
      }
      slide_hash(s2);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
      while (s2.insert) {
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
};
const deflate_stored = (s2, flush) => {
  let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s2.strm.avail_in;
  do {
    len = 65535;
    have = s2.bi_valid + 42 >> 3;
    if (s2.strm.avail_out < have) {
      break;
    }
    have = s2.strm.avail_out - have;
    left = s2.strstart - s2.block_start;
    if (len > left + s2.strm.avail_in) {
      len = left + s2.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s2.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s2.strm.avail_in ? 1 : 0;
    _tr_stored_block(s2, 0, 0, last);
    s2.pending_buf[s2.pending - 4] = len;
    s2.pending_buf[s2.pending - 3] = len >> 8;
    s2.pending_buf[s2.pending - 2] = ~len;
    s2.pending_buf[s2.pending - 1] = ~len >> 8;
    flush_pending(s2.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
      s2.strm.next_out += left;
      s2.strm.avail_out -= left;
      s2.strm.total_out += left;
      s2.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len);
      s2.strm.next_out += len;
      s2.strm.avail_out -= len;
      s2.strm.total_out += len;
    }
  } while (last === 0);
  used -= s2.strm.avail_in;
  if (used) {
    if (used >= s2.w_size) {
      s2.matches = 2;
      s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
      s2.strstart = s2.w_size;
      s2.insert = s2.strstart;
    } else {
      if (s2.window_size - s2.strstart <= used) {
        s2.strstart -= s2.w_size;
        s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
        if (s2.matches < 2) {
          s2.matches++;
        }
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
      }
      s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
      s2.strstart += used;
      s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
    }
    s2.block_start = s2.strstart;
  }
  if (s2.high_water < s2.strstart) {
    s2.high_water = s2.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s2.window_size - s2.strstart;
  if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
    s2.block_start -= s2.w_size;
    s2.strstart -= s2.w_size;
    s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
    if (s2.matches < 2) {
      s2.matches++;
    }
    have += s2.w_size;
    if (s2.insert > s2.strstart) {
      s2.insert = s2.strstart;
    }
  }
  if (have > s2.strm.avail_in) {
    have = s2.strm.avail_in;
  }
  if (have) {
    read_buf(s2.strm, s2.window, s2.strstart, have);
    s2.strstart += have;
    s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
  }
  if (s2.high_water < s2.strstart) {
    s2.high_water = s2.strstart;
  }
  have = s2.bi_valid + 42 >> 3;
  have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
  min_block = have > s2.w_size ? s2.w_size : have;
  left = s2.strstart - s2.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s2.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s2.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s2, s2.block_start, len, last);
    s2.block_start += len;
    flush_pending(s2.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s2, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s2, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s2, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s2, flush) => {
  let bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s2) => {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s2 = strm.state;
  if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && //#ifdef GZIP
  s2.status !== GZIP_STATE && //#endif
  s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = //#ifdef GZIP
  s2.wrap === 2 ? GZIP_STATE : (
    //#endif
    s2.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = -2;
  _tr_init(s2);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.status = INIT_STATE;
  s2.wrap = wrap;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new Uint8Array(s2.w_size * 2);
  s2.head = new Uint16Array(s2.hash_size);
  s2.prev = new Uint16Array(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new Uint8Array(s2.pending_buf_size);
  s2.sym_buf = s2.lit_bufsize;
  s2.sym_end = (s2.lit_bufsize - 1) * 3;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s2.last_flush;
  s2.last_flush = flush;
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === INIT_STATE && s2.wrap === 0) {
    s2.status = BUSY_STATE;
  }
  if (s2.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
      level_flags = 0;
    } else if (s2.level < 6) {
      level_flags = 1;
    } else if (s2.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s2.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s2, header);
    if (s2.strstart !== 0) {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    strm.adler = 1;
    s2.status = BUSY_STATE;
    flush_pending(strm);
    if (s2.pending !== 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s2.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s2, 31);
    put_byte(s2, 139);
    put_byte(s2, 8);
    if (!s2.gzhead) {
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
      put_byte(s2, OS_CODE);
      s2.status = BUSY_STATE;
      flush_pending(strm);
      if (s2.pending !== 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s2,
        (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
      );
      put_byte(s2, s2.gzhead.time & 255);
      put_byte(s2, s2.gzhead.time >> 8 & 255);
      put_byte(s2, s2.gzhead.time >> 16 & 255);
      put_byte(s2, s2.gzhead.time >> 24 & 255);
      put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
      put_byte(s2, s2.gzhead.os & 255);
      if (s2.gzhead.extra && s2.gzhead.extra.length) {
        put_byte(s2, s2.gzhead.extra.length & 255);
        put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
      }
      if (s2.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
      }
      s2.gzindex = 0;
      s2.status = EXTRA_STATE;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      let beg = s2.pending;
      let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
      while (s2.pending + left > s2.pending_buf_size) {
        let copy = s2.pending_buf_size - s2.pending;
        s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy), s2.pending);
        s2.pending = s2.pending_buf_size;
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        s2.gzindex += copy;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s2.gzhead.extra);
      s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
      s2.pending += left;
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      s2.gzindex = 0;
    }
    s2.status = NAME_STATE;
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      let beg = s2.pending;
      let val;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      s2.gzindex = 0;
    }
    s2.status = COMMENT_STATE;
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      let beg = s2.pending;
      let val;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
    }
    s2.status = HCRC_STATE;
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s2.status = BUSY_STATE;
    flush_pending(strm);
    if (s2.pending !== 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
    let bstate = s2.level === 0 ? deflate_stored(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s2);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s2, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  const wrap = s2.wrap;
  if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    let tmpDict = new Uint8Array(s2.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    let str = s2.strstart;
    let n = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p2 in source) {
      if (_has(source, p2)) {
        obj[p2] = source[p2];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i2++] = c2;
    } else if (c2 < 2048) {
      buf[i2++] = 192 | c2 >>> 6;
      buf[i2++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i2++] = 224 | c2 >>> 12;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    } else {
      buf[i2++] = 240 | c2 >>> 18;
      buf[i2++] = 128 | c2 >>> 12 & 63;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buf[i2]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c2 = buf[i2++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    let c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c2 = c2 << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data3, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data3 === "string") {
    strm.input = strings.string2buf(data3);
  } else if (toString$1.call(data3) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data3);
  } else {
    strm.input = data3;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
var deflate_2 = deflate$1;
var deflate_1$1 = {
  deflate: deflate_2
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root4 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask3;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root4 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root4 > max) {
    root4 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root4 < min) {
    root4 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root4;
  drop = 0;
  low = -1;
  used = 1 << root4;
  mask3 = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root4 && (huff & mask3) !== low) {
      if (drop === 0) {
        drop = root4;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask3;
      table[low] = root4 << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root4;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data3, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data3) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data3);
  } else {
    strm.input = data3;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data3[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
var inflate_2 = inflate$1;
var inflate_1$1 = {
  inflate: inflate_2
};
const { deflate } = deflate_1$1;
const { inflate } = inflate_1$1;
var deflate_1 = deflate;
var inflate_1 = inflate;
var dctZigZag = new Int32Array([
  0,
  1,
  8,
  16,
  9,
  2,
  3,
  10,
  17,
  24,
  32,
  25,
  18,
  11,
  4,
  5,
  12,
  19,
  26,
  33,
  40,
  48,
  41,
  34,
  27,
  20,
  13,
  6,
  7,
  14,
  21,
  28,
  35,
  42,
  49,
  56,
  57,
  50,
  43,
  36,
  29,
  22,
  15,
  23,
  30,
  37,
  44,
  51,
  58,
  59,
  52,
  45,
  38,
  31,
  39,
  46,
  53,
  60,
  61,
  54,
  47,
  55,
  62,
  63
]);
var dctCos1 = 4017;
var dctSin1 = 799;
var dctCos3 = 3406;
var dctSin3 = 2276;
var dctCos6 = 1567;
var dctSin6 = 3784;
var dctSqrt2 = 5793;
var dctSqrt1d2 = 2896;
var maxResolutionInMP = 100;
var maxMemoryUsageBytes = 64 * 1024 * 1024;
var totalBytesAllocated = 0;
function requestMemoryAllocation(increaseAmount) {
  var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
  if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
    var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
    throw new Error("Max memory limit exceeded by at least ".concat(exceededAmount, "MB"));
  }
  totalBytesAllocated = totalMemoryImpactBytes;
}
function buildHuffmanTable(codeLengths, values) {
  var length = 16;
  while (length > 0 && !codeLengths[length - 1])
    length--;
  var code2 = [{ children: [], index: 0 }];
  var k2 = 0;
  var p2 = code2[0];
  for (var i2 = 0; i2 < length; i2++) {
    for (var j = 0; j < codeLengths[i2]; j++) {
      p2 = code2.pop();
      p2.children[p2.index] = values[k2];
      while (p2.index > 0) {
        if (code2.length === 0)
          throw new Error("Could not recreate Huffman Table");
        p2 = code2.pop();
      }
      p2.index++;
      code2.push(p2);
      while (code2.length <= i2) {
        var q = { children: [], index: 0 };
        code2.push(q);
        p2.children[p2.index] = q.children;
        p2 = q;
      }
      k2++;
    }
    if (i2 + 1 < length) {
      var q = { children: [], index: 0 };
      code2.push(q);
      p2.children[p2.index] = q.children;
      p2 = q;
    }
  }
  return code2[0].children;
}
function decodeScan(data3, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {
  var mcusPerLine = frame.mcusPerLine;
  var progressive = frame.progressive;
  var startOffset = offset;
  var bitsData = 0;
  var bitsCount = 0;
  function readBit() {
    if (bitsCount > 0) {
      bitsCount--;
      return bitsData >> bitsCount & 1;
    }
    bitsData = data3[offset++];
    if (bitsData == 255) {
      var nextByte = data3[offset++];
      if (nextByte)
        throw new Error("unexpected marker: ".concat((bitsData << 8 | nextByte).toString(16)));
    }
    bitsCount = 7;
    return bitsData >>> 7;
  }
  function decodeHuffman(tree) {
    var node = tree;
    while (true) {
      node = node[readBit()];
      if (typeof node === "number")
        return node;
      if (node === void 0)
        throw new Error("invalid huffman sequence");
    }
  }
  function receive(length) {
    var n2 = 0;
    while (length > 0) {
      n2 = n2 << 1 | readBit();
      length--;
    }
    return n2;
  }
  function receiveAndExtend(length) {
    var n2 = receive(length);
    if (n2 >= 1 << length - 1)
      return n2;
    return n2 + (-1 << length) + 1;
  }
  function decodeBaseline(component2, zz) {
    var t2 = decodeHuffman(component2.huffmanTableDC);
    var diff = t2 === 0 ? 0 : receiveAndExtend(t2);
    zz[0] = component2.pred += diff;
    var k3 = 1;
    while (k3 < 64) {
      var rs = decodeHuffman(component2.huffmanTableAC);
      var s2 = rs & 15;
      var r = rs >> 4;
      if (s2 === 0) {
        if (r < 15)
          break;
        k3 += 16;
        continue;
      }
      k3 += r;
      var z2 = dctZigZag[k3];
      zz[z2] = receiveAndExtend(s2);
      k3++;
    }
  }
  function decodeDCFirst(component2, zz) {
    var t2 = decodeHuffman(component2.huffmanTableDC);
    var diff = t2 === 0 ? 0 : receiveAndExtend(t2) << successive;
    zz[0] = component2.pred += diff;
  }
  function decodeDCSuccessive(_component, zz) {
    zz[0] |= readBit() << successive;
  }
  var eobrun = 0;
  function decodeACFirst(component2, zz) {
    if (eobrun > 0) {
      eobrun--;
      return;
    }
    var k3 = spectralStart, e = spectralEnd;
    while (k3 <= e) {
      var rs = decodeHuffman(component2.huffmanTableAC);
      var s2 = rs & 15;
      var r = rs >> 4;
      if (s2 === 0) {
        if (r < 15) {
          eobrun = receive(r) + (1 << r) - 1;
          break;
        }
        k3 += 16;
        continue;
      }
      k3 += r;
      var z2 = dctZigZag[k3];
      zz[z2] = receiveAndExtend(s2) * (1 << successive);
      k3++;
    }
  }
  var successiveACState = 0;
  var successiveACNextValue = 0;
  function decodeACSuccessive(component2, zz) {
    var k3 = spectralStart;
    var e = spectralEnd;
    var r = 0;
    while (k3 <= e) {
      var z2 = dctZigZag[k3];
      var direction = zz[z2] < 0 ? -1 : 1;
      switch (successiveACState) {
        case 0:
          var rs = decodeHuffman(component2.huffmanTableAC);
          var s2 = rs & 15;
          r = rs >> 4;
          if (s2 === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s2 !== 1)
              throw new Error("invalid ACn encoding");
            successiveACNextValue = receiveAndExtend(s2);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1:
        // skipping r zero items
        case 2:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction;
          } else {
            r--;
            if (r === 0)
              successiveACState = successiveACState == 2 ? 3 : 0;
          }
          break;
        case 3:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction;
          } else {
            zz[z2] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4:
          if (zz[z2]) {
            zz[z2] += (readBit() << successive) * direction;
          }
          break;
      }
      k3++;
    }
    if (successiveACState === 4) {
      eobrun--;
      if (eobrun === 0)
        successiveACState = 0;
    }
  }
  function decodeMcu(component2, decode, mcu2, row, col) {
    var mcuRow = mcu2 / mcusPerLine | 0;
    var mcuCol = mcu2 % mcusPerLine;
    var blockRow = mcuRow * component2.v + row;
    var blockCol = mcuCol * component2.h + col;
    if (component2.blocks[blockRow] === void 0)
      return;
    decode(component2, component2.blocks[blockRow][blockCol]);
  }
  function decodeBlock(component2, decode, mcu2) {
    var blockRow = mcu2 / component2.blocksPerLine | 0;
    var blockCol = mcu2 % component2.blocksPerLine;
    if (component2.blocks[blockRow] === void 0)
      return;
    decode(component2, component2.blocks[blockRow][blockCol]);
  }
  var componentsLength = components.length;
  var component;
  var decodeFn;
  if (progressive) {
    if (spectralStart === 0) {
      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
    } else {
      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    }
  } else {
    decodeFn = decodeBaseline;
  }
  var mcu = 0;
  var mcuExpected;
  if (componentsLength == 1) {
    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
  } else {
    mcuExpected = mcusPerLine * frame.mcusPerColumn;
  }
  if (!resetInterval)
    resetInterval = mcuExpected;
  var h2;
  var v2;
  var marker;
  while (mcu < mcuExpected) {
    for (var i2 = 0; i2 < componentsLength; i2++)
      components[i2].pred = 0;
    eobrun = 0;
    if (componentsLength == 1) {
      component = components[0];
      for (var n = 0; n < resetInterval; n++) {
        decodeBlock(component, decodeFn, mcu);
        mcu++;
      }
    } else {
      for (var n = 0; n < resetInterval; n++) {
        for (var i2 = 0; i2 < componentsLength; i2++) {
          component = components[i2];
          h2 = component.h;
          v2 = component.v;
          for (var j = 0; j < v2; j++) {
            for (var k2 = 0; k2 < h2; k2++) {
              decodeMcu(component, decodeFn, mcu, j, k2);
            }
          }
        }
        mcu++;
        if (mcu === mcuExpected)
          break;
      }
    }
    if (mcu === mcuExpected) {
      do {
        if (data3[offset] === 255) {
          if (data3[offset + 1] !== 0) {
            break;
          }
        }
        offset += 1;
      } while (offset < data3.length - 2);
    }
    bitsCount = 0;
    marker = data3[offset] << 8 | data3[offset + 1];
    if (marker < 65280)
      throw new Error("marker was not found");
    if (marker >= 65488 && marker <= 65495) {
      offset += 2;
    } else {
      break;
    }
  }
  return offset - startOffset;
}
function buildComponentData(component) {
  var lines = [];
  var blocksPerLine = component.blocksPerLine;
  var blocksPerColumn = component.blocksPerColumn;
  var samplesPerLine = blocksPerLine << 3;
  var R2 = new Int32Array(64);
  var r = new Uint8Array(64);
  function quantizeAndInverse(zz, dataOut, dataIn) {
    var qt = component.quantizationTable;
    var p2 = dataIn;
    for (var i3 = 0; i3 < 64; i3++) {
      p2[i3] = zz[i3] * qt[i3];
    }
    for (var i3 = 0; i3 < 8; ++i3) {
      var row = 8 * i3;
      if (p2[1 + row] == 0 && p2[2 + row] == 0 && p2[3 + row] == 0 && p2[4 + row] == 0 && p2[5 + row] == 0 && p2[6 + row] == 0 && p2[7 + row] == 0) {
        var t_1 = dctSqrt2 * p2[0 + row] + 512 >> 10;
        p2[0 + row] = t_1;
        p2[1 + row] = t_1;
        p2[2 + row] = t_1;
        p2[3 + row] = t_1;
        p2[4 + row] = t_1;
        p2[5 + row] = t_1;
        p2[6 + row] = t_1;
        p2[7 + row] = t_1;
        continue;
      }
      var v0 = dctSqrt2 * p2[0 + row] + 128 >> 8;
      var v1 = dctSqrt2 * p2[4 + row] + 128 >> 8;
      var v2 = p2[2 + row];
      var v3 = p2[6 + row];
      var v4 = dctSqrt1d2 * (p2[1 + row] - p2[7 + row]) + 128 >> 8;
      var v7 = dctSqrt1d2 * (p2[1 + row] + p2[7 + row]) + 128 >> 8;
      var v5 = p2[3 + row] << 4;
      var v6 = p2[5 + row] << 4;
      var t2 = v0 - v1 + 1 >> 1;
      v0 = v0 + v1 + 1 >> 1;
      v1 = t2;
      t2 = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
      v3 = t2;
      t2 = v4 - v6 + 1 >> 1;
      v4 = v4 + v6 + 1 >> 1;
      v6 = t2;
      t2 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5 + 1 >> 1;
      v7 = t2;
      t2 = v0 - v3 + 1 >> 1;
      v0 = v0 + v3 + 1 >> 1;
      v3 = t2;
      t2 = v1 - v2 + 1 >> 1;
      v1 = v1 + v2 + 1 >> 1;
      v2 = t2;
      t2 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t2;
      t2 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t2;
      p2[0 + row] = v0 + v7;
      p2[7 + row] = v0 - v7;
      p2[1 + row] = v1 + v6;
      p2[6 + row] = v1 - v6;
      p2[2 + row] = v2 + v5;
      p2[5 + row] = v2 - v5;
      p2[3 + row] = v3 + v4;
      p2[4 + row] = v3 - v4;
    }
    for (var i3 = 0; i3 < 8; ++i3) {
      var col = i3;
      if (p2[1 * 8 + col] == 0 && p2[2 * 8 + col] == 0 && p2[3 * 8 + col] == 0 && p2[4 * 8 + col] == 0 && p2[5 * 8 + col] == 0 && p2[6 * 8 + col] == 0 && p2[7 * 8 + col] == 0) {
        var t_2 = dctSqrt2 * dataIn[i3 + 0] + 8192 >> 14;
        p2[0 * 8 + col] = t_2;
        p2[1 * 8 + col] = t_2;
        p2[2 * 8 + col] = t_2;
        p2[3 * 8 + col] = t_2;
        p2[4 * 8 + col] = t_2;
        p2[5 * 8 + col] = t_2;
        p2[6 * 8 + col] = t_2;
        p2[7 * 8 + col] = t_2;
        continue;
      }
      var v0 = dctSqrt2 * p2[0 * 8 + col] + 2048 >> 12;
      var v1 = dctSqrt2 * p2[4 * 8 + col] + 2048 >> 12;
      var v2 = p2[2 * 8 + col];
      var v3 = p2[6 * 8 + col];
      var v4 = dctSqrt1d2 * (p2[1 * 8 + col] - p2[7 * 8 + col]) + 2048 >> 12;
      var v7 = dctSqrt1d2 * (p2[1 * 8 + col] + p2[7 * 8 + col]) + 2048 >> 12;
      var v5 = p2[3 * 8 + col];
      var v6 = p2[5 * 8 + col];
      var t2 = v0 - v1 + 1 >> 1;
      v0 = v0 + v1 + 1 >> 1;
      v1 = t2;
      t2 = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
      v3 = t2;
      t2 = v4 - v6 + 1 >> 1;
      v4 = v4 + v6 + 1 >> 1;
      v6 = t2;
      t2 = v7 + v5 + 1 >> 1;
      v5 = v7 - v5 + 1 >> 1;
      v7 = t2;
      t2 = v0 - v3 + 1 >> 1;
      v0 = v0 + v3 + 1 >> 1;
      v3 = t2;
      t2 = v1 - v2 + 1 >> 1;
      v1 = v1 + v2 + 1 >> 1;
      v2 = t2;
      t2 = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
      v7 = t2;
      t2 = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
      v6 = t2;
      p2[0 * 8 + col] = v0 + v7;
      p2[7 * 8 + col] = v0 - v7;
      p2[1 * 8 + col] = v1 + v6;
      p2[6 * 8 + col] = v1 - v6;
      p2[2 * 8 + col] = v2 + v5;
      p2[5 * 8 + col] = v2 - v5;
      p2[3 * 8 + col] = v3 + v4;
      p2[4 * 8 + col] = v3 - v4;
    }
    for (var i3 = 0; i3 < 64; ++i3) {
      var sample2 = 128 + (p2[i3] + 8 >> 4);
      dataOut[i3] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
    }
  }
  requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
  for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
    var scanLine = blockRow << 3;
    for (var i2 = 0; i2 < 8; i2++)
      lines.push(new Uint8Array(samplesPerLine));
    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R2);
      var offset = 0;
      var sample = blockCol << 3;
      for (var j = 0; j < 8; j++) {
        var line = lines[scanLine + j];
        for (var i2 = 0; i2 < 8; i2++)
          line[sample + i2] = r[offset++];
      }
    }
  }
  return lines;
}
function clampTo8bit(a2) {
  return a2 < 0 ? 0 : a2 > 255 ? 255 : a2;
}
function parse(data3) {
  var self2 = {
    width: 0,
    height: 0,
    comments: [],
    adobe: void 0,
    components: [],
    exifBuffer: void 0,
    jfif: void 0
  };
  var maxResolutionInPixels = maxResolutionInMP * 1e3 * 1e3;
  var offset = 0;
  function readUint162() {
    var value = data3[offset] << 8 | data3[offset + 1];
    offset += 2;
    return value;
  }
  function readDataBlock() {
    var length = readUint162();
    var array = data3.subarray(offset, offset + length - 2);
    offset += array.length;
    return array;
  }
  function prepareComponents(frame2) {
    var maxH = 0, maxV = 0;
    for (var componentId2 in frame2.components) {
      if (frame2.components.hasOwnProperty(componentId2)) {
        var component2 = frame2.components[componentId2];
        if (maxH < component2.h)
          maxH = component2.h;
        if (maxV < component2.v)
          maxV = component2.v;
      }
    }
    var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH);
    var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV);
    for (var componentId2 in frame2.components) {
      if (frame2.components.hasOwnProperty(componentId2)) {
        var component2 = frame2.components[componentId2];
        var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH);
        var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV);
        var blocksPerLineForMcu = mcusPerLine * component2.h;
        var blocksPerColumnForMcu = mcusPerColumn * component2.v;
        var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
        var blocks = [];
        requestMemoryAllocation(blocksToAllocate * 256);
        for (var i3 = 0; i3 < blocksPerColumnForMcu; i3++) {
          var row = [];
          for (var j2 = 0; j2 < blocksPerLineForMcu; j2++) {
            row.push(new Int32Array(64));
          }
          blocks.push(row);
        }
        component2.blocksPerLine = blocksPerLine;
        component2.blocksPerColumn = blocksPerColumn;
        component2.blocks = blocks;
      }
    }
    frame2.maxH = maxH;
    frame2.maxV = maxV;
    frame2.mcusPerLine = mcusPerLine;
    frame2.mcusPerColumn = mcusPerColumn;
  }
  var jfif = null;
  var adobe = null;
  var frame = void 0;
  var resetInterval = 0;
  var quantizationTables = [];
  var frames = [];
  var huffmanTablesAC = [];
  var huffmanTablesDC = [];
  var fileMarker = readUint162();
  var malformedDataOffset = -1;
  if (fileMarker != 65496) {
    throw new Error("SOI not found");
  }
  fileMarker = readUint162();
  while (fileMarker != 65497) {
    switch (fileMarker) {
      case 65280:
        break;
      case 65504:
      // APP0 (Application Specific)
      case 65505:
      // APP1
      case 65506:
      // APP2
      case 65507:
      // APP3
      case 65508:
      // APP4
      case 65509:
      // APP5
      case 65510:
      // APP6
      case 65511:
      // APP7
      case 65512:
      // APP8
      case 65513:
      // APP9
      case 65514:
      // APP10
      case 65515:
      // APP11
      case 65516:
      // APP12
      case 65517:
      // APP13
      case 65518:
      // APP14
      case 65519:
      // APP15
      case 65534: {
        var appData = readDataBlock();
        if (fileMarker === 65534) {
          var comment = "";
          for (var ii = 0; ii < appData.byteLength; ii++) {
            comment += String.fromCharCode(appData[ii]);
          }
          self2.comments.push(comment);
        }
        if (fileMarker === 65504) {
          if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
            jfif = {
              version: { major: appData[5], minor: appData[6] },
              densityUnits: appData[7],
              xDensity: appData[8] << 8 | appData[9],
              yDensity: appData[10] << 8 | appData[11],
              thumbWidth: appData[12],
              thumbHeight: appData[13],
              thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
            };
          }
        }
        if (fileMarker === 65505) {
          if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
            self2.exifBuffer = appData.subarray(5, appData.length);
          }
        }
        if (fileMarker === 65518) {
          if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
            adobe = {
              version: appData[6],
              flags0: appData[7] << 8 | appData[8],
              flags1: appData[9] << 8 | appData[10],
              transformCode: appData[11]
            };
          }
        }
        break;
      }
      case 65499: {
        var quantizationTablesLength = readUint162();
        var quantizationTablesEnd = quantizationTablesLength + offset - 2;
        while (offset < quantizationTablesEnd) {
          var quantizationTableSpec = data3[offset++];
          requestMemoryAllocation(64 * 4);
          var tableData = new Int32Array(64);
          if (quantizationTableSpec >> 4 === 0) {
            for (var j = 0; j < 64; j++) {
              var z2 = dctZigZag[j];
              tableData[z2] = data3[offset++];
            }
          } else if (quantizationTableSpec >> 4 === 1) {
            for (var j = 0; j < 64; j++) {
              var z2 = dctZigZag[j];
              tableData[z2] = readUint162();
            }
          } else
            throw new Error("DQT: invalid table spec");
          quantizationTables[quantizationTableSpec & 15] = tableData;
        }
        break;
      }
      case 65472:
      // SOF0 (Start of Frame, Baseline DCT)
      case 65473:
      // SOF1 (Start of Frame, Extended DCT)
      case 65474: {
        readUint162();
        frame = {
          extended: fileMarker === 65473,
          progressive: fileMarker === 65474,
          precision: data3[offset++],
          scanLines: readUint162(),
          samplesPerLine: readUint162(),
          components: {},
          componentsOrder: [],
          maxH: 0,
          maxV: 0,
          mcusPerLine: 0,
          mcusPerColumn: 0
        };
        var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
        if (pixelsInFrame > maxResolutionInPixels) {
          var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
          throw new Error("maxResolutionInMP limit exceeded by ".concat(exceededAmount, "MP"));
        }
        var componentsCount = data3[offset++];
        for (var i2 = 0; i2 < componentsCount; i2++) {
          var componentId = data3[offset];
          var h2 = data3[offset + 1] >> 4;
          var v2 = data3[offset + 1] & 15;
          var qId = data3[offset + 2];
          frame.componentsOrder.push(componentId);
          frame.components[componentId] = {
            h: h2,
            v: v2,
            quantizationIdx: qId,
            blocksPerColumn: 0,
            blocksPerLine: 0,
            blocks: [],
            pred: 0
          };
          offset += 3;
        }
        prepareComponents(frame);
        frames.push(frame);
        break;
      }
      case 65476: {
        var huffmanLength = readUint162();
        for (var i2 = 2; i2 < huffmanLength; ) {
          var huffmanTableSpec = data3[offset++];
          var codeLengths = new Uint8Array(16);
          var codeLengthSum = 0;
          for (var j = 0; j < 16; j++, offset++) {
            codeLengthSum += codeLengths[j] = data3[offset];
          }
          requestMemoryAllocation(16 + codeLengthSum);
          var huffmanValues = new Uint8Array(codeLengthSum);
          for (var j = 0; j < codeLengthSum; j++, offset++) {
            huffmanValues[j] = data3[offset];
          }
          i2 += 17 + codeLengthSum;
          var index = huffmanTableSpec & 15;
          var table = huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC;
          table[index] = buildHuffmanTable(codeLengths, huffmanValues);
        }
        break;
      }
      case 65501:
        readUint162();
        resetInterval = readUint162();
        break;
      case 65500:
        readUint162();
        readUint162();
        break;
      case 65498: {
        readUint162();
        var selectorsCount = data3[offset++];
        var components = [];
        for (var i2 = 0; i2 < selectorsCount; i2++) {
          var component = frame.components[data3[offset++]];
          var tableSpec = data3[offset++];
          component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
          component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
          components.push(component);
        }
        var spectralStart = data3[offset++];
        var spectralEnd = data3[offset++];
        var successiveApproximation = data3[offset++];
        var processed = decodeScan(data3, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);
        offset += processed;
        break;
      }
      case 65535:
        if (data3[offset] !== 255) {
          offset--;
        }
        break;
      default: {
        if (data3[offset - 3] == 255 && data3[offset - 2] >= 192 && data3[offset - 2] <= 254) {
          offset -= 3;
          break;
        } else if (fileMarker === 224 || fileMarker == 225) {
          if (malformedDataOffset !== -1) {
            throw new Error("first unknown JPEG marker at offset ".concat(malformedDataOffset.toString(16), ", second unknown JPEG marker ").concat(fileMarker.toString(16), " at offset ").concat((offset - 1).toString(16)));
          }
          malformedDataOffset = offset - 1;
          var nextOffset = readUint162();
          if (data3[offset + nextOffset - 2] === 255) {
            offset += nextOffset - 2;
            break;
          }
        }
        throw new Error("unknown JPEG marker " + fileMarker.toString(16));
      }
    }
    fileMarker = readUint162();
  }
  if (frames.length != 1)
    throw new Error("only single frame JPEGs supported");
  for (var i2 = 0; i2 < frames.length; i2++) {
    var cp = frames[i2].components;
    for (var j in cp) {
      cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
      delete cp[j].quantizationIdx;
    }
  }
  self2.width = frame.samplesPerLine;
  self2.height = frame.scanLines;
  self2.jfif = jfif;
  self2.adobe = adobe;
  self2.components = [];
  for (var i2 = 0; i2 < frame.componentsOrder.length; i2++) {
    var component = frame.components[frame.componentsOrder[i2]];
    self2.components.push({
      lines: buildComponentData(component),
      scaleX: component.h / frame.maxH,
      scaleY: component.v / frame.maxV
    });
  }
  return self2;
}
function getData(decoded) {
  var offset = 0;
  var colorTransform = false;
  var width = decoded.width;
  var height = decoded.height;
  var dataLength = width * height * decoded.components.length;
  requestMemoryAllocation(dataLength);
  var data3 = new Uint8Array(dataLength);
  switch (decoded.components.length) {
    case 1: {
      var component1 = decoded.components[0];
      for (var y2 = 0; y2 < height; y2++) {
        var component1Line = component1.lines[0 | y2 * component1.scaleY];
        for (var x2 = 0; x2 < width; x2++) {
          var Y2 = component1Line[0 | x2 * component1.scaleX];
          data3[offset++] = Y2;
        }
      }
      break;
    }
    case 2: {
      var component1 = decoded.components[0];
      var component2 = decoded.components[1];
      for (var y2 = 0; y2 < height; y2++) {
        var component1Line = component1.lines[0 | y2 * component1.scaleY];
        var component2Line = component2.lines[0 | y2 * component2.scaleY];
        for (var x2 = 0; x2 < width; x2++) {
          var Y1 = component1Line[0 | x2 * component1.scaleX];
          data3[offset++] = Y1;
          var Y22 = component2Line[0 | x2 * component2.scaleX];
          data3[offset++] = Y22;
        }
      }
      break;
    }
    case 3: {
      colorTransform = true;
      if (decoded.adobe && decoded.adobe.transformCode)
        colorTransform = true;
      var component1 = decoded.components[0];
      var component2 = decoded.components[1];
      var component3 = decoded.components[2];
      for (var y2 = 0; y2 < height; y2++) {
        var component1Line = component1.lines[0 | y2 * component1.scaleY];
        var component2Line = component2.lines[0 | y2 * component2.scaleY];
        var component3Line = component3.lines[0 | y2 * component3.scaleY];
        for (var x2 = 0; x2 < width; x2++) {
          var Y2 = void 0, Cb = void 0, Cr = void 0, R2 = void 0, G2 = void 0, B = void 0;
          if (!colorTransform) {
            R2 = component1Line[0 | x2 * component1.scaleX];
            G2 = component2Line[0 | x2 * component2.scaleX];
            B = component3Line[0 | x2 * component3.scaleX];
          } else {
            Y2 = component1Line[0 | x2 * component1.scaleX];
            Cb = component2Line[0 | x2 * component2.scaleX];
            Cr = component3Line[0 | x2 * component3.scaleX];
            R2 = clampTo8bit(Y2 + 1.402 * (Cr - 128));
            G2 = clampTo8bit(Y2 - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
            B = clampTo8bit(Y2 + 1.772 * (Cb - 128));
          }
          data3[offset++] = R2;
          data3[offset++] = G2;
          data3[offset++] = B;
        }
      }
      break;
    }
    case 4: {
      if (!decoded.adobe)
        throw new Error("Unsupported color mode (4 components)");
      colorTransform = false;
      if (decoded.adobe && decoded.adobe.transformCode)
        colorTransform = true;
      var component1 = decoded.components[0];
      var component2 = decoded.components[1];
      var component3 = decoded.components[2];
      var component4 = decoded.components[3];
      for (var y2 = 0; y2 < height; y2++) {
        var component1Line = component1.lines[0 | y2 * component1.scaleY];
        var component2Line = component2.lines[0 | y2 * component2.scaleY];
        var component3Line = component3.lines[0 | y2 * component3.scaleY];
        var component4Line = component4.lines[0 | y2 * component4.scaleY];
        for (var x2 = 0; x2 < width; x2++) {
          var Y2 = void 0, Cb = void 0, Cr = void 0, K2 = void 0, C2 = void 0, M = void 0, Ye = void 0;
          if (!colorTransform) {
            C2 = component1Line[0 | x2 * component1.scaleX];
            M = component2Line[0 | x2 * component2.scaleX];
            Ye = component3Line[0 | x2 * component3.scaleX];
            K2 = component4Line[0 | x2 * component4.scaleX];
          } else {
            Y2 = component1Line[0 | x2 * component1.scaleX];
            Cb = component2Line[0 | x2 * component2.scaleX];
            Cr = component3Line[0 | x2 * component3.scaleX];
            K2 = component4Line[0 | x2 * component4.scaleX];
            C2 = 255 - clampTo8bit(Y2 + 1.402 * (Cr - 128));
            M = 255 - clampTo8bit(Y2 - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
            Ye = 255 - clampTo8bit(Y2 + 1.772 * (Cb - 128));
          }
          data3[offset++] = 255 - C2;
          data3[offset++] = 255 - M;
          data3[offset++] = 255 - Ye;
          data3[offset++] = 255 - K2;
        }
      }
      break;
    }
    default:
      throw new Error("Unsupported color mode");
  }
  return data3;
}
function decodeJpeg(encoded, createImageData2) {
  totalBytesAllocated = 0;
  if (encoded.length === 0)
    throw new Error("Empty jpeg buffer");
  var decoded = parse(encoded);
  requestMemoryAllocation(decoded.width * decoded.height * 4);
  var data3 = getData(decoded);
  var imageData = createImageData2(decoded.width, decoded.height);
  var width = imageData.width;
  var height = imageData.height;
  var imageDataArray = imageData.data;
  var i2 = 0;
  var j = 0;
  switch (decoded.components.length) {
    case 1:
      for (var y2 = 0; y2 < height; y2++) {
        for (var x2 = 0; x2 < width; x2++) {
          var Y2 = data3[i2++];
          imageDataArray[j++] = Y2;
          imageDataArray[j++] = Y2;
          imageDataArray[j++] = Y2;
          imageDataArray[j++] = 255;
        }
      }
      break;
    case 3:
      for (var y2 = 0; y2 < height; y2++) {
        for (var x2 = 0; x2 < width; x2++) {
          var R2 = data3[i2++];
          var G2 = data3[i2++];
          var B = data3[i2++];
          imageDataArray[j++] = R2;
          imageDataArray[j++] = G2;
          imageDataArray[j++] = B;
          imageDataArray[j++] = 255;
        }
      }
      break;
    case 4:
      for (var y2 = 0; y2 < height; y2++) {
        for (var x2 = 0; x2 < width; x2++) {
          var C2 = data3[i2++];
          var M = data3[i2++];
          var Y2 = data3[i2++];
          var K2 = data3[i2++];
          var R2 = 255 - clampTo8bit(C2 * (1 - K2 / 255) + K2);
          var G2 = 255 - clampTo8bit(M * (1 - K2 / 255) + K2);
          var B = 255 - clampTo8bit(Y2 * (1 - K2 / 255) + K2);
          imageDataArray[j++] = R2;
          imageDataArray[j++] = G2;
          imageDataArray[j++] = B;
          imageDataArray[j++] = 255;
        }
      }
      break;
    default:
      throw new Error("Unsupported color mode");
  }
  return imageData;
}
var RAW_IMAGE_DATA = false;
var fromBlendMode = {};
var toBlendMode = {
  "pass": "pass through",
  "norm": "normal",
  "diss": "dissolve",
  "dark": "darken",
  "mul ": "multiply",
  "idiv": "color burn",
  "lbrn": "linear burn",
  "dkCl": "darker color",
  "lite": "lighten",
  "scrn": "screen",
  "div ": "color dodge",
  "lddg": "linear dodge",
  "lgCl": "lighter color",
  "over": "overlay",
  "sLit": "soft light",
  "hLit": "hard light",
  "vLit": "vivid light",
  "lLit": "linear light",
  "pLit": "pin light",
  "hMix": "hard mix",
  "diff": "difference",
  "smud": "exclusion",
  "fsub": "subtract",
  "fdiv": "divide",
  "hue ": "hue",
  "sat ": "saturation",
  "colr": "color",
  "lum ": "luminosity"
};
Object.keys(toBlendMode).forEach(function(key) {
  return fromBlendMode[toBlendMode[key]] = key;
});
var layerColors = [
  "none",
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "violet",
  "gray"
];
var largeAdditionalInfoKeys = [
  // from documentation
  "LMsk",
  "Lr16",
  "Lr32",
  "Layr",
  "Mt16",
  "Mt32",
  "Mtrn",
  "Alph",
  "FMsk",
  "lnk2",
  "FEid",
  "FXid",
  "PxSD",
  // from guessing
  "cinf"
];
function revMap$1(map) {
  var result = {};
  Object.keys(map).forEach(function(key) {
    return result[map[key]] = key;
  });
  return result;
}
function createEnum(prefix, def2, map) {
  var rev = revMap$1(map);
  var decode = function(val) {
    var value = val.split(".")[1];
    if (value && !rev[value])
      throw new Error("Unrecognized value for enum: '".concat(val, "'"));
    return rev[value] || def2;
  };
  var encode = function(val) {
    if (val && !map[val])
      throw new Error("Invalid value for enum: '".concat(val, "'"));
    return "".concat(prefix, ".").concat(map[val] || map[def2]);
  };
  return { decode, encode };
}
var ColorSpace;
(function(ColorSpace2) {
  ColorSpace2[ColorSpace2["RGB"] = 0] = "RGB";
  ColorSpace2[ColorSpace2["HSB"] = 1] = "HSB";
  ColorSpace2[ColorSpace2["CMYK"] = 2] = "CMYK";
  ColorSpace2[ColorSpace2["Lab"] = 7] = "Lab";
  ColorSpace2[ColorSpace2["Grayscale"] = 8] = "Grayscale";
})(ColorSpace || (ColorSpace = {}));
var LayerMaskFlags;
(function(LayerMaskFlags2) {
  LayerMaskFlags2[LayerMaskFlags2["PositionRelativeToLayer"] = 1] = "PositionRelativeToLayer";
  LayerMaskFlags2[LayerMaskFlags2["LayerMaskDisabled"] = 2] = "LayerMaskDisabled";
  LayerMaskFlags2[LayerMaskFlags2["InvertLayerMaskWhenBlending"] = 4] = "InvertLayerMaskWhenBlending";
  LayerMaskFlags2[LayerMaskFlags2["LayerMaskFromRenderingOtherData"] = 8] = "LayerMaskFromRenderingOtherData";
  LayerMaskFlags2[LayerMaskFlags2["MaskHasParametersAppliedToIt"] = 16] = "MaskHasParametersAppliedToIt";
})(LayerMaskFlags || (LayerMaskFlags = {}));
var MaskParams;
(function(MaskParams2) {
  MaskParams2[MaskParams2["UserMaskDensity"] = 1] = "UserMaskDensity";
  MaskParams2[MaskParams2["UserMaskFeather"] = 2] = "UserMaskFeather";
  MaskParams2[MaskParams2["VectorMaskDensity"] = 4] = "VectorMaskDensity";
  MaskParams2[MaskParams2["VectorMaskFeather"] = 8] = "VectorMaskFeather";
})(MaskParams || (MaskParams = {}));
var ChannelID;
(function(ChannelID2) {
  ChannelID2[ChannelID2["Color0"] = 0] = "Color0";
  ChannelID2[ChannelID2["Color1"] = 1] = "Color1";
  ChannelID2[ChannelID2["Color2"] = 2] = "Color2";
  ChannelID2[ChannelID2["Color3"] = 3] = "Color3";
  ChannelID2[ChannelID2["Transparency"] = -1] = "Transparency";
  ChannelID2[ChannelID2["UserMask"] = -2] = "UserMask";
  ChannelID2[ChannelID2["RealUserMask"] = -3] = "RealUserMask";
})(ChannelID || (ChannelID = {}));
var Compression;
(function(Compression2) {
  Compression2[Compression2["RawData"] = 0] = "RawData";
  Compression2[Compression2["RleCompressed"] = 1] = "RleCompressed";
  Compression2[Compression2["ZipWithoutPrediction"] = 2] = "ZipWithoutPrediction";
  Compression2[Compression2["ZipWithPrediction"] = 3] = "ZipWithPrediction";
})(Compression || (Compression = {}));
function offsetForChannel(channelId, cmyk) {
  switch (channelId) {
    case 0:
      return 0;
    case 1:
      return 1;
    case 2:
      return 2;
    case 3:
      return cmyk ? 3 : channelId + 1;
    case -1:
      return cmyk ? 4 : 3;
    default:
      return channelId + 1;
  }
}
function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
}
function hasAlpha(data3) {
  var size = data3.width * data3.height * 4;
  for (var i2 = 3; i2 < size; i2 += 4) {
    if (data3.data[i2] !== 255) {
      return true;
    }
  }
  return false;
}
function resetImageData(_a) {
  var data3 = _a.data;
  var alpha = data3 instanceof Float32Array ? 1 : data3 instanceof Uint16Array ? 65535 : 255;
  for (var p2 = 0, size = data3.length | 0; p2 < size; p2 = p2 + 4 | 0) {
    data3[p2 + 0] = 0;
    data3[p2 + 1] = 0;
    data3[p2 + 2] = 0;
    data3[p2 + 3] = alpha;
  }
}
function imageDataToCanvas(pixelData) {
  var canvas = createCanvas(pixelData.width, pixelData.height);
  var imageData;
  if (pixelData.data instanceof Uint8ClampedArray) {
    imageData = pixelData;
  } else {
    imageData = createImageData(pixelData.width, pixelData.height);
    var src = pixelData.data;
    var dst = imageData.data;
    if (src instanceof Float32Array) {
      for (var i2 = 0, size = src.length; i2 < size; i2 += 4) {
        dst[i2 + 0] = Math.round(Math.pow(src[i2 + 0], 1 / 2.2) * 255);
        dst[i2 + 1] = Math.round(Math.pow(src[i2 + 1], 1 / 2.2) * 255);
        dst[i2 + 2] = Math.round(Math.pow(src[i2 + 2], 1 / 2.2) * 255);
        dst[i2 + 3] = Math.round(src[i2 + 3] * 255);
      }
    } else {
      var shift = src instanceof Uint16Array ? 8 : 0;
      for (var i2 = 0, size = src.length; i2 < size; i2++) {
        dst[i2] = src[i2] >>> shift;
      }
    }
  }
  canvas.getContext("2d").putImageData(imageData, 0, 0);
  return canvas;
}
function writeDataRLE(buffer, _a, offsets, large) {
  var data3 = _a.data, width = _a.width, height = _a.height;
  if (!width || !height)
    return void 0;
  var stride = 4 * width | 0;
  var ol = 0;
  var o = offsets.length * (large ? 4 : 2) * height | 0;
  for (var _i = 0, offsets_1 = offsets; _i < offsets_1.length; _i++) {
    var offset = offsets_1[_i];
    for (var y2 = 0, p2 = offset | 0; y2 < height; y2++) {
      var strideStart = y2 * stride | 0;
      var strideEnd = strideStart + stride | 0;
      var lastIndex = strideEnd + offset - 4 | 0;
      var lastIndex2 = lastIndex - 4 | 0;
      var startOffset = o;
      for (p2 = strideStart + offset | 0; p2 < strideEnd; p2 = p2 + 4 | 0) {
        if (p2 < lastIndex2) {
          var value1 = data3[p2];
          p2 = p2 + 4 | 0;
          var value2 = data3[p2];
          p2 = p2 + 4 | 0;
          var value3 = data3[p2];
          if (value1 === value2 && value1 === value3) {
            var count = 3;
            while (count < 128 && p2 < lastIndex && data3[p2 + 4 | 0] === value1) {
              count = count + 1 | 0;
              p2 = p2 + 4 | 0;
            }
            buffer[o++] = 1 - count;
            buffer[o++] = value1;
          } else {
            var countIndex = o;
            var writeLast = true;
            var count = 1;
            buffer[o++] = 0;
            buffer[o++] = value1;
            while (p2 < lastIndex && count < 128) {
              p2 = p2 + 4 | 0;
              value1 = value2;
              value2 = value3;
              value3 = data3[p2];
              if (value1 === value2 && value1 === value3) {
                p2 = p2 - 12 | 0;
                writeLast = false;
                break;
              } else {
                count++;
                buffer[o++] = value1;
              }
            }
            if (writeLast) {
              if (count < 127) {
                buffer[o++] = value2;
                buffer[o++] = value3;
                count += 2;
              } else if (count < 128) {
                buffer[o++] = value2;
                count++;
                p2 = p2 - 4 | 0;
              } else {
                p2 = p2 - 8 | 0;
              }
            }
            buffer[countIndex] = count - 1;
          }
        } else if (p2 === lastIndex) {
          buffer[o++] = 0;
          buffer[o++] = data3[p2];
        } else {
          buffer[o++] = 1;
          buffer[o++] = data3[p2];
          p2 = p2 + 4 | 0;
          buffer[o++] = data3[p2];
        }
      }
      var length_1 = o - startOffset;
      if (large) {
        buffer[ol++] = length_1 >> 24 & 255;
        buffer[ol++] = length_1 >> 16 & 255;
      }
      buffer[ol++] = length_1 >> 8 & 255;
      buffer[ol++] = length_1 & 255;
    }
  }
  return buffer.slice(0, o);
}
function writeDataZipWithoutPrediction(_a, offsets) {
  var data3 = _a.data, width = _a.width, height = _a.height;
  var size = width * height;
  var channel = new Uint8Array(size);
  var buffers = [];
  var totalLength = 0;
  for (var _i = 0, offsets_2 = offsets; _i < offsets_2.length; _i++) {
    var offset = offsets_2[_i];
    for (var i2 = 0, o = offset; i2 < size; i2++, o += 4) {
      channel[i2] = data3[o];
    }
    var buffer = deflate_1(channel);
    buffers.push(buffer);
    totalLength += buffer.byteLength;
  }
  if (buffers.length > 0) {
    var buffer = new Uint8Array(totalLength);
    var offset = 0;
    for (var _b = 0, buffers_1 = buffers; _b < buffers_1.length; _b++) {
      var b2 = buffers_1[_b];
      buffer.set(b2, offset);
      offset += b2.byteLength;
    }
    return buffer;
  } else {
    return buffers[0];
  }
}
function createCanvasFromData(data3) {
  var canvas = createCanvas(100, 100);
  try {
    var context_1 = canvas.getContext("2d");
    var imageData = decodeJpeg(data3, function(w2, h2) {
      return context_1.createImageData(w2, h2);
    });
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    context_1.putImageData(imageData, 0, 0);
  } catch (e) {
    console.error("JPEG decompression error", e.message);
  }
  return canvas;
}
var createCanvas = function() {
  throw new Error("Canvas not initialized, use initializeCanvas method to set up createCanvas method");
};
var tempCanvas = void 0;
var createImageData = function(width, height) {
  if (!tempCanvas)
    tempCanvas = createCanvas(1, 1);
  return tempCanvas.getContext("2d").createImageData(width, height);
};
if (typeof document !== "undefined") {
  createCanvas = function(width, height) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  };
}
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code2.length; i2 < len; ++i2) {
    lookup[i2] = code2[i2];
    revLookup[code2.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i3;
    for (i3 = 0; i3 < len2; i3 += 4) {
      tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i3 = start; i3 < end; i3 += 3) {
      tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var base64JsExports = requireBase64Js();
function charLengthInBytes(code2) {
  if ((code2 & 4294967168) === 0) {
    return 1;
  } else if ((code2 & 4294965248) === 0) {
    return 2;
  } else if ((code2 & 4294901760) === 0) {
    return 3;
  } else {
    return 4;
  }
}
function stringLengthInBytes(value) {
  var result = 0;
  for (var i2 = 0; i2 < value.length; i2++) {
    var code2 = value.charCodeAt(i2);
    if (code2 >= 55296 && code2 <= 56319) {
      if (i2 + 1 < value.length) {
        var extra = value.charCodeAt(i2 + 1);
        if ((extra & 64512) === 56320) {
          i2++;
          result += charLengthInBytes(((code2 & 1023) << 10) + (extra & 1023) + 65536);
        }
      }
    } else {
      result += charLengthInBytes(code2);
    }
  }
  return result;
}
function writeCharacter(buffer, offset, code2) {
  var length = charLengthInBytes(code2);
  switch (length) {
    case 1:
      buffer[offset] = code2;
      break;
    case 2:
      buffer[offset] = code2 >> 6 & 31 | 192;
      buffer[offset + 1] = code2 & 63 | 128;
      break;
    case 3:
      buffer[offset] = code2 >> 12 & 15 | 224;
      buffer[offset + 1] = code2 >> 6 & 63 | 128;
      buffer[offset + 2] = code2 & 63 | 128;
      break;
    default:
      buffer[offset] = code2 >> 18 & 7 | 240;
      buffer[offset + 1] = code2 >> 12 & 63 | 128;
      buffer[offset + 2] = code2 >> 6 & 63 | 128;
      buffer[offset + 3] = code2 & 63 | 128;
      break;
  }
  return length;
}
function encodeStringTo(buffer, offset, value) {
  for (var i2 = 0; i2 < value.length; i2++) {
    var code2 = value.charCodeAt(i2);
    if (code2 >= 55296 && code2 <= 56319) {
      if (i2 + 1 < value.length) {
        var extra = value.charCodeAt(i2 + 1);
        if ((extra & 64512) === 56320) {
          i2++;
          var fullCode = ((code2 & 1023) << 10) + (extra & 1023) + 65536;
          offset += writeCharacter(buffer, offset, fullCode);
        }
      }
    } else {
      offset += writeCharacter(buffer, offset, code2);
    }
  }
  return offset;
}
function encodeString(value) {
  if (value.length > 1e3 && typeof TextEncoder !== "undefined") {
    return new TextEncoder().encode(value);
  }
  var buffer = new Uint8Array(stringLengthInBytes(value));
  encodeStringTo(buffer, 0, value);
  return buffer;
}
function continuationByte(buffer, index) {
  if (index >= buffer.length) {
    throw Error("Invalid byte index");
  }
  var continuationByte2 = buffer[index];
  if ((continuationByte2 & 192) === 128) {
    return continuationByte2 & 63;
  } else {
    throw Error("Invalid continuation byte");
  }
}
function decodeString(value) {
  if (value.byteLength > 1e3 && typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(value);
  }
  var result = [];
  for (var i2 = 0; i2 < value.length; ) {
    var byte1 = value[i2++];
    var code2 = void 0;
    if ((byte1 & 128) === 0) {
      code2 = byte1;
    } else if ((byte1 & 224) === 192) {
      var byte2 = continuationByte(value, i2++);
      code2 = (byte1 & 31) << 6 | byte2;
      if (code2 < 128) {
        throw Error("Invalid continuation byte");
      }
    } else if ((byte1 & 240) === 224) {
      var byte2 = continuationByte(value, i2++);
      var byte3 = continuationByte(value, i2++);
      code2 = (byte1 & 15) << 12 | byte2 << 6 | byte3;
      if (code2 < 2048) {
        throw Error("Invalid continuation byte");
      }
      if (code2 >= 55296 && code2 <= 57343) {
        throw Error("Lone surrogate U+".concat(code2.toString(16).toUpperCase(), " is not a scalar value"));
      }
    } else if ((byte1 & 248) === 240) {
      var byte2 = continuationByte(value, i2++);
      var byte3 = continuationByte(value, i2++);
      var byte4 = continuationByte(value, i2++);
      code2 = (byte1 & 15) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (code2 < 65536 || code2 > 1114111) {
        throw Error("Invalid continuation byte");
      }
    } else {
      throw Error("Invalid UTF-8 detected");
    }
    if (code2 > 65535) {
      code2 -= 65536;
      result.push(String.fromCharCode(code2 >>> 10 & 1023 | 55296));
      code2 = 56320 | code2 & 1023;
    }
    result.push(String.fromCharCode(code2));
  }
  return result.join("");
}
var __assign$6 = function() {
  __assign$6 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$6.apply(this, arguments);
};
var __rest = function(s2, e) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function revMap(map) {
  var result = {};
  Object.keys(map).forEach(function(key) {
    return result[map[key]] = key;
  });
  return result;
}
var unitsMap = {
  "#Ang": "Angle",
  "#Rsl": "Density",
  "#Rlt": "Distance",
  "#Nne": "None",
  "#Prc": "Percent",
  "#Pxl": "Pixels",
  "#Mlm": "Millimeters",
  "#Pnt": "Points",
  "RrPi": "Picas",
  "RrIn": "Inches",
  "RrCm": "Centimeters"
};
var unitsMapRev = revMap(unitsMap);
function makeType(name, classID) {
  return { name, classID };
}
var nullType = makeType("", "null");
var fieldToExtType = {
  strokeStyleContent: makeType("", "solidColorLayer"),
  printProofSetup: makeType("Proof Setup", "proofSetup"),
  Grad: makeType("Gradient", "Grdn"),
  Trnf: makeType("Transform", "Trnf"),
  patternFill: makeType("", "patternFill"),
  ebbl: makeType("", "ebbl"),
  SoFi: makeType("", "SoFi"),
  GrFl: makeType("", "GrFl"),
  sdwC: makeType("", "RGBC"),
  hglC: makeType("", "RGBC"),
  "Clr ": makeType("", "RGBC"),
  "tintColor": makeType("", "RGBC"),
  Ofst: makeType("", "Pnt "),
  ChFX: makeType("", "ChFX"),
  MpgS: makeType("", "ShpC"),
  DrSh: makeType("", "DrSh"),
  IrSh: makeType("", "IrSh"),
  OrGl: makeType("", "OrGl"),
  IrGl: makeType("", "IrGl"),
  TrnS: makeType("", "ShpC"),
  Ptrn: makeType("", "Ptrn"),
  FrFX: makeType("", "FrFX"),
  phase: makeType("", "Pnt "),
  frameStep: nullType,
  duration: nullType,
  workInTime: nullType,
  workOutTime: nullType,
  audioClipGroupList: nullType,
  bounds: makeType("", "Rctn"),
  customEnvelopeWarp: makeType("", "customEnvelopeWarp"),
  warp: makeType("", "warp"),
  "Sz  ": makeType("", "Pnt "),
  origin: makeType("", "Pnt "),
  autoExpandOffset: makeType("", "Pnt "),
  keyOriginShapeBBox: makeType("", "unitRect"),
  Vrsn: nullType,
  psVersion: nullType,
  docDefaultNewArtboardBackgroundColor: makeType("", "RGBC"),
  artboardRect: makeType("", "classFloatRect"),
  keyOriginRRectRadii: makeType("", "radii"),
  keyOriginBoxCorners: nullType,
  rectangleCornerA: makeType("", "Pnt "),
  rectangleCornerB: makeType("", "Pnt "),
  rectangleCornerC: makeType("", "Pnt "),
  rectangleCornerD: makeType("", "Pnt "),
  compInfo: nullType,
  quiltWarp: makeType("", "quiltWarp"),
  generatorSettings: nullType,
  crema: nullType,
  FrIn: nullType,
  blendOptions: nullType,
  FXRf: nullType,
  Lefx: nullType,
  time: nullType,
  animKey: nullType,
  timeScope: nullType,
  inTime: nullType,
  outTime: nullType,
  sheetStyle: nullType,
  translation: nullType,
  Skew: nullType,
  boundingBox: makeType("", "boundingBox"),
  "Lnk ": makeType("", "ExternalFileLink"),
  frameReader: makeType("", "FrameReader"),
  effectParams: makeType("", "motionTrackEffectParams"),
  Impr: makeType("None", "none"),
  Anch: makeType("", "Pnt "),
  "Fwd ": makeType("", "Pnt "),
  "Bwd ": makeType("", "Pnt "),
  FlrC: makeType("", "Pnt "),
  meshBoundaryPath: makeType("", "pathClass"),
  filterFX: makeType("", "filterFXStyle"),
  Fltr: makeType("", "rigidTransform"),
  FrgC: makeType("", "RGBC"),
  BckC: makeType("", "RGBC"),
  sdwM: makeType("Parameters", "adaptCorrectTones"),
  hglM: makeType("Parameters", "adaptCorrectTones"),
  customShape: makeType("", "customShape"),
  origFXRefPoint: nullType,
  FXRefPoint: nullType,
  ClMg: makeType("", "ClMg")
};
var fieldToArrayExtType = {
  "Crv ": makeType("", "CrPt"),
  Clrs: makeType("", "Clrt"),
  Trns: makeType("", "TrnS"),
  keyDescriptorList: nullType,
  solidFillMulti: makeType("", "SoFi"),
  gradientFillMulti: makeType("", "GrFl"),
  dropShadowMulti: makeType("", "DrSh"),
  innerShadowMulti: makeType("", "IrSh"),
  frameFXMulti: makeType("", "FrFX"),
  FrIn: nullType,
  FSts: nullType,
  LaSt: nullType,
  sheetTimelineOptions: nullType,
  trackList: makeType("", "animationTrack"),
  globalTrackList: makeType("", "animationTrack"),
  keyList: nullType,
  audioClipGroupList: nullType,
  audioClipList: nullType,
  countObjectList: makeType("", "countObject"),
  countGroupList: makeType("", "countGroup"),
  slices: makeType("", "slice"),
  "Pts ": makeType("", "Pthp"),
  SbpL: makeType("", "SbpL"),
  pathComponents: makeType("", "PaCm"),
  filterFXList: makeType("", "filterFX"),
  puppetShapeList: makeType("", "puppetShape"),
  channelDenoise: makeType("", "channelDenoiseParams"),
  ShrP: makeType("", "Pnt "),
  layerSettings: nullType,
  list: nullType,
  Adjs: makeType("", "CrvA")
};
var typeToField = {
  "TEXT": [
    "Txt ",
    "printerName",
    "Nm  ",
    "Idnt",
    "blackAndWhitePresetFileName",
    "LUT3DFileName",
    "presetFileName",
    "curvesPresetFileName",
    "mixerPresetFileName",
    "placed",
    "description",
    "reason",
    "artboardPresetName",
    "json",
    "clipID",
    "relPath",
    "fullPath",
    "mediaDescriptor",
    "Msge",
    "altTag",
    "url",
    "cellText",
    "preset",
    "KnNm",
    "FPth",
    "comment",
    "originalPath"
  ],
  "tdta": [
    "EngineData",
    "LUT3DFileData",
    "indexArray",
    "originalVertexArray",
    "deformedVertexArray",
    "LqMe"
  ],
  "long": [
    "TextIndex",
    "RndS",
    "Mdpn",
    "Smth",
    "Lctn",
    "strokeStyleVersion",
    "LaID",
    "Vrsn",
    "Cnt ",
    "Brgh",
    "Cntr",
    "means",
    "vibrance",
    "Strt",
    "bwPresetKind",
    "comp",
    "compID",
    "originalCompID",
    "curvesPresetKind",
    "mixerPresetKind",
    "uOrder",
    "vOrder",
    "PgNm",
    "totalPages",
    "Crop",
    "numerator",
    "denominator",
    "frameCount",
    "Annt",
    "keyOriginType",
    "unitValueQuadVersion",
    "keyOriginIndex",
    "major",
    "minor",
    "fix",
    "docDefaultNewArtboardBackgroundType",
    "artboardBackgroundType",
    "numModifyingFX",
    "deformNumRows",
    "deformNumCols",
    "FrID",
    "FrDl",
    "FsID",
    "LCnt",
    "AFrm",
    "AFSt",
    "numBefore",
    "numAfter",
    "Spcn",
    "minOpacity",
    "maxOpacity",
    "BlnM",
    "sheetID",
    "gblA",
    "globalAltitude",
    "descVersion",
    "frameReaderType",
    "LyrI",
    "zoomOrigin",
    "fontSize",
    "Rds ",
    "sliceID",
    "topOutset",
    "leftOutset",
    "bottomOutset",
    "rightOutset",
    "filterID",
    "meshQuality",
    "meshExpansion",
    "meshRigidity",
    "VrsM",
    "VrsN",
    "NmbG",
    "WLMn",
    "WLMx",
    "AmMn",
    "AmMx",
    "SclH",
    "SclV",
    "Lvl ",
    "TlNm",
    "TlOf",
    "FlRs",
    "Thsh",
    "ShrS",
    "ShrE",
    "FlRs",
    "Vrnc",
    "Strg",
    "ExtS",
    "ExtD",
    "HrzS",
    "VrtS",
    "NmbR",
    "EdgF",
    "Ang1",
    "Ang2",
    "Ang3",
    "Ang4",
    "lastAppliedComp",
    "capturedInfo"
  ],
  "enum": [
    "textGridding",
    "Ornt",
    "warpStyle",
    "warpRotate",
    "Inte",
    "Bltn",
    "ClrS",
    "BlrQ",
    "bvlT",
    "bvlS",
    "bvlD",
    "Md  ",
    "glwS",
    "GrdF",
    "GlwT",
    "RplS",
    "BlrM",
    "SmBM",
    "strokeStyleLineCapType",
    "strokeStyleLineJoinType",
    "strokeStyleLineAlignment",
    "strokeStyleBlendMode",
    "PntT",
    "Styl",
    "lookupType",
    "LUTFormat",
    "dataOrder",
    "tableOrder",
    "enableCompCore",
    "enableCompCoreGPU",
    "compCoreSupport",
    "compCoreGPUSupport",
    "Engn",
    "enableCompCoreThreads",
    "gs99",
    "FrDs",
    "trackID",
    "animInterpStyle",
    "horzAlign",
    "vertAlign",
    "bgColorType",
    "shapeOperation",
    "UndA",
    "Wvtp",
    "Drct",
    "WndM",
    "Edg ",
    "FlCl",
    "IntE",
    "IntC",
    "Cnvr",
    "Fl  ",
    "Dstr",
    "MztT",
    "Lns ",
    "ExtT",
    "DspM",
    "ExtR",
    "ZZTy",
    "SphM",
    "SmBQ",
    "placedLayerOCIOConversion",
    "gradientsInterpolationMethod"
  ],
  "bool": [
    "PstS",
    "printSixteenBit",
    "masterFXSwitch",
    "enab",
    "uglg",
    "antialiasGloss",
    "useShape",
    "useTexture",
    "uglg",
    "antialiasGloss",
    "useShape",
    "Vsbl",
    "useTexture",
    "Algn",
    "Rvrs",
    "Dthr",
    "Invr",
    "VctC",
    "ShTr",
    "layerConceals",
    "strokeEnabled",
    "fillEnabled",
    "strokeStyleScaleLock",
    "strokeStyleStrokeAdjust",
    "hardProof",
    "MpBl",
    "paperWhite",
    "useLegacy",
    "Auto",
    "Lab ",
    "useTint",
    "keyShapeInvalidated",
    "autoExpandEnabled",
    "autoNestEnabled",
    "autoPositionEnabled",
    "shrinkwrapOnSaveEnabled",
    "present",
    "showInDialog",
    "overprint",
    "sheetDisclosed",
    "lightsDisclosed",
    "meshesDisclosed",
    "materialsDisclosed",
    "hasMotion",
    "muted",
    "Effc",
    "selected",
    "autoScope",
    "fillCanvas",
    "cellTextIsHTML",
    "Smoo",
    "Clsp",
    "validAtPosition",
    "rigidType",
    "hasoptions",
    "filterMaskEnable",
    "filterMaskLinked",
    "filterMaskExtendWithWhite",
    "removeJPEGArtifact",
    "Mnch",
    "ExtF",
    "ExtM",
    "moreAccurate",
    "GpuY",
    "LIWy",
    "Cnty"
  ],
  "doub": [
    "warpValue",
    "warpPerspective",
    "warpPerspectiveOther",
    "Intr",
    "Wdth",
    "Hght",
    "strokeStyleMiterLimit",
    "strokeStyleResolution",
    "layerTime",
    "keyOriginResolution",
    "xx",
    "xy",
    "yx",
    "yy",
    "tx",
    "ty",
    "FrGA",
    "frameRate",
    "audioLevel",
    "rotation",
    "X   ",
    "Y   ",
    "redFloat",
    "greenFloat",
    "blueFloat",
    "imageResolution",
    "PuX0",
    "PuX1",
    "PuX2",
    "PuX3",
    "PuY0",
    "PuY1",
    "PuY2",
    "PuY3"
  ],
  "UntF": [
    "sdwO",
    "hglO",
    "lagl",
    "Lald",
    "srgR",
    "blur",
    "Sftn",
    "Opct",
    "Dstn",
    "Angl",
    "Ckmt",
    "Nose",
    "Inpr",
    "ShdN",
    "strokeStyleLineWidth",
    "strokeStyleLineDashOffset",
    "strokeStyleOpacity",
    "H   ",
    "Top ",
    "Left",
    "Btom",
    "Rght",
    "Rslt",
    "topRight",
    "topLeft",
    "bottomLeft",
    "bottomRight",
    "ClNs",
    "Shrp"
  ],
  "VlLs": [
    "Crv ",
    "Clrs",
    "Mnm ",
    "Mxm ",
    "Trns",
    "pathList",
    "strokeStyleLineDashSet",
    "FrLs",
    "slices",
    "LaSt",
    "Trnf",
    "nonAffineTransform",
    "keyDescriptorList",
    "guideIndeces",
    "gradientFillMulti",
    "solidFillMulti",
    "frameFXMulti",
    "innerShadowMulti",
    "dropShadowMulti",
    "FrIn",
    "FSts",
    "FsFr",
    "sheetTimelineOptions",
    "audioClipList",
    "trackList",
    "globalTrackList",
    "keyList",
    "audioClipList",
    "warpValues",
    "selectedPin",
    "Pts ",
    "SbpL",
    "pathComponents",
    "pinOffsets",
    "posFinalPins",
    "pinVertexIndices",
    "PinP",
    "PnRt",
    "PnOv",
    "PnDp",
    "filterFXList",
    "puppetShapeList",
    "ShrP",
    "channelDenoise",
    "Mtrx",
    "layerSettings",
    "list",
    "compList",
    "Adjs"
  ],
  "ObAr": ["meshPoints", "quiltSliceX", "quiltSliceY"],
  "obj ": ["null", "Chnl"],
  "Pth ": ["DspF"]
};
var channels = [
  "Rd  ",
  "Grn ",
  "Bl  ",
  "Yllw",
  "Ylw ",
  "Cyn ",
  "Mgnt",
  "Blck",
  "Gry ",
  "Lmnc",
  "A   ",
  "B   "
];
var fieldToArrayType = {
  "Mnm ": "long",
  "Mxm ": "long",
  FrLs: "long",
  strokeStyleLineDashSet: "UntF",
  Trnf: "doub",
  nonAffineTransform: "doub",
  keyDescriptorList: "Objc",
  gradientFillMulti: "Objc",
  solidFillMulti: "Objc",
  frameFXMulti: "Objc",
  innerShadowMulti: "Objc",
  dropShadowMulti: "Objc",
  LaSt: "Objc",
  FrIn: "Objc",
  FSts: "Objc",
  FsFr: "long",
  blendOptions: "Objc",
  sheetTimelineOptions: "Objc",
  keyList: "Objc",
  warpValues: "doub",
  selectedPin: "long",
  "Pts ": "Objc",
  SbpL: "Objc",
  pathComponents: "Objc",
  pinOffsets: "doub",
  posFinalPins: "doub",
  pinVertexIndices: "long",
  PinP: "doub",
  PnRt: "long",
  PnOv: "bool",
  PnDp: "doub",
  filterFXList: "Objc",
  puppetShapeList: "Objc",
  ShrP: "Objc",
  channelDenoise: "Objc",
  Mtrx: "long",
  compList: "long",
  Chnl: "enum"
};
var fieldToType = {};
for (var _i = 0, _a = Object.keys(typeToField); _i < _a.length; _i++) {
  var type = _a[_i];
  for (var _b = 0, _c = typeToField[type]; _b < _c.length; _b++) {
    var field = _c[_b];
    fieldToType[field] = type;
  }
}
for (var _d = 0, _e = Object.keys(fieldToExtType); _d < _e.length; _d++) {
  var field = _e[_d];
  if (!fieldToType[field])
    fieldToType[field] = "Objc";
}
for (var _f = 0, _g = Object.keys(fieldToArrayExtType); _f < _g.length; _f++) {
  var field = _g[_f];
  fieldToArrayType[field] = "Objc";
}
function getTypeByKey(key, value, root4, parent) {
  if (key === "presetKind") {
    return typeof value === "string" ? "enum" : "long";
  }
  if (key === "null" && root4 === "slices") {
    return "TEXT";
  } else if (key === "groupID") {
    return root4 === "slices" ? "long" : "TEXT";
  } else if (key === "Sz  ") {
    return "Wdth" in value ? "Objc" : "units" in value ? "UntF" : "doub";
  } else if (key === "Type") {
    return typeof value === "string" ? "enum" : "long";
  } else if (key === "AntA") {
    return typeof value === "string" ? "enum" : "bool";
  } else if ((key === "Hrzn" || key === "Vrtc") && (parent.Type === "keyType.Pstn" || parent._classID === "Ofst")) {
    return "long";
  } else if (key === "Hrzn" || key === "Vrtc" || key === "Top " || key === "Left" || key === "Btom" || key === "Rght") {
    if (root4 === "slices")
      return "long";
    return typeof value === "number" ? "doub" : "UntF";
  } else if (key === "Vrsn") {
    return typeof value === "number" ? "long" : "Objc";
  } else if (key === "Rd  " || key === "Grn " || key === "Bl  ") {
    return root4 === "artd" ? "long" : "doub";
  } else if (key === "Trnf") {
    return Array.isArray(value) ? "VlLs" : "Objc";
  } else {
    return fieldToType[key];
  }
}
function readAsciiStringOrClassId(reader) {
  var length = readInt32(reader);
  return readAsciiString(reader, length || 4);
}
function writeAsciiStringOrClassId(writer, value) {
  if (value.length === 4 && value !== "warp" && value !== "time" && value !== "hold" && value !== "list") {
    writeInt32(writer, 0);
    writeSignature(writer, value);
  } else {
    writeInt32(writer, value.length);
    for (var i2 = 0; i2 < value.length; i2++) {
      writeUint8(writer, value.charCodeAt(i2));
    }
  }
}
function readDescriptorStructure(reader, includeClass) {
  var struct = readClassStructure(reader);
  var object = includeClass ? { _name: struct.name, _classID: struct.classID } : {};
  var itemsCount = readUint32(reader);
  for (var i2 = 0; i2 < itemsCount; i2++) {
    var key = readAsciiStringOrClassId(reader);
    var type = readSignature(reader);
    var data3 = readOSType(reader, type, includeClass);
    object[key] = data3;
  }
  return object;
}
function writeDescriptorStructure(writer, name, classId, value, root4) {
  writeUnicodeStringWithPadding(writer, name);
  writeAsciiStringOrClassId(writer, classId);
  var keys = Object.keys(value);
  var keyCount = keys.length;
  if ("_name" in value)
    keyCount--;
  if ("_classID" in value)
    keyCount--;
  writeUint32(writer, keyCount);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (key === "_name" || key === "_classID")
      continue;
    var type = getTypeByKey(key, value[key], root4, value);
    var extType = fieldToExtType[key];
    if (key === "bounds" && root4 === "text") {
      extType = makeType("", "bounds");
    } else if (key === "origin") {
      type = root4 === "slices" ? "enum" : "Objc";
    } else if ((key === "Cyn " || key === "Mgnt" || key === "Ylw " || key === "Blck") && value._classID === "CMYC") {
      type = "doub";
    } else if (/^PN[a-z][a-z]$/.test(key)) {
      type = "TEXT";
    } else if (/^PT[a-z][a-z]$/.test(key)) {
      type = "long";
    } else if (/^PF[a-z][a-z]$/.test(key)) {
      type = "doub";
    } else if ((key === "Rds " || key === "Thsh") && typeof value[key] === "number" && value._classID === "SmrB") {
      type = "doub";
    } else if (key === "ClSz" || key === "Rds " || key === "Amnt") {
      type = typeof value[key] === "number" ? "long" : "UntF";
    } else if ((key === "sdwM" || key === "hglM") && typeof value[key] === "string") {
      type = "enum";
    } else if (key === "blur" && typeof value[key] === "string") {
      type = "enum";
    } else if (key === "Hght" && typeof value[key] === "number" && value._classID === "Embs") {
      type = "long";
    } else if (key === "Angl" && typeof value[key] === "number" && (value._classID === "Embs" || value._classID === "smartSharpen" || value._classID === "Twrl" || value._classID === "MtnB")) {
      type = "long";
    } else if (key === "Angl" && typeof value[key] === "number") {
      type = "doub";
    } else if (key === "bounds" && root4 === "slices") {
      type = "Objc";
      extType = makeType("", "Rct1");
    } else if (key === "Scl ") {
      if (typeof value[key] === "object" && "Hrzn" in value[key]) {
        type = "Objc";
        extType = nullType;
      } else if (typeof value[key] === "number") {
        type = "long";
      } else {
        type = "UntF";
      }
    } else if (key === "audioClipGroupList" && keys.length === 1) {
      type = "VlLs";
    } else if ((key === "Strt" || key === "Brgh") && "H   " in value) {
      type = "doub";
    } else if (key === "Wdth" && typeof value[key] === "object") {
      type = "UntF";
    } else if (key === "Ofst" && typeof value[key] === "number") {
      type = "long";
    } else if (key === "Strt" && typeof value[key] === "object") {
      type = "Objc";
      extType = nullType;
    } else if (channels.indexOf(key) !== -1) {
      type = classId === "RGBC" && root4 !== "artd" ? "doub" : "long";
    } else if (key === "profile") {
      type = classId === "printOutput" ? "TEXT" : "tdta";
    } else if (key === "strokeStyleContent") {
      if (value[key]["Clr "]) {
        extType = makeType("", "solidColorLayer");
      } else if (value[key].Grad) {
        extType = makeType("", "gradientLayer");
      } else if (value[key].Ptrn) {
        extType = makeType("", "patternLayer");
      } else ;
    } else if (key === "bounds" && root4 === "quiltWarp") {
      extType = makeType("", "classFloatRect");
    }
    if (extType && extType.classID === "RGBC") {
      if ("H   " in value[key])
        extType = { classID: "HSBC", name: "" };
    }
    writeAsciiStringOrClassId(writer, key);
    writeSignature(writer, type || "long");
    writeOSType(writer, type || "long", value[key], key, extType, root4);
  }
}
function readOSType(reader, type, includeClass) {
  switch (type) {
    case "obj ":
      return readReferenceStructure(reader);
    case "Objc":
    // Descriptor
    case "GlbO":
      return readDescriptorStructure(reader, includeClass);
    case "VlLs": {
      var length_1 = readInt32(reader);
      var items = [];
      for (var i2 = 0; i2 < length_1; i2++) {
        var itemType = readSignature(reader);
        items.push(readOSType(reader, itemType, includeClass));
      }
      return items;
    }
    case "doub":
      return readFloat64(reader);
    case "UntF": {
      var units = readSignature(reader);
      var value = readFloat64(reader);
      if (!unitsMap[units])
        throw new Error("Invalid units: ".concat(units));
      return { units: unitsMap[units], value };
    }
    case "UnFl": {
      var units = readSignature(reader);
      var value = readFloat32(reader);
      if (!unitsMap[units])
        throw new Error("Invalid units: ".concat(units));
      return { units: unitsMap[units], value };
    }
    case "TEXT":
      return readUnicodeString(reader);
    case "enum": {
      var enumType = readAsciiStringOrClassId(reader);
      var value = readAsciiStringOrClassId(reader);
      return "".concat(enumType, ".").concat(value);
    }
    case "long":
      return readInt32(reader);
    case "comp": {
      var low = readUint32(reader);
      var high = readUint32(reader);
      return { low, high };
    }
    case "bool":
      return !!readUint8(reader);
    case "type":
    // Class
    case "GlbC":
      return readClassStructure(reader);
    case "alis": {
      var length_2 = readInt32(reader);
      return readAsciiString(reader, length_2);
    }
    case "tdta": {
      var length_3 = readInt32(reader);
      return readBytes(reader, length_3);
    }
    case "ObAr": {
      readInt32(reader);
      readUnicodeString(reader);
      readAsciiStringOrClassId(reader);
      var length_4 = readInt32(reader);
      var items = [];
      for (var i2 = 0; i2 < length_4; i2++) {
        var type1 = readAsciiStringOrClassId(reader);
        readSignature(reader);
        readSignature(reader);
        var valuesCount = readInt32(reader);
        var values = [];
        for (var j = 0; j < valuesCount; j++) {
          values.push(readFloat64(reader));
        }
        items.push({ type: type1, values });
      }
      return items;
    }
    case "Pth ": {
      readInt32(reader);
      var sig = readSignature(reader);
      readInt32LE(reader);
      var charsCount = readInt32LE(reader);
      var path = readUnicodeStringWithLengthLE(reader, charsCount);
      return { sig, path };
    }
    default:
      throw new Error("Invalid TySh descriptor OSType: ".concat(type, " at ").concat(reader.offset.toString(16)));
  }
}
var ObArTypes = {
  meshPoints: "rationalPoint",
  quiltSliceX: "UntF",
  quiltSliceY: "UntF"
};
function writeOSType(writer, type, value, key, extType, root4) {
  switch (type) {
    case "obj ":
      writeReferenceStructure(writer, key, value);
      break;
    case "Objc":
    // Descriptor
    case "GlbO": {
      if (typeof value !== "object")
        throw new Error("Invalid struct value: ".concat(JSON.stringify(value), ", key: ").concat(key));
      if (!extType)
        throw new Error("Missing ext type for: '".concat(key, "' (").concat(JSON.stringify(value), ")"));
      var name_1 = value._name || extType.name;
      var classID = value._classID || extType.classID;
      writeDescriptorStructure(writer, name_1, classID, value, root4);
      break;
    }
    case "VlLs":
      if (!Array.isArray(value))
        throw new Error("Invalid list value: ".concat(JSON.stringify(value), ", key: ").concat(key));
      writeInt32(writer, value.length);
      for (var i2 = 0; i2 < value.length; i2++) {
        var type_1 = fieldToArrayType[key];
        writeSignature(writer, type_1 || "long");
        writeOSType(writer, type_1 || "long", value[i2], "".concat(key, "[]"), fieldToArrayExtType[key], root4);
      }
      break;
    case "doub":
      if (typeof value !== "number")
        throw new Error("Invalid number value: ".concat(JSON.stringify(value), ", key: ").concat(key));
      writeFloat64(writer, value);
      break;
    case "UntF":
      if (!unitsMapRev[value.units])
        throw new Error("Invalid units: ".concat(value.units, " in ").concat(key));
      writeSignature(writer, unitsMapRev[value.units]);
      writeFloat64(writer, value.value);
      break;
    case "UnFl":
      if (!unitsMapRev[value.units])
        throw new Error("Invalid units: ".concat(value.units, " in ").concat(key));
      writeSignature(writer, unitsMapRev[value.units]);
      writeFloat32(writer, value.value);
      break;
    case "TEXT":
      writeUnicodeStringWithPadding(writer, value);
      break;
    case "enum": {
      if (typeof value !== "string")
        throw new Error("Invalid enum value: ".concat(JSON.stringify(value), ", key: ").concat(key));
      var _a = value.split("."), _type = _a[0], val = _a[1];
      writeAsciiStringOrClassId(writer, _type);
      writeAsciiStringOrClassId(writer, val);
      break;
    }
    case "long":
      if (typeof value !== "number")
        throw new Error("Invalid integer value: ".concat(JSON.stringify(value), ", key: ").concat(key));
      writeInt32(writer, value);
      break;
    // case 'comp': // Large Integer
    // 	writeLargeInteger(reader);
    case "bool":
      if (typeof value !== "boolean")
        throw new Error("Invalid boolean value: ".concat(JSON.stringify(value), ", key: ").concat(key));
      writeUint8(writer, value ? 1 : 0);
      break;
    // case 'type': // Class
    // case 'GlbC': // Class
    // 	writeClassStructure(reader);
    // case 'alis': // Alias
    // 	writeAliasStructure(reader);
    case "tdta":
      writeInt32(writer, value.byteLength);
      writeBytes(writer, value);
      break;
    case "ObAr": {
      writeInt32(writer, 16);
      writeUnicodeStringWithPadding(writer, "");
      var type_2 = ObArTypes[key];
      if (!type_2)
        throw new Error("Not implemented ObArType for: ".concat(key));
      writeAsciiStringOrClassId(writer, type_2);
      writeInt32(writer, value.length);
      for (var i2 = 0; i2 < value.length; i2++) {
        writeAsciiStringOrClassId(writer, value[i2].type);
        writeSignature(writer, "UnFl");
        writeSignature(writer, "#Pxl");
        writeInt32(writer, value[i2].values.length);
        for (var j = 0; j < value[i2].values.length; j++) {
          writeFloat64(writer, value[i2].values[j]);
        }
      }
      break;
    }
    case "Pth ": {
      var length_5 = 4 + 4 + 4 + value.path.length * 2;
      writeInt32(writer, length_5);
      writeSignature(writer, value.sig);
      writeInt32LE(writer, length_5);
      writeInt32LE(writer, value.path.length);
      writeUnicodeStringWithoutLengthLE(writer, value.path);
      break;
    }
    default:
      throw new Error("Not implemented descriptor OSType: ".concat(type));
  }
}
function readReferenceStructure(reader) {
  var itemsCount = readInt32(reader);
  var items = [];
  for (var i2 = 0; i2 < itemsCount; i2++) {
    var type = readSignature(reader);
    switch (type) {
      case "prop": {
        readClassStructure(reader);
        var keyID = readAsciiStringOrClassId(reader);
        items.push(keyID);
        break;
      }
      case "Clss":
        items.push(readClassStructure(reader));
        break;
      case "Enmr": {
        readClassStructure(reader);
        var typeID = readAsciiStringOrClassId(reader);
        var value = readAsciiStringOrClassId(reader);
        items.push("".concat(typeID, ".").concat(value));
        break;
      }
      case "rele": {
        readClassStructure(reader);
        items.push(readUint32(reader));
        break;
      }
      case "Idnt":
        items.push(readInt32(reader));
        break;
      case "indx":
        items.push(readInt32(reader));
        break;
      case "name": {
        readClassStructure(reader);
        items.push(readUnicodeString(reader));
        break;
      }
      default:
        throw new Error("Invalid descriptor reference type: ".concat(type));
    }
  }
  return items;
}
function writeReferenceStructure(writer, _key, items) {
  writeInt32(writer, items.length);
  for (var i2 = 0; i2 < items.length; i2++) {
    var value = items[i2];
    var type = "unknown";
    if (typeof value === "string") {
      if (/^[a-z ]+\.[a-z ]+$/i.test(value)) {
        type = "Enmr";
      } else {
        type = "name";
      }
    }
    writeSignature(writer, type);
    switch (type) {
      // case 'prop': // Property
      // case 'Clss': // Class
      case "Enmr": {
        var _a = value.split("."), typeID = _a[0], enumValue = _a[1];
        writeClassStructure(writer, "\0", typeID);
        writeAsciiStringOrClassId(writer, typeID);
        writeAsciiStringOrClassId(writer, enumValue);
        break;
      }
      // case 'rele': // Offset
      // case 'Idnt': // Identifier
      // case 'indx': // Index
      case "name": {
        writeClassStructure(writer, "\0", "Lyr ");
        writeUnicodeString(writer, value + "\0");
        break;
      }
      default:
        throw new Error("Invalid descriptor reference type: ".concat(type));
    }
  }
  return items;
}
function readClassStructure(reader) {
  var name = readUnicodeString(reader);
  var classID = readAsciiStringOrClassId(reader);
  return { name, classID };
}
function writeClassStructure(writer, name, classID) {
  writeUnicodeString(writer, name);
  writeAsciiStringOrClassId(writer, classID);
}
function readVersionAndDescriptor(reader, includeClass) {
  if (includeClass === void 0) {
    includeClass = false;
  }
  var version2 = readUint32(reader);
  if (version2 !== 16)
    throw new Error("Invalid descriptor version: ".concat(version2));
  var desc = readDescriptorStructure(reader, includeClass);
  return desc;
}
function writeVersionAndDescriptor(writer, name, classID, descriptor, root4) {
  if (root4 === void 0) {
    root4 = "";
  }
  writeUint32(writer, 16);
  writeDescriptorStructure(writer, name, classID, descriptor, root4);
}
function horzVrtcToXY(hv) {
  return { x: hv.Hrzn, y: hv.Vrtc };
}
function xyToHorzVrtc(xy) {
  return { Hrzn: xy.x, Vrtc: xy.y };
}
function descBoundsToBounds(desc) {
  return {
    top: parseUnits(desc["Top "]),
    left: parseUnits(desc.Left),
    right: parseUnits(desc.Rght),
    bottom: parseUnits(desc.Btom)
  };
}
function boundsToDescBounds(bounds) {
  var _a;
  return _a = {
    Left: unitsValue(bounds.left, "bounds.left")
  }, _a["Top "] = unitsValue(bounds.top, "bounds.top"), _a.Rght = unitsValue(bounds.right, "bounds.right"), _a.Btom = unitsValue(bounds.bottom, "bounds.bottom"), _a;
}
function parseFxObject(fx) {
  var stroke = {
    enabled: !!fx.enab,
    position: FStl.decode(fx.Styl),
    fillType: FrFl.decode(fx.PntT),
    blendMode: BlnM.decode(fx["Md  "]),
    opacity: parsePercent(fx.Opct),
    size: parseUnits(fx["Sz  "])
  };
  if (fx.present !== void 0)
    stroke.present = fx.present;
  if (fx.showInDialog !== void 0)
    stroke.showInDialog = fx.showInDialog;
  if (fx.overprint !== void 0)
    stroke.overprint = fx.overprint;
  if (fx["Clr "])
    stroke.color = parseColor(fx["Clr "]);
  if (fx.Grad)
    stroke.gradient = parseGradientContent(fx);
  if (fx.Ptrn)
    stroke.pattern = parsePatternContent(fx);
  return stroke;
}
function serializeFxObject(stroke) {
  var FrFX = {};
  FrFX.enab = !!stroke.enabled;
  if (stroke.present !== void 0)
    FrFX.present = !!stroke.present;
  if (stroke.showInDialog !== void 0)
    FrFX.showInDialog = !!stroke.showInDialog;
  FrFX.Styl = FStl.encode(stroke.position);
  FrFX.PntT = FrFl.encode(stroke.fillType);
  FrFX["Md  "] = BlnM.encode(stroke.blendMode);
  FrFX.Opct = unitsPercent(stroke.opacity);
  FrFX["Sz  "] = unitsValue(stroke.size, "size");
  if (stroke.color)
    FrFX["Clr "] = serializeColor(stroke.color);
  if (stroke.gradient)
    FrFX = __assign$6(__assign$6({}, FrFX), serializeGradientContent(stroke.gradient));
  if (stroke.pattern)
    FrFX = __assign$6(__assign$6({}, FrFX), serializePatternContent(stroke.pattern));
  if (stroke.overprint !== void 0)
    FrFX.overprint = !!stroke.overprint;
  return FrFX;
}
function serializeEffects(e, log, multi) {
  var _a, _b, _c;
  var info = multi ? {
    "Scl ": unitsPercentF((_a = e.scale) !== null && _a !== void 0 ? _a : 1),
    masterFXSwitch: !e.disabled
  } : {
    masterFXSwitch: !e.disabled,
    "Scl ": unitsPercentF((_b = e.scale) !== null && _b !== void 0 ? _b : 1)
  };
  var arrayKeys = ["dropShadow", "innerShadow", "solidFill", "gradientOverlay", "stroke"];
  for (var _i = 0, arrayKeys_1 = arrayKeys; _i < arrayKeys_1.length; _i++) {
    var key = arrayKeys_1[_i];
    if (e[key] && !Array.isArray(e[key]))
      throw new Error("".concat(key, " should be an array"));
  }
  var useMulti = function(arr) {
    return !!arr && arr.length > 1 && multi;
  };
  var useSingle = function(arr) {
    return !!arr && arr.length >= 1 && (!multi || arr.length === 1);
  };
  if (useSingle(e.dropShadow))
    info.DrSh = serializeEffectObject(e.dropShadow[0], "dropShadow", log);
  if (useMulti(e.dropShadow))
    info.dropShadowMulti = e.dropShadow.map(function(i2) {
      return serializeEffectObject(i2, "dropShadow", log);
    });
  if (useSingle(e.innerShadow))
    info.IrSh = serializeEffectObject(e.innerShadow[0], "innerShadow", log);
  if (useMulti(e.innerShadow))
    info.innerShadowMulti = e.innerShadow.map(function(i2) {
      return serializeEffectObject(i2, "innerShadow", log);
    });
  if (e.outerGlow)
    info.OrGl = serializeEffectObject(e.outerGlow, "outerGlow", log);
  if (useMulti(e.solidFill))
    info.solidFillMulti = e.solidFill.map(function(i2) {
      return serializeEffectObject(i2, "solidFill", log);
    });
  if (useMulti(e.gradientOverlay))
    info.gradientFillMulti = e.gradientOverlay.map(function(i2) {
      return serializeEffectObject(i2, "gradientOverlay", log);
    });
  if (useMulti(e.stroke))
    info.frameFXMulti = e.stroke.map(function(i2) {
      return serializeFxObject(i2);
    });
  if (e.innerGlow)
    info.IrGl = serializeEffectObject(e.innerGlow, "innerGlow", log);
  if (e.bevel)
    info.ebbl = serializeEffectObject(e.bevel, "bevel", log);
  if (useSingle(e.solidFill))
    info.SoFi = serializeEffectObject(e.solidFill[0], "solidFill", log);
  if (e.patternOverlay)
    info.patternFill = serializeEffectObject(e.patternOverlay, "patternOverlay", log);
  if (useSingle(e.gradientOverlay))
    info.GrFl = serializeEffectObject(e.gradientOverlay[0], "gradientOverlay", log);
  if (e.satin)
    info.ChFX = serializeEffectObject(e.satin, "satin", log);
  if (useSingle(e.stroke))
    info.FrFX = serializeFxObject((_c = e.stroke) === null || _c === void 0 ? void 0 : _c[0]);
  if (multi) {
    info.numModifyingFX = 0;
    for (var _d = 0, _e = Object.keys(e); _d < _e.length; _d++) {
      var key = _e[_d];
      var value = e[key];
      if (Array.isArray(value)) {
        for (var _f = 0, value_1 = value; _f < value_1.length; _f++) {
          var effect = value_1[_f];
          if (effect.enabled)
            info.numModifyingFX++;
        }
      } else if (value.enabled) {
        info.numModifyingFX++;
      }
    }
  }
  return info;
}
function parseEffects(info, log) {
  var effects = {};
  var masterFXSwitch = info.masterFXSwitch, DrSh = info.DrSh, dropShadowMulti = info.dropShadowMulti, IrSh = info.IrSh, innerShadowMulti = info.innerShadowMulti, OrGl = info.OrGl, IrGl = info.IrGl, ebbl = info.ebbl, SoFi = info.SoFi, solidFillMulti = info.solidFillMulti, patternFill = info.patternFill, GrFl = info.GrFl, gradientFillMulti = info.gradientFillMulti, ChFX = info.ChFX, FrFX = info.FrFX, frameFXMulti = info.frameFXMulti;
  info.numModifyingFX;
  var rest = __rest(info, ["masterFXSwitch", "DrSh", "dropShadowMulti", "IrSh", "innerShadowMulti", "OrGl", "IrGl", "ebbl", "SoFi", "solidFillMulti", "patternFill", "GrFl", "gradientFillMulti", "ChFX", "FrFX", "frameFXMulti", "numModifyingFX"]);
  if (!masterFXSwitch)
    effects.disabled = true;
  if (info["Scl "])
    effects.scale = parsePercent(info["Scl "]);
  if (DrSh)
    effects.dropShadow = [parseEffectObject(DrSh, log)];
  if (dropShadowMulti)
    effects.dropShadow = dropShadowMulti.map(function(i2) {
      return parseEffectObject(i2, log);
    });
  if (IrSh)
    effects.innerShadow = [parseEffectObject(IrSh, log)];
  if (innerShadowMulti)
    effects.innerShadow = innerShadowMulti.map(function(i2) {
      return parseEffectObject(i2, log);
    });
  if (OrGl)
    effects.outerGlow = parseEffectObject(OrGl, log);
  if (IrGl)
    effects.innerGlow = parseEffectObject(IrGl, log);
  if (ebbl)
    effects.bevel = parseEffectObject(ebbl, log);
  if (SoFi)
    effects.solidFill = [parseEffectObject(SoFi, log)];
  if (solidFillMulti)
    effects.solidFill = solidFillMulti.map(function(i2) {
      return parseEffectObject(i2, log);
    });
  if (patternFill)
    effects.patternOverlay = parseEffectObject(patternFill, log);
  if (GrFl)
    effects.gradientOverlay = [parseEffectObject(GrFl, log)];
  if (gradientFillMulti)
    effects.gradientOverlay = gradientFillMulti.map(function(i2) {
      return parseEffectObject(i2, log);
    });
  if (ChFX)
    effects.satin = parseEffectObject(ChFX, log);
  if (FrFX)
    effects.stroke = [parseFxObject(FrFX)];
  if (frameFXMulti)
    effects.stroke = frameFXMulti.map(function(i2) {
      return parseFxObject(i2);
    });
  if (log && Object.keys(rest).length > 1)
    console.log("Unhandled effect keys:", rest);
  return effects;
}
function parseKeyList(keyList, logMissingFeatures) {
  var keys = [];
  for (var j = 0; j < keyList.length; j++) {
    var key = keyList[j];
    var _a = key.time, denominator = _a.denominator, numerator = _a.numerator, selected = key.selected, animKey = key.animKey;
    var time = { numerator, denominator };
    var interpolation = animInterpStyleEnum.decode(key.animInterpStyle);
    switch (animKey.Type) {
      case "keyType.Opct":
        keys.push({ interpolation, time, selected, type: "opacity", value: parsePercent(animKey.Opct) });
        break;
      case "keyType.Pstn":
        keys.push({ interpolation, time, selected, type: "position", x: animKey.Hrzn, y: animKey.Vrtc });
        break;
      case "keyType.Trnf":
        keys.push({
          interpolation,
          time,
          selected,
          type: "transform",
          scale: horzVrtcToXY(animKey["Scl "]),
          skew: horzVrtcToXY(animKey.Skew),
          rotation: animKey.rotation,
          translation: horzVrtcToXY(animKey.translation)
        });
        break;
      case "keyType.sheetStyle": {
        var key_1 = { interpolation, time, selected, type: "style" };
        if (animKey.sheetStyle.Lefx)
          key_1.style = parseEffects(animKey.sheetStyle.Lefx, logMissingFeatures);
        keys.push(key_1);
        break;
      }
      case "keyType.globalLighting": {
        keys.push({
          interpolation,
          time,
          selected,
          type: "globalLighting",
          globalAngle: animKey.gblA,
          globalAltitude: animKey.globalAltitude
        });
        break;
      }
      default:
        throw new Error("Unsupported keyType value");
    }
  }
  return keys;
}
function serializeKeyList(keys) {
  var keyList = [];
  for (var j = 0; j < keys.length; j++) {
    var key = keys[j];
    var time = key.time, _a = key.selected, selected = _a === void 0 ? false : _a, interpolation = key.interpolation;
    var animInterpStyle = animInterpStyleEnum.encode(interpolation);
    var animKey = void 0;
    switch (key.type) {
      case "opacity":
        animKey = { Type: "keyType.Opct", Opct: unitsPercent(key.value) };
        break;
      case "position":
        animKey = { Type: "keyType.Pstn", Hrzn: key.x, Vrtc: key.y };
        break;
      case "transform":
        animKey = { Type: "keyType.Trnf", "Scl ": xyToHorzVrtc(key.scale), Skew: xyToHorzVrtc(key.skew), rotation: key.rotation, translation: xyToHorzVrtc(key.translation) };
        break;
      case "style":
        animKey = { Type: "keyType.sheetStyle", sheetStyle: { Vrsn: 1, blendOptions: {} } };
        if (key.style)
          animKey.sheetStyle = { Vrsn: 1, Lefx: serializeEffects(key.style, false, false), blendOptions: {} };
        break;
      case "globalLighting": {
        animKey = { Type: "keyType.globalLighting", gblA: key.globalAngle, globalAltitude: key.globalAltitude };
        break;
      }
      default:
        throw new Error("Unsupported keyType value");
    }
    keyList.push({ Vrsn: 1, animInterpStyle, time, animKey, selected });
  }
  return keyList;
}
function parseTrackList(trackList, logMissingFeatures) {
  var tracks = [];
  for (var i2 = 0; i2 < trackList.length; i2++) {
    var tr = trackList[i2];
    var track2 = {
      type: stdTrackID.decode(tr.trackID),
      enabled: tr.enab,
      keys: parseKeyList(tr.keyList, logMissingFeatures)
    };
    if (tr.effectParams) {
      track2.effectParams = {
        fillCanvas: tr.effectParams.fillCanvas,
        zoomOrigin: tr.effectParams.zoomOrigin,
        keys: parseKeyList(tr.effectParams.keyList, logMissingFeatures)
      };
    }
    tracks.push(track2);
  }
  return tracks;
}
function serializeTrackList(tracks) {
  var trackList = [];
  for (var i2 = 0; i2 < tracks.length; i2++) {
    var t2 = tracks[i2];
    trackList.push(__assign$6(__assign$6({ trackID: stdTrackID.encode(t2.type), Vrsn: 1, enab: !!t2.enabled, Effc: !!t2.effectParams }, t2.effectParams ? {
      effectParams: {
        keyList: serializeKeyList(t2.keys),
        fillCanvas: t2.effectParams.fillCanvas,
        zoomOrigin: t2.effectParams.zoomOrigin
      }
    } : {}), { keyList: serializeKeyList(t2.keys) }));
  }
  return trackList;
}
function parseEffectObject(obj, reportErrors) {
  var result = {};
  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
    var key = _a[_i];
    var val = obj[key];
    switch (key) {
      case "enab":
        result.enabled = !!val;
        break;
      case "uglg":
        result.useGlobalLight = !!val;
        break;
      case "AntA":
        result.antialiased = !!val;
        break;
      case "Algn":
        result.align = !!val;
        break;
      case "Dthr":
        result.dither = !!val;
        break;
      case "Invr":
        result.invert = !!val;
        break;
      case "Rvrs":
        result.reverse = !!val;
        break;
      case "Clr ":
        result.color = parseColor(val);
        break;
      case "hglC":
        result.highlightColor = parseColor(val);
        break;
      case "sdwC":
        result.shadowColor = parseColor(val);
        break;
      case "Styl":
        result.position = FStl.decode(val);
        break;
      case "Md  ":
        result.blendMode = BlnM.decode(val);
        break;
      case "hglM":
        result.highlightBlendMode = BlnM.decode(val);
        break;
      case "sdwM":
        result.shadowBlendMode = BlnM.decode(val);
        break;
      case "bvlS":
        result.style = BESl.decode(val);
        break;
      case "bvlD":
        result.direction = BESs.decode(val);
        break;
      case "bvlT":
        result.technique = bvlT.decode(val);
        break;
      case "GlwT":
        result.technique = BETE.decode(val);
        break;
      case "glwS":
        result.source = IGSr.decode(val);
        break;
      case "Type":
        result.type = GrdT.decode(val);
        break;
      case "gs99":
        result.interpolationMethod = gradientInterpolationMethodType.decode(val);
        break;
      case "Opct":
        result.opacity = parsePercent(val);
        break;
      case "hglO":
        result.highlightOpacity = parsePercent(val);
        break;
      case "sdwO":
        result.shadowOpacity = parsePercent(val);
        break;
      case "lagl":
        result.angle = parseAngle(val);
        break;
      case "Angl":
        result.angle = parseAngle(val);
        break;
      case "Lald":
        result.altitude = parseAngle(val);
        break;
      case "Sftn":
        result.soften = parseUnits(val);
        break;
      case "srgR":
        result.strength = parsePercent(val);
        break;
      case "blur":
        result.size = parseUnits(val);
        break;
      case "Nose":
        result.noise = parsePercent(val);
        break;
      case "Inpr":
        result.range = parsePercent(val);
        break;
      case "Ckmt":
        result.choke = parseUnits(val);
        break;
      case "ShdN":
        result.jitter = parsePercent(val);
        break;
      case "Dstn":
        result.distance = parseUnits(val);
        break;
      case "Scl ":
        result.scale = parsePercent(val);
        break;
      case "Ptrn":
        result.pattern = { name: val["Nm  "], id: val.Idnt };
        break;
      case "phase":
        result.phase = { x: val.Hrzn, y: val.Vrtc };
        break;
      case "Ofst":
        result.offset = { x: parsePercent(val.Hrzn), y: parsePercent(val.Vrtc) };
        break;
      case "MpgS":
      case "TrnS":
        result.contour = {
          name: val["Nm  "],
          curve: val["Crv "].map(function(p2) {
            return { x: p2.Hrzn, y: p2.Vrtc };
          })
        };
        break;
      case "Grad":
        result.gradient = parseGradient(val);
        break;
      case "useTexture":
      case "useShape":
      case "layerConceals":
      case "present":
      case "showInDialog":
      case "antialiasGloss":
        result[key] = val;
        break;
      case "_name":
      case "_classID":
        break;
      default:
        reportErrors && console.log("Invalid effect key: '".concat(key, "', value:"), val);
    }
  }
  return result;
}
function serializeEffectObject(obj, objName, reportErrors) {
  var result = {
    enab: false
  };
  if (objName === "dropShadow") {
    result.TrnS = { "Nm  ": "", "Crv ": [] };
  }
  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
    var objKey = _a[_i];
    var key = objKey;
    var val = obj[key];
    switch (key) {
      case "enabled":
        result.enab = !!val;
        break;
      case "useGlobalLight":
        result.uglg = !!val;
        break;
      case "antialiased":
        result.AntA = !!val;
        break;
      case "align":
        result.Algn = !!val;
        break;
      case "dither":
        result.Dthr = !!val;
        break;
      case "invert":
        result.Invr = !!val;
        break;
      case "reverse":
        result.Rvrs = !!val;
        break;
      case "color":
        result["Clr "] = serializeColor(val);
        break;
      case "highlightColor":
        result.hglC = serializeColor(val);
        break;
      case "shadowColor":
        result.sdwC = serializeColor(val);
        break;
      case "position":
        result.Styl = FStl.encode(val);
        break;
      case "blendMode":
        result["Md  "] = BlnM.encode(val);
        break;
      case "highlightBlendMode":
        result.hglM = BlnM.encode(val);
        break;
      case "shadowBlendMode":
        result.sdwM = BlnM.encode(val);
        break;
      case "style":
        result.bvlS = BESl.encode(val);
        break;
      case "direction":
        result.bvlD = BESs.encode(val);
        break;
      case "technique":
        if (objName === "bevel") {
          result.bvlT = bvlT.encode(val);
        } else {
          result.GlwT = BETE.encode(val);
        }
        break;
      case "source":
        result.glwS = IGSr.encode(val);
        break;
      case "type":
        result.Type = GrdT.encode(val);
        break;
      case "interpolationMethod":
        result.gs99 = gradientInterpolationMethodType.encode(val);
        break;
      case "opacity":
        result.Opct = unitsPercent(val);
        break;
      case "highlightOpacity":
        result.hglO = unitsPercent(val);
        break;
      case "shadowOpacity":
        result.sdwO = unitsPercent(val);
        break;
      case "angle":
        if (objName === "gradientOverlay" || objName === "patternFill") {
          result.Angl = unitsAngle(val);
        } else {
          result.lagl = unitsAngle(val);
        }
        break;
      case "altitude":
        result.Lald = unitsAngle(val);
        break;
      case "soften":
        result.Sftn = unitsValue(val, key);
        break;
      case "strength":
        result.srgR = unitsPercent(val);
        break;
      case "size":
        result.blur = unitsValue(val, key);
        break;
      case "noise":
        result.Nose = unitsPercent(val);
        break;
      case "range":
        result.Inpr = unitsPercent(val);
        break;
      case "choke":
        result.Ckmt = unitsValue(val, key);
        break;
      case "jitter":
        result.ShdN = unitsPercent(val);
        break;
      case "distance":
        result.Dstn = unitsValue(val, key);
        break;
      case "scale":
        result["Scl "] = unitsPercent(val);
        break;
      case "pattern":
        result.Ptrn = { "Nm  ": val.name, Idnt: val.id };
        break;
      case "phase":
        result.phase = { Hrzn: val.x, Vrtc: val.y };
        break;
      case "offset":
        result.Ofst = { Hrzn: unitsPercent(val.x), Vrtc: unitsPercent(val.y) };
        break;
      case "contour": {
        result[objName === "satin" ? "MpgS" : "TrnS"] = {
          "Nm  ": val.name,
          "Crv ": val.curve.map(function(p2) {
            return { Hrzn: p2.x, Vrtc: p2.y };
          })
        };
        break;
      }
      case "gradient":
        result.Grad = serializeGradient(val);
        break;
      case "useTexture":
      case "useShape":
      case "layerConceals":
      case "present":
      case "showInDialog":
      case "antialiasGloss":
        result[key] = val;
        break;
      default:
        reportErrors && console.log("Invalid effect key: '".concat(key, "', value:"), val);
    }
  }
  return result;
}
function parseGradient(grad) {
  if (grad.GrdF === "GrdF.CstS") {
    var samples_1 = grad.Intr || 4096;
    return {
      type: "solid",
      name: grad["Nm  "],
      smoothness: grad.Intr / 4096,
      colorStops: grad.Clrs.map(function(s2) {
        return {
          color: parseColor(s2["Clr "]),
          location: s2.Lctn / samples_1,
          midpoint: s2.Mdpn / 100
        };
      }),
      opacityStops: grad.Trns.map(function(s2) {
        return {
          opacity: parsePercent(s2.Opct),
          location: s2.Lctn / samples_1,
          midpoint: s2.Mdpn / 100
        };
      })
    };
  } else {
    return {
      type: "noise",
      name: grad["Nm  "],
      roughness: grad.Smth / 4096,
      colorModel: ClrS.decode(grad.ClrS),
      randomSeed: grad.RndS,
      restrictColors: !!grad.VctC,
      addTransparency: !!grad.ShTr,
      min: grad["Mnm "].map(function(x2) {
        return x2 / 100;
      }),
      max: grad["Mxm "].map(function(x2) {
        return x2 / 100;
      })
    };
  }
}
function serializeGradient(grad) {
  var _a, _b;
  if (grad.type === "solid") {
    var samples_2 = Math.round(((_a = grad.smoothness) !== null && _a !== void 0 ? _a : 1) * 4096);
    return {
      "Nm  ": grad.name || "",
      GrdF: "GrdF.CstS",
      Intr: samples_2,
      Clrs: grad.colorStops.map(function(s2) {
        var _a2;
        return {
          "Clr ": serializeColor(s2.color),
          Type: "Clry.UsrS",
          Lctn: Math.round(s2.location * samples_2),
          Mdpn: Math.round(((_a2 = s2.midpoint) !== null && _a2 !== void 0 ? _a2 : 0.5) * 100)
        };
      }),
      Trns: grad.opacityStops.map(function(s2) {
        var _a2;
        return {
          Opct: unitsPercent(s2.opacity),
          Lctn: Math.round(s2.location * samples_2),
          Mdpn: Math.round(((_a2 = s2.midpoint) !== null && _a2 !== void 0 ? _a2 : 0.5) * 100)
        };
      })
    };
  } else {
    return {
      GrdF: "GrdF.ClNs",
      "Nm  ": grad.name || "",
      ShTr: !!grad.addTransparency,
      VctC: !!grad.restrictColors,
      ClrS: ClrS.encode(grad.colorModel),
      RndS: grad.randomSeed || 0,
      Smth: Math.round(((_b = grad.roughness) !== null && _b !== void 0 ? _b : 1) * 4096),
      "Mnm ": (grad.min || [0, 0, 0, 0]).map(function(x2) {
        return x2 * 100;
      }),
      "Mxm ": (grad.max || [1, 1, 1, 1]).map(function(x2) {
        return x2 * 100;
      })
    };
  }
}
function parseGradientContent(descriptor) {
  var result = parseGradient(descriptor.Grad);
  result.style = GrdT.decode(descriptor.Type);
  if (descriptor.Dthr !== void 0)
    result.dither = descriptor.Dthr;
  if (descriptor.gradientsInterpolationMethod !== void 0)
    result.interpolationMethod = gradientInterpolationMethodType.decode(descriptor.gradientsInterpolationMethod);
  if (descriptor.Rvrs !== void 0)
    result.reverse = descriptor.Rvrs;
  if (descriptor.Angl !== void 0)
    result.angle = parseAngle(descriptor.Angl);
  if (descriptor["Scl "] !== void 0)
    result.scale = parsePercent(descriptor["Scl "]);
  if (descriptor.Algn !== void 0)
    result.align = descriptor.Algn;
  if (descriptor.Ofst !== void 0) {
    result.offset = {
      x: parsePercent(descriptor.Ofst.Hrzn),
      y: parsePercent(descriptor.Ofst.Vrtc)
    };
  }
  return result;
}
function parsePatternContent(descriptor) {
  var result = {
    name: descriptor.Ptrn["Nm  "],
    id: descriptor.Ptrn.Idnt
  };
  if (descriptor.Lnkd !== void 0)
    result.linked = descriptor.Lnkd;
  if (descriptor.phase !== void 0)
    result.phase = { x: descriptor.phase.Hrzn, y: descriptor.phase.Vrtc };
  return result;
}
function parseVectorContent(descriptor) {
  if ("Grad" in descriptor) {
    return parseGradientContent(descriptor);
  } else if ("Ptrn" in descriptor) {
    return __assign$6({ type: "pattern" }, parsePatternContent(descriptor));
  } else if ("Clr " in descriptor) {
    return { type: "color", color: parseColor(descriptor["Clr "]) };
  } else {
    throw new Error("Invalid vector content");
  }
}
function serializeGradientContent(content) {
  var result = {};
  if (content.dither !== void 0)
    result.Dthr = content.dither;
  if (content.interpolationMethod !== void 0)
    result.gradientsInterpolationMethod = gradientInterpolationMethodType.encode(content.interpolationMethod);
  if (content.reverse !== void 0)
    result.Rvrs = content.reverse;
  if (content.angle !== void 0)
    result.Angl = unitsAngle(content.angle);
  result.Type = GrdT.encode(content.style);
  if (content.align !== void 0)
    result.Algn = content.align;
  if (content.scale !== void 0)
    result["Scl "] = unitsPercent(content.scale);
  if (content.offset) {
    result.Ofst = {
      Hrzn: unitsPercent(content.offset.x),
      Vrtc: unitsPercent(content.offset.y)
    };
  }
  result.Grad = serializeGradient(content);
  return result;
}
function serializePatternContent(content) {
  var result = {
    Ptrn: {
      "Nm  ": content.name || "",
      Idnt: content.id || ""
    }
  };
  if (content.linked !== void 0)
    result.Lnkd = !!content.linked;
  if (content.phase !== void 0)
    result.phase = { Hrzn: content.phase.x, Vrtc: content.phase.y };
  return result;
}
function serializeVectorContent(content) {
  if (content.type === "color") {
    return { key: "SoCo", descriptor: { "Clr ": serializeColor(content.color) } };
  } else if (content.type === "pattern") {
    return { key: "PtFl", descriptor: serializePatternContent(content) };
  } else {
    return { key: "GdFl", descriptor: serializeGradientContent(content) };
  }
}
function parseColor(color) {
  if ("H   " in color) {
    return { h: parsePercentOrAngle(color["H   "]), s: color.Strt, b: color.Brgh };
  } else if ("Rd  " in color) {
    return { r: color["Rd  "], g: color["Grn "], b: color["Bl  "] };
  } else if ("Cyn " in color) {
    return { c: color["Cyn "], m: color.Mgnt, y: color["Ylw "], k: color.Blck };
  } else if ("Gry " in color) {
    return { k: color["Gry "] };
  } else if ("Lmnc" in color) {
    return { l: color.Lmnc, a: color["A   "], b: color["B   "] };
  } else if ("redFloat" in color) {
    return { fr: color.redFloat, fg: color.greenFloat, fb: color.blueFloat };
  } else {
    throw new Error("Unsupported color descriptor");
  }
}
function serializeColor(color) {
  if (!color) {
    return { _name: "", _classID: "RGBC", "Rd  ": 0, "Grn ": 0, "Bl  ": 0 };
  } else if ("r" in color) {
    return { _name: "", _classID: "RGBC", "Rd  ": color.r || 0, "Grn ": color.g || 0, "Bl  ": color.b || 0 };
  } else if ("fr" in color) {
    return { _name: "", _classID: "RGBC", redFloat: color.fr, greenFloat: color.fg, blueFloat: color.fb };
  } else if ("h" in color) {
    return { _name: "", _classID: "HSBC", "H   ": unitsAngle(color.h * 360), Strt: color.s || 0, Brgh: color.b || 0 };
  } else if ("c" in color) {
    return { _name: "", _classID: "CMYC", "Cyn ": color.c || 0, Mgnt: color.m || 0, "Ylw ": color.y || 0, Blck: color.k || 0 };
  } else if ("l" in color) {
    return { _name: "", _classID: "LABC", Lmnc: color.l || 0, "A   ": color.a || 0, "B   ": color.b || 0 };
  } else if ("k" in color) {
    return { _name: "", _classID: "GRYC", "Gry ": color.k };
  } else {
    throw new Error("Invalid color value");
  }
}
function parseAngle(x2) {
  if (x2 === void 0)
    return 0;
  if (x2.units !== "Angle")
    throw new Error("Invalid units: ".concat(x2.units));
  return x2.value;
}
function parsePercent(x2) {
  if (x2 === void 0)
    return 1;
  if (x2.units !== "Percent")
    throw new Error("Invalid units: ".concat(x2.units));
  return x2.value / 100;
}
function parsePercentOrAngle(x2) {
  if (x2 === void 0)
    return 1;
  if (x2.units === "Percent")
    return x2.value / 100;
  if (x2.units === "Angle")
    return x2.value / 360;
  throw new Error("Invalid units: ".concat(x2.units));
}
function parseUnits(_a) {
  var units = _a.units, value = _a.value;
  if (units !== "Pixels" && units !== "Millimeters" && units !== "Points" && units !== "None" && units !== "Picas" && units !== "Inches" && units !== "Centimeters" && units !== "Density") {
    throw new Error("Invalid units: ".concat(JSON.stringify({ units, value })));
  }
  return { value, units };
}
function parseUnitsOrNumber(value, units) {
  if (units === void 0) {
    units = "Pixels";
  }
  if (typeof value === "number")
    return { value, units };
  return parseUnits(value);
}
function unitsAngle(value) {
  return { units: "Angle", value: value || 0 };
}
function unitsPercent(value) {
  return { units: "Percent", value: Math.round((value || 0) * 100) };
}
function unitsPercentF(value) {
  return { units: "Percent", value: (value || 0) * 100 };
}
function unitsValue(x2, key) {
  if (x2 == null)
    return { units: "Pixels", value: 0 };
  if (typeof x2 !== "object")
    throw new Error("Invalid value: ".concat(JSON.stringify(x2), " (key: ").concat(key, ") (should have value and units)"));
  var units = x2.units, value = x2.value;
  if (typeof value !== "number")
    throw new Error("Invalid value in ".concat(JSON.stringify(x2), " (key: ").concat(key, ")"));
  if (units !== "Pixels" && units !== "Millimeters" && units !== "Points" && units !== "None" && units !== "Picas" && units !== "Inches" && units !== "Centimeters" && units !== "Density") {
    throw new Error("Invalid units in ".concat(JSON.stringify(x2), " (key: ").concat(key, ")"));
  }
  return { units, value };
}
function frac(_a) {
  var numerator = _a.numerator, denominator = _a.denominator;
  return { numerator, denominator };
}
var textGridding = createEnum("textGridding", "none", {
  none: "None",
  round: "Rnd "
});
var Ornt = createEnum("Ornt", "horizontal", {
  horizontal: "Hrzn",
  vertical: "Vrtc"
});
var Annt = createEnum("Annt", "sharp", {
  none: "Anno",
  sharp: "antiAliasSharp",
  crisp: "AnCr",
  strong: "AnSt",
  smooth: "AnSm",
  platform: "antiAliasPlatformGray",
  platformLCD: "antiAliasPlatformLCD"
});
var warpStyle = createEnum("warpStyle", "none", {
  none: "warpNone",
  arc: "warpArc",
  arcLower: "warpArcLower",
  arcUpper: "warpArcUpper",
  arch: "warpArch",
  bulge: "warpBulge",
  shellLower: "warpShellLower",
  shellUpper: "warpShellUpper",
  flag: "warpFlag",
  wave: "warpWave",
  fish: "warpFish",
  rise: "warpRise",
  fisheye: "warpFisheye",
  inflate: "warpInflate",
  squeeze: "warpSqueeze",
  twist: "warpTwist",
  cylinder: "warpCylinder",
  custom: "warpCustom"
});
var BlnM = createEnum("BlnM", "normal", {
  "normal": "Nrml",
  "dissolve": "Dslv",
  "darken": "Drkn",
  "multiply": "Mltp",
  "color burn": "CBrn",
  "linear burn": "linearBurn",
  "darker color": "darkerColor",
  "lighten": "Lghn",
  "screen": "Scrn",
  "color dodge": "CDdg",
  "linear dodge": "linearDodge",
  "lighter color": "lighterColor",
  "overlay": "Ovrl",
  "soft light": "SftL",
  "hard light": "HrdL",
  "vivid light": "vividLight",
  "linear light": "linearLight",
  "pin light": "pinLight",
  "hard mix": "hardMix",
  "difference": "Dfrn",
  "exclusion": "Xclu",
  "subtract": "blendSubtraction",
  "divide": "blendDivide",
  "hue": "H   ",
  "saturation": "Strt",
  "color": "Clr ",
  "luminosity": "Lmns",
  // used in ABR
  "linear height": "linearHeight",
  "height": "Hght",
  "subtraction": "Sbtr"
  // 2nd version of subtract ?
});
var BESl = createEnum("BESl", "inner bevel", {
  "inner bevel": "InrB",
  "outer bevel": "OtrB",
  "emboss": "Embs",
  "pillow emboss": "PlEb",
  "stroke emboss": "strokeEmboss"
});
var bvlT = createEnum("bvlT", "smooth", {
  "smooth": "SfBL",
  "chisel hard": "PrBL",
  "chisel soft": "Slmt"
});
var BESs = createEnum("BESs", "up", {
  up: "In  ",
  down: "Out "
});
var BETE = createEnum("BETE", "softer", {
  softer: "SfBL",
  precise: "PrBL"
});
var IGSr = createEnum("IGSr", "edge", {
  edge: "SrcE",
  center: "SrcC"
});
var GrdT = createEnum("GrdT", "linear", {
  linear: "Lnr ",
  radial: "Rdl ",
  angle: "Angl",
  reflected: "Rflc",
  diamond: "Dmnd"
});
var animInterpStyleEnum = createEnum("animInterpStyle", "linear", {
  linear: "Lnr ",
  hold: "hold"
});
var stdTrackID = createEnum("stdTrackID", "opacity", {
  opacity: "opacityTrack",
  style: "styleTrack",
  sheetTransform: "sheetTransformTrack",
  sheetPosition: "sheetPositionTrack",
  globalLighting: "globalLightingTrack"
});
var gradientInterpolationMethodType = createEnum("gradientInterpolationMethodType", "perceptual", {
  perceptual: "Perc",
  linear: "Lnr ",
  classic: "Gcls",
  smooth: "Smoo"
  // TODO: stripes
});
var ClrS = createEnum("ClrS", "rgb", {
  rgb: "RGBC",
  hsb: "HSBl",
  lab: "LbCl",
  hsl: "HSLC"
});
var FStl = createEnum("FStl", "outside", {
  outside: "OutF",
  center: "CtrF",
  inside: "InsF"
});
var FrFl = createEnum("FrFl", "color", {
  color: "SClr",
  gradient: "GrFl",
  pattern: "Ptrn"
});
var ESliceType = createEnum("ESliceType", "image", {
  image: "Img ",
  noImage: "noImage"
});
var ESliceHorzAlign = createEnum("ESliceHorzAlign", "default", {
  default: "default"
});
var ESliceVertAlign = createEnum("ESliceVertAlign", "default", {
  default: "default"
});
var ESliceOrigin = createEnum("ESliceOrigin", "userGenerated", {
  userGenerated: "userGenerated",
  autoGenerated: "autoGenerated",
  layer: "layer"
});
var ESliceBGColorType = createEnum("ESliceBGColorType", "none", {
  none: "None",
  matte: "matte",
  color: "Clr "
});
var strokeStyleLineCapType = createEnum("strokeStyleLineCapType", "butt", {
  butt: "strokeStyleButtCap",
  round: "strokeStyleRoundCap",
  square: "strokeStyleSquareCap"
});
var strokeStyleLineJoinType = createEnum("strokeStyleLineJoinType", "miter", {
  miter: "strokeStyleMiterJoin",
  round: "strokeStyleRoundJoin",
  bevel: "strokeStyleBevelJoin"
});
var strokeStyleLineAlignment = createEnum("strokeStyleLineAlignment", "inside", {
  inside: "strokeStyleAlignInside",
  center: "strokeStyleAlignCenter",
  outside: "strokeStyleAlignOutside"
});
var BlrM = createEnum("BlrM", "ispinmage", {
  spin: "Spn ",
  zoom: "Zm  "
});
var BlrQ = createEnum("BlrQ", "good", {
  draft: "Drft",
  good: "Gd  ",
  best: "Bst "
});
var SmBM = createEnum("SmBM", "normal", {
  normal: "SBMN",
  "edge only": "SBME",
  "overlay edge": "SBMO"
});
var SmBQ = createEnum("SmBQ", "medium", {
  low: "SBQL",
  medium: "SBQM",
  high: "SBQH"
});
var DspM = createEnum("DspM", "stretch to fit", {
  "stretch to fit": "StrF",
  "tile": "Tile"
});
var UndA = createEnum("UndA", "repeat edge pixels", {
  "wrap around": "WrpA",
  "repeat edge pixels": "RptE"
});
var Cnvr = createEnum("Cnvr", "rectangular to polar", {
  "rectangular to polar": "RctP",
  "polar to rectangular": "PlrR"
});
var RplS = createEnum("RplS", "medium", {
  small: "Sml ",
  medium: "Mdm ",
  large: "Lrg "
});
var SphM = createEnum("SphM", "normal", {
  "normal": "Nrml",
  "horizontal only": "HrzO",
  "vertical only": "VrtO"
});
var Wvtp = createEnum("Wvtp", "sine", {
  sine: "WvSn",
  triangle: "WvTr",
  square: "WvSq"
});
var ZZTy = createEnum("ZZTy", "pond ripples", {
  "around center": "ArnC",
  "out from center": "OtFr",
  "pond ripples": "PndR"
});
var Dstr = createEnum("Dstr", "uniform", {
  uniform: "Unfr",
  gaussian: "Gsn "
});
var Chnl = createEnum("Chnl", "composite", {
  red: "Rd  ",
  green: "Grn ",
  blue: "Bl  ",
  composite: "Cmps"
});
var MztT = createEnum("MztT", "fine dots", {
  "fine dots": "FnDt",
  "medium dots": "MdmD",
  "grainy dots": "GrnD",
  "coarse dots": "CrsD",
  "short lines": "ShrL",
  "medium lines": "MdmL",
  "long lines": "LngL",
  "short strokes": "ShSt",
  "medium strokes": "MdmS",
  "long strokes": "LngS"
});
var Lns = createEnum("Lns ", "50-300mm zoom", {
  "50-300mm zoom": "Zm  ",
  "32mm prime": "Nkn ",
  "105mm prime": "Nkn1",
  "movie prime": "PnVs"
});
var blurType = createEnum("blurType", "gaussian blur", {
  "gaussian blur": "GsnB",
  "lens blur": "lensBlur",
  "motion blur": "MtnB"
});
var DfsM = createEnum("DfsM", "normal", {
  "normal": "Nrml",
  "darken only": "DrkO",
  "lighten only": "LghO",
  "anisotropic": "anisotropic"
});
var ExtT = createEnum("ExtT", "blocks", {
  blocks: "Blks",
  pyramids: "Pyrm"
});
var ExtR = createEnum("ExtR", "random", {
  random: "Rndm",
  "level-based": "LvlB"
});
var FlCl = createEnum("FlCl", "background color", {
  "background color": "FlBc",
  "foreground color": "FlFr",
  "inverse image": "FlIn",
  "unaltered image": "FlSm"
});
var CntE = createEnum("CntE", "upper", {
  lower: "Lwr ",
  upper: "Upr "
});
var WndM = createEnum("WndM", "wind", {
  wind: "Wnd ",
  blast: "Blst",
  stagger: "Stgr"
});
var Drct = createEnum("Drct", "from the right", {
  left: "Left",
  right: "Rght"
});
var IntE = createEnum("IntE", "odd lines", {
  "odd lines": "ElmO",
  "even lines": "ElmE"
});
var IntC = createEnum("IntC", "interpolation", {
  duplication: "CrtD",
  interpolation: "CrtI"
});
var FlMd = createEnum("FlMd", "wrap around", {
  "set to transparent": "Bckg",
  "repeat edge pixels": "Rpt ",
  "wrap around": "Wrp "
});
createEnum("prjM", "fisheye", {
  "fisheye": "fisP",
  "perspective": "perP",
  "auto": "auto",
  "full spherical": "fusP"
});
var presetKindType = createEnum("presetKindType", "presetKindCustom", {
  custom: "presetKindCustom",
  default: "presetKindDefault"
});
var __assign$5 = function() {
  __assign$5 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
var resourceHandlers = [];
var resourceHandlersMap = {};
function addHandler$1(key, has, read, write) {
  var handler3 = { key, has, read, write };
  resourceHandlers.push(handler3);
  resourceHandlersMap[handler3.key] = handler3;
}
var RESOLUTION_UNITS = [void 0, "PPI", "PPCM"];
var MEASUREMENT_UNITS = [void 0, "Inches", "Centimeters", "Points", "Picas", "Columns"];
var hex = "0123456789abcdef";
function charToNibble(code2) {
  return code2 <= 57 ? code2 - 48 : code2 - 87;
}
function byteAt(value, index) {
  return charToNibble(value.charCodeAt(index)) << 4 | charToNibble(value.charCodeAt(index + 1));
}
function readUtf8String(reader, length) {
  var buffer = readBytes(reader, length);
  return decodeString(buffer);
}
function writeUtf8String(writer, value) {
  var buffer = encodeString(value);
  writeBytes(writer, buffer);
}
function readEncodedString(reader) {
  var length = readUint8(reader);
  var buffer = readBytes(reader, length);
  var notAscii = false;
  for (var i2 = 0; i2 < buffer.byteLength; i2++) {
    if (buffer[i2] & 128) {
      notAscii = true;
      break;
    }
  }
  if (notAscii) {
    var decoder = new TextDecoder("gbk");
    return decoder.decode(buffer);
  } else {
    return decodeString(buffer);
  }
}
function writeEncodedString(writer, value) {
  var ascii = "";
  for (var i2 = 0, code2 = value.codePointAt(i2++); code2 !== void 0; code2 = value.codePointAt(i2++)) {
    ascii += code2 > 127 ? "?" : String.fromCodePoint(code2);
  }
  var buffer = encodeString(ascii);
  writeUint8(writer, buffer.byteLength);
  writeBytes(writer, buffer);
}
addHandler$1(1061, function(target) {
  return target.captionDigest !== void 0;
}, function(reader, target) {
  var captionDigest = "";
  for (var i2 = 0; i2 < 16; i2++) {
    var byte = readUint8(reader);
    captionDigest += hex[byte >> 4];
    captionDigest += hex[byte & 15];
  }
  target.captionDigest = captionDigest;
}, function(writer, target) {
  for (var i2 = 0; i2 < 16; i2++) {
    writeUint8(writer, byteAt(target.captionDigest, i2 * 2));
  }
});
addHandler$1(1060, function(target) {
  return target.xmpMetadata !== void 0;
}, function(reader, target, left) {
  target.xmpMetadata = readUtf8String(reader, left());
}, function(writer, target) {
  writeUtf8String(writer, target.xmpMetadata);
});
var Inte = createEnum("Inte", "perceptual", {
  "perceptual": "Img ",
  "saturation": "Grp ",
  "relative colorimetric": "Clrm",
  "absolute colorimetric": "AClr"
});
addHandler$1(1082, function(target) {
  return target.printInformation !== void 0;
}, function(reader, target) {
  var _a, _b;
  var desc = readVersionAndDescriptor(reader);
  target.printInformation = {
    printerName: desc.printerName || "",
    renderingIntent: Inte.decode((_a = desc.Inte) !== null && _a !== void 0 ? _a : "Inte.Img ")
  };
  var info = target.printInformation;
  if (desc.PstS !== void 0)
    info.printerManagesColors = desc.PstS;
  if (desc["Nm  "] !== void 0)
    info.printerProfile = desc["Nm  "];
  if (desc.MpBl !== void 0)
    info.blackPointCompensation = desc.MpBl;
  if (desc.printSixteenBit !== void 0)
    info.printSixteenBit = desc.printSixteenBit;
  if (desc.hardProof !== void 0)
    info.hardProof = desc.hardProof;
  if (desc.printProofSetup) {
    if ("Bltn" in desc.printProofSetup) {
      info.proofSetup = { builtin: desc.printProofSetup.Bltn.split(".")[1] };
    } else {
      info.proofSetup = {
        profile: desc.printProofSetup.profile,
        renderingIntent: Inte.decode((_b = desc.printProofSetup.Inte) !== null && _b !== void 0 ? _b : "Inte.Img "),
        blackPointCompensation: !!desc.printProofSetup.MpBl,
        paperWhite: !!desc.printProofSetup.paperWhite
      };
    }
  }
}, function(writer, target) {
  var _a, _b;
  var info = target.printInformation;
  var desc = {};
  if (info.printerManagesColors) {
    desc.PstS = true;
  } else {
    if (info.hardProof !== void 0)
      desc.hardProof = !!info.hardProof;
    desc.ClrS = "ClrS.RGBC";
    desc["Nm  "] = (_a = info.printerProfile) !== null && _a !== void 0 ? _a : "CIE RGB";
  }
  desc.Inte = Inte.encode(info.renderingIntent);
  if (!info.printerManagesColors)
    desc.MpBl = !!info.blackPointCompensation;
  desc.printSixteenBit = !!info.printSixteenBit;
  desc.printerName = info.printerName || "";
  if (info.proofSetup && "profile" in info.proofSetup) {
    desc.printProofSetup = {
      profile: info.proofSetup.profile || "",
      Inte: Inte.encode(info.proofSetup.renderingIntent),
      MpBl: !!info.proofSetup.blackPointCompensation,
      paperWhite: !!info.proofSetup.paperWhite
    };
  } else {
    desc.printProofSetup = {
      Bltn: ((_b = info.proofSetup) === null || _b === void 0 ? void 0 : _b.builtin) ? "builtinProof.".concat(info.proofSetup.builtin) : "builtinProof.proofCMYK"
    };
  }
  writeVersionAndDescriptor(writer, "", "printOutput", desc);
});
addHandler$1(1005, function(target) {
  return target.resolutionInfo !== void 0;
}, function(reader, target) {
  var horizontalResolution = readFixedPoint32(reader);
  var horizontalResolutionUnit = readUint16(reader);
  var widthUnit = readUint16(reader);
  var verticalResolution = readFixedPoint32(reader);
  var verticalResolutionUnit = readUint16(reader);
  var heightUnit = readUint16(reader);
  target.resolutionInfo = {
    horizontalResolution,
    horizontalResolutionUnit: RESOLUTION_UNITS[horizontalResolutionUnit] || "PPI",
    widthUnit: MEASUREMENT_UNITS[widthUnit] || "Inches",
    verticalResolution,
    verticalResolutionUnit: RESOLUTION_UNITS[verticalResolutionUnit] || "PPI",
    heightUnit: MEASUREMENT_UNITS[heightUnit] || "Inches"
  };
}, function(writer, target) {
  var info = target.resolutionInfo;
  writeFixedPoint32(writer, info.horizontalResolution || 0);
  writeUint16(writer, Math.max(1, RESOLUTION_UNITS.indexOf(info.horizontalResolutionUnit)));
  writeUint16(writer, Math.max(1, MEASUREMENT_UNITS.indexOf(info.widthUnit)));
  writeFixedPoint32(writer, info.verticalResolution || 0);
  writeUint16(writer, Math.max(1, RESOLUTION_UNITS.indexOf(info.verticalResolutionUnit)));
  writeUint16(writer, Math.max(1, MEASUREMENT_UNITS.indexOf(info.heightUnit)));
});
var printScaleStyles = ["centered", "size to fit", "user defined"];
addHandler$1(1062, function(target) {
  return target.printScale !== void 0;
}, function(reader, target) {
  target.printScale = {
    style: printScaleStyles[readInt16(reader)],
    x: readFloat32(reader),
    y: readFloat32(reader),
    scale: readFloat32(reader)
  };
}, function(writer, target) {
  var _a = target.printScale, style2 = _a.style, x2 = _a.x, y2 = _a.y, scale = _a.scale;
  writeInt16(writer, Math.max(0, printScaleStyles.indexOf(style2)));
  writeFloat32(writer, x2 || 0);
  writeFloat32(writer, y2 || 0);
  writeFloat32(writer, scale || 0);
});
addHandler$1(1006, function(target) {
  return target.alphaChannelNames !== void 0;
}, function(reader, target, left) {
  if (!target.alphaChannelNames) {
    target.alphaChannelNames = [];
    while (left() > 0) {
      var value = readEncodedString(reader);
      target.alphaChannelNames.push(value);
    }
  } else {
    skipBytes(reader, left());
  }
}, function(writer, target) {
  for (var _i = 0, _a = target.alphaChannelNames; _i < _a.length; _i++) {
    var name_1 = _a[_i];
    writeEncodedString(writer, name_1);
  }
});
addHandler$1(1045, function(target) {
  return target.alphaChannelNames !== void 0;
}, function(reader, target, left) {
  target.alphaChannelNames = [];
  while (left() > 0) {
    target.alphaChannelNames.push(readUnicodeString(reader));
  }
}, function(writer, target) {
  for (var _i = 0, _a = target.alphaChannelNames; _i < _a.length; _i++) {
    var name_2 = _a[_i];
    writeUnicodeStringWithPadding(writer, name_2);
  }
});
addHandler$1(1053, function(target) {
  return target.alphaIdentifiers !== void 0;
}, function(reader, target, left) {
  target.alphaIdentifiers = [];
  while (left() >= 4) {
    target.alphaIdentifiers.push(readUint32(reader));
  }
}, function(writer, target) {
  for (var _i = 0, _a = target.alphaIdentifiers; _i < _a.length; _i++) {
    var id = _a[_i];
    writeUint32(writer, id);
  }
});
addHandler$1(1010, function(target) {
  return target.backgroundColor !== void 0;
}, function(reader, target) {
  return target.backgroundColor = readColor(reader);
}, function(writer, target) {
  return writeColor(writer, target.backgroundColor);
});
addHandler$1(1037, function(target) {
  return target.globalAngle !== void 0;
}, function(reader, target) {
  return target.globalAngle = readInt32(reader);
}, function(writer, target) {
  return writeInt32(writer, target.globalAngle);
});
addHandler$1(1049, function(target) {
  return target.globalAltitude !== void 0;
}, function(reader, target) {
  return target.globalAltitude = readUint32(reader);
}, function(writer, target) {
  return writeUint32(writer, target.globalAltitude);
});
addHandler$1(1011, function(target) {
  return target.printFlags !== void 0;
}, function(reader, target) {
  target.printFlags = {
    labels: !!readUint8(reader),
    cropMarks: !!readUint8(reader),
    colorBars: !!readUint8(reader),
    registrationMarks: !!readUint8(reader),
    negative: !!readUint8(reader),
    flip: !!readUint8(reader),
    interpolate: !!readUint8(reader),
    caption: !!readUint8(reader),
    printFlags: !!readUint8(reader)
  };
}, function(writer, target) {
  var flags = target.printFlags;
  writeUint8(writer, flags.labels ? 1 : 0);
  writeUint8(writer, flags.cropMarks ? 1 : 0);
  writeUint8(writer, flags.colorBars ? 1 : 0);
  writeUint8(writer, flags.registrationMarks ? 1 : 0);
  writeUint8(writer, flags.negative ? 1 : 0);
  writeUint8(writer, flags.flip ? 1 : 0);
  writeUint8(writer, flags.interpolate ? 1 : 0);
  writeUint8(writer, flags.caption ? 1 : 0);
  writeUint8(writer, flags.printFlags ? 1 : 0);
});
addHandler$1(
  1034,
  // Copyright flag
  function(target) {
    return target.copyrighted !== void 0;
  },
  function(reader, target) {
    target.copyrighted = !!readUint8(reader);
  },
  function(writer, target) {
    writeUint8(writer, target.copyrighted ? 1 : 0);
  }
);
addHandler$1(
  1035,
  // URL
  function(target) {
    return target.url !== void 0;
  },
  function(reader, target, left) {
    target.url = readAsciiString(reader, left());
  },
  function(writer, target) {
    writeAsciiString(writer, target.url);
  }
);
addHandler$1(
  1080,
  // Count Information
  function(target) {
    return target.countInformation !== void 0;
  },
  function(reader, target) {
    var desc = readVersionAndDescriptor(reader);
    target.countInformation = desc.countGroupList.map(function(g2) {
      return {
        color: { r: g2["Rd  "], g: g2["Grn "], b: g2["Bl  "] },
        name: g2["Nm  "],
        size: g2["Rds "],
        fontSize: g2.fontSize,
        visible: g2.Vsbl,
        points: g2.countObjectList.map(function(p2) {
          return { x: p2["X   "], y: p2["Y   "] };
        })
      };
    });
  },
  function(writer, target) {
    var desc = {
      Vrsn: 1,
      countGroupList: target.countInformation.map(function(g2) {
        return {
          "Rd  ": g2.color.r,
          "Grn ": g2.color.g,
          "Bl  ": g2.color.b,
          "Nm  ": g2.name,
          "Rds ": g2.size,
          fontSize: g2.fontSize,
          Vsbl: g2.visible,
          countObjectList: g2.points.map(function(p2) {
            return { "X   ": p2.x, "Y   ": p2.y };
          })
        };
      })
    };
    writeVersionAndDescriptor(writer, "", "Cnt ", desc);
  }
);
addHandler$1(1024, function(target) {
  return target.layerState !== void 0;
}, function(reader, target) {
  return target.layerState = readUint16(reader);
}, function(writer, target) {
  return writeUint16(writer, target.layerState);
});
addHandler$1(1026, function(target) {
  return target.layersGroup !== void 0;
}, function(reader, target, left) {
  target.layersGroup = [];
  while (left() > 0) {
    target.layersGroup.push(readUint16(reader));
  }
}, function(writer, target) {
  for (var _i = 0, _a = target.layersGroup; _i < _a.length; _i++) {
    var g2 = _a[_i];
    writeUint16(writer, g2);
  }
});
addHandler$1(1072, function(target) {
  return target.layerGroupsEnabledId !== void 0;
}, function(reader, target, left) {
  target.layerGroupsEnabledId = [];
  while (left() > 0) {
    target.layerGroupsEnabledId.push(readUint8(reader));
  }
}, function(writer, target) {
  for (var _i = 0, _a = target.layerGroupsEnabledId; _i < _a.length; _i++) {
    var id = _a[_i];
    writeUint8(writer, id);
  }
});
addHandler$1(1069, function(target) {
  return target.layerSelectionIds !== void 0;
}, function(reader, target) {
  var count = readUint16(reader);
  target.layerSelectionIds = [];
  while (count--) {
    target.layerSelectionIds.push(readUint32(reader));
  }
}, function(writer, target) {
  writeUint16(writer, target.layerSelectionIds.length);
  for (var _i = 0, _a = target.layerSelectionIds; _i < _a.length; _i++) {
    var id = _a[_i];
    writeUint32(writer, id);
  }
});
addHandler$1(1032, function(target) {
  return target.gridAndGuidesInformation !== void 0;
}, function(reader, target) {
  var version2 = readUint32(reader);
  var horizontal = readUint32(reader);
  var vertical = readUint32(reader);
  var count = readUint32(reader);
  if (version2 !== 1)
    throw new Error("Invalid 1032 resource version: ".concat(version2));
  target.gridAndGuidesInformation = {
    grid: { horizontal, vertical },
    guides: []
  };
  for (var i2 = 0; i2 < count; i2++) {
    target.gridAndGuidesInformation.guides.push({
      location: readUint32(reader) / 32,
      direction: readUint8(reader) ? "horizontal" : "vertical"
    });
  }
}, function(writer, target) {
  var info = target.gridAndGuidesInformation;
  var grid = info.grid || { horizontal: 18 * 32, vertical: 18 * 32 };
  var guides = info.guides || [];
  writeUint32(writer, 1);
  writeUint32(writer, grid.horizontal);
  writeUint32(writer, grid.vertical);
  writeUint32(writer, guides.length);
  for (var _i = 0, guides_1 = guides; _i < guides_1.length; _i++) {
    var g2 = guides_1[_i];
    writeUint32(writer, g2.location * 32);
    writeUint8(writer, g2.direction === "horizontal" ? 1 : 0);
  }
});
addHandler$1(
  1065,
  // Layer Comps
  function(target) {
    return target.layerComps !== void 0;
  },
  function(reader, target) {
    var desc = readVersionAndDescriptor(reader, true);
    target.layerComps = { list: [] };
    for (var _i = 0, _a = desc.list; _i < _a.length; _i++) {
      var item = _a[_i];
      target.layerComps.list.push({
        id: item.compID,
        name: item["Nm  "],
        capturedInfo: item.capturedInfo
      });
      if ("comment" in item)
        target.layerComps.list[target.layerComps.list.length - 1].comment = item.comment;
    }
    if ("lastAppliedComp" in desc)
      target.layerComps.lastApplied = desc.lastAppliedComp;
  },
  function(writer, target) {
    var layerComps = target.layerComps;
    var desc = { list: [] };
    for (var _i = 0, _a = layerComps.list; _i < _a.length; _i++) {
      var item = _a[_i];
      var t2 = {};
      t2._classID = "Comp";
      t2["Nm  "] = item.name;
      if ("comment" in item)
        t2.comment = item.comment;
      t2.compID = item.id;
      t2.capturedInfo = item.capturedInfo;
      desc.list.push(t2);
    }
    if ("lastApplied" in layerComps)
      desc.lastAppliedComp = layerComps.lastApplied;
    writeVersionAndDescriptor(writer, "", "CompList", desc);
  }
);
var onionSkinsBlendModes = [
  "normal",
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  "multiply",
  "screen",
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  "difference"
];
addHandler$1(
  1078,
  // Onion Skins
  function(target) {
    return target.onionSkins !== void 0;
  },
  function(reader, target) {
    var desc = readVersionAndDescriptor(reader);
    target.onionSkins = {
      enabled: desc.enab,
      framesBefore: desc.numBefore,
      framesAfter: desc.numAfter,
      frameSpacing: desc.Spcn,
      minOpacity: desc.minOpacity / 100,
      maxOpacity: desc.maxOpacity / 100,
      blendMode: onionSkinsBlendModes[desc.BlnM] || "normal"
    };
  },
  function(writer, target) {
    var onionSkins = target.onionSkins;
    var desc = {
      Vrsn: 1,
      enab: onionSkins.enabled,
      numBefore: onionSkins.framesBefore,
      numAfter: onionSkins.framesAfter,
      Spcn: onionSkins.frameSpacing,
      minOpacity: onionSkins.minOpacity * 100 | 0,
      maxOpacity: onionSkins.maxOpacity * 100 | 0,
      BlnM: Math.max(0, onionSkinsBlendModes.indexOf(onionSkins.blendMode))
    };
    writeVersionAndDescriptor(writer, "", "null", desc);
  }
);
addHandler$1(
  1075,
  // Timeline Information
  function(target) {
    return target.timelineInformation !== void 0;
  },
  function(reader, target) {
    var _a, _b;
    var desc = readVersionAndDescriptor(reader);
    target.timelineInformation = {
      enabled: desc.enab,
      frameStep: frac(desc.frameStep),
      frameRate: desc.frameRate,
      time: frac(desc.time),
      duration: frac(desc.duration),
      workInTime: frac(desc.workInTime),
      workOutTime: frac(desc.workOutTime),
      repeats: desc.LCnt,
      hasMotion: desc.hasMotion,
      globalTracks: parseTrackList(desc.globalTrackList, !!reader.logMissingFeatures)
    };
    if ((_b = (_a = desc.audioClipGroupList) === null || _a === void 0 ? void 0 : _a.audioClipGroupList) === null || _b === void 0 ? void 0 : _b.length) {
      target.timelineInformation.audioClipGroups = desc.audioClipGroupList.audioClipGroupList.map(function(g2) {
        return {
          id: g2.groupID,
          muted: g2.muted,
          audioClips: g2.audioClipList.map(function(_a2) {
            var clipID = _a2.clipID, timeScope = _a2.timeScope, muted = _a2.muted, audioLevel = _a2.audioLevel, frameReader = _a2.frameReader;
            return {
              id: clipID,
              start: frac(timeScope.Strt),
              duration: frac(timeScope.duration),
              inTime: frac(timeScope.inTime),
              outTime: frac(timeScope.outTime),
              muted,
              audioLevel,
              frameReader: {
                type: frameReader.frameReaderType,
                mediaDescriptor: frameReader.mediaDescriptor,
                link: {
                  name: frameReader["Lnk "]["Nm  "],
                  fullPath: frameReader["Lnk "].fullPath,
                  relativePath: frameReader["Lnk "].relPath
                }
              }
            };
          })
        };
      });
    }
  },
  function(writer, target) {
    var _a;
    var timeline = target.timelineInformation;
    var desc = {
      Vrsn: 1,
      enab: timeline.enabled,
      frameStep: timeline.frameStep,
      frameRate: timeline.frameRate,
      time: timeline.time,
      duration: timeline.duration,
      workInTime: timeline.workInTime,
      workOutTime: timeline.workOutTime,
      LCnt: timeline.repeats,
      globalTrackList: serializeTrackList(timeline.globalTracks),
      audioClipGroupList: {
        audioClipGroupList: (_a = timeline.audioClipGroups) === null || _a === void 0 ? void 0 : _a.map(function(a2) {
          return {
            groupID: a2.id,
            muted: a2.muted,
            audioClipList: a2.audioClips.map(function(c2) {
              return {
                clipID: c2.id,
                timeScope: {
                  Vrsn: 1,
                  Strt: c2.start,
                  duration: c2.duration,
                  inTime: c2.inTime,
                  outTime: c2.outTime
                },
                frameReader: {
                  frameReaderType: c2.frameReader.type,
                  descVersion: 1,
                  "Lnk ": {
                    descVersion: 1,
                    "Nm  ": c2.frameReader.link.name,
                    fullPath: c2.frameReader.link.fullPath,
                    relPath: c2.frameReader.link.relativePath
                  },
                  mediaDescriptor: c2.frameReader.mediaDescriptor
                },
                muted: c2.muted,
                audioLevel: c2.audioLevel
              };
            })
          };
        })
      },
      hasMotion: timeline.hasMotion
    };
    writeVersionAndDescriptor(writer, "", "null", desc, "anim");
  }
);
addHandler$1(
  1076,
  // Sheet Disclosure
  function(target) {
    return target.sheetDisclosure !== void 0;
  },
  function(reader, target) {
    var desc = readVersionAndDescriptor(reader);
    target.sheetDisclosure = {};
    if (desc.sheetTimelineOptions) {
      target.sheetDisclosure.sheetTimelineOptions = desc.sheetTimelineOptions.map(function(o) {
        return {
          sheetID: o.sheetID,
          sheetDisclosed: o.sheetDisclosed,
          lightsDisclosed: o.lightsDisclosed,
          meshesDisclosed: o.meshesDisclosed,
          materialsDisclosed: o.materialsDisclosed
        };
      });
    }
  },
  function(writer, target) {
    var disclosure = target.sheetDisclosure;
    var desc = { Vrsn: 1 };
    if (disclosure.sheetTimelineOptions) {
      desc.sheetTimelineOptions = disclosure.sheetTimelineOptions.map(function(d2) {
        return {
          Vrsn: 2,
          sheetID: d2.sheetID,
          sheetDisclosed: d2.sheetDisclosed,
          lightsDisclosed: d2.lightsDisclosed,
          meshesDisclosed: d2.meshesDisclosed,
          materialsDisclosed: d2.materialsDisclosed
        };
      });
    }
    writeVersionAndDescriptor(writer, "", "null", desc);
  }
);
addHandler$1(
  1054,
  // URL List
  function(target) {
    return target.urlsList !== void 0;
  },
  function(reader, target) {
    var count = readUint32(reader);
    target.urlsList = [];
    for (var i2 = 0; i2 < count; i2++) {
      var long = readSignature(reader);
      if (long !== "slic" && reader.throwForMissingFeatures)
        throw new Error("Unknown long");
      var id = readUint32(reader);
      var url = readUnicodeString(reader);
      target.urlsList.push({ id, url, ref: "slice" });
    }
  },
  function(writer, target) {
    var list = target.urlsList;
    writeUint32(writer, list.length);
    for (var i2 = 0; i2 < list.length; i2++) {
      writeSignature(writer, "slic");
      writeUint32(writer, list[i2].id);
      writeUnicodeString(writer, list[i2].url);
    }
  }
);
function boundsToBounds(bounds) {
  return { "Top ": bounds.top, Left: bounds.left, Btom: bounds.bottom, Rght: bounds.right };
}
function boundsFromBounds(bounds) {
  return { top: bounds["Top "], left: bounds.Left, bottom: bounds.Btom, right: bounds.Rght };
}
function clamped(array, index) {
  return array[Math.max(0, Math.min(array.length - 1, index))];
}
var sliceOrigins = ["autoGenerated", "layer", "userGenerated"];
var sliceTypes = ["noImage", "image"];
var sliceAlignments = ["default"];
addHandler$1(
  1050,
  // Slices
  function(target) {
    return target.slices ? target.slices.length : 0;
  },
  function(reader, target) {
    var version2 = readUint32(reader);
    if (version2 === 6) {
      if (!target.slices)
        target.slices = [];
      var top_1 = readInt32(reader);
      var left = readInt32(reader);
      var bottom = readInt32(reader);
      var right = readInt32(reader);
      var groupName = readUnicodeString(reader);
      var count = readUint32(reader);
      target.slices.push({ bounds: { top: top_1, left, bottom, right }, groupName, slices: [] });
      var slices_1 = target.slices[target.slices.length - 1].slices;
      for (var i2 = 0; i2 < count; i2++) {
        var id = readUint32(reader);
        var groupId = readUint32(reader);
        var origin_1 = clamped(sliceOrigins, readUint32(reader));
        var associatedLayerId = origin_1 == "layer" ? readUint32(reader) : 0;
        var name_3 = readUnicodeString(reader);
        var type = clamped(sliceTypes, readUint32(reader));
        var left_1 = readInt32(reader);
        var top_2 = readInt32(reader);
        var right_1 = readInt32(reader);
        var bottom_1 = readInt32(reader);
        var url = readUnicodeString(reader);
        var target_1 = readUnicodeString(reader);
        var message = readUnicodeString(reader);
        var altTag = readUnicodeString(reader);
        var cellTextIsHTML = !!readUint8(reader);
        var cellText = readUnicodeString(reader);
        var horizontalAlignment = clamped(sliceAlignments, readUint32(reader));
        var verticalAlignment = clamped(sliceAlignments, readUint32(reader));
        var a2 = readUint8(reader);
        var r = readUint8(reader);
        var g2 = readUint8(reader);
        var b2 = readUint8(reader);
        var backgroundColorType = a2 + r + g2 + b2 === 0 ? "none" : a2 === 0 ? "matte" : "color";
        slices_1.push({
          id,
          groupId,
          origin: origin_1,
          associatedLayerId,
          name: name_3,
          target: target_1,
          message,
          altTag,
          cellTextIsHTML,
          cellText,
          horizontalAlignment,
          verticalAlignment,
          type,
          url,
          bounds: { top: top_2, left: left_1, bottom: bottom_1, right: right_1 },
          backgroundColorType,
          backgroundColor: { r, g: g2, b: b2, a: a2 }
        });
      }
      var desc = readVersionAndDescriptor(reader);
      desc.slices.forEach(function(d2) {
        var slice = slices_1.find(function(s2) {
          return d2.sliceID == s2.id;
        });
        if (slice) {
          slice.topOutset = d2.topOutset;
          slice.leftOutset = d2.leftOutset;
          slice.bottomOutset = d2.bottomOutset;
          slice.rightOutset = d2.rightOutset;
        }
      });
    } else if (version2 === 7 || version2 === 8) {
      var desc = readVersionAndDescriptor(reader);
      if (!target.slices)
        target.slices = [];
      target.slices.push({
        groupName: desc.baseName,
        bounds: boundsFromBounds(desc.bounds),
        slices: desc.slices.map(function(s2) {
          return __assign$5(__assign$5({}, s2["Nm  "] ? { name: s2["Nm  "] } : {}), { id: s2.sliceID, groupId: s2.groupID, associatedLayerId: 0, origin: ESliceOrigin.decode(s2.origin), type: ESliceType.decode(s2.Type), bounds: boundsFromBounds(s2.bounds), url: s2.url, target: s2.null, message: s2.Msge, altTag: s2.altTag, cellTextIsHTML: s2.cellTextIsHTML, cellText: s2.cellText, horizontalAlignment: ESliceHorzAlign.decode(s2.horzAlign), verticalAlignment: ESliceVertAlign.decode(s2.vertAlign), backgroundColorType: ESliceBGColorType.decode(s2.bgColorType), backgroundColor: s2.bgColor ? { r: s2.bgColor["Rd  "], g: s2.bgColor["Grn "], b: s2.bgColor["Bl  "], a: s2.bgColor.alpha } : { r: 0, g: 0, b: 0, a: 0 }, topOutset: s2.topOutset || 0, leftOutset: s2.leftOutset || 0, bottomOutset: s2.bottomOutset || 0, rightOutset: s2.rightOutset || 0 });
        })
      });
    } else {
      throw new Error("Invalid slices version (".concat(version2, ")"));
    }
  },
  function(writer, target, index) {
    var _a = target.slices[index], bounds = _a.bounds, groupName = _a.groupName, slices = _a.slices;
    writeUint32(writer, 6);
    writeInt32(writer, bounds.top);
    writeInt32(writer, bounds.left);
    writeInt32(writer, bounds.bottom);
    writeInt32(writer, bounds.right);
    writeUnicodeString(writer, groupName);
    writeUint32(writer, slices.length);
    for (var i2 = 0; i2 < slices.length; i2++) {
      var slice = slices[i2];
      var _b = slice.backgroundColor, a2 = _b.a, r = _b.r, g2 = _b.g, b2 = _b.b;
      if (slice.backgroundColorType === "none") {
        a2 = r = g2 = b2 = 0;
      } else if (slice.backgroundColorType === "matte") {
        a2 = 0;
        r = g2 = b2 = 255;
      }
      writeUint32(writer, slice.id);
      writeUint32(writer, slice.groupId);
      writeUint32(writer, sliceOrigins.indexOf(slice.origin));
      if (slice.origin === "layer")
        writeUint32(writer, slice.associatedLayerId);
      writeUnicodeString(writer, slice.name || "");
      writeUint32(writer, sliceTypes.indexOf(slice.type));
      writeInt32(writer, slice.bounds.left);
      writeInt32(writer, slice.bounds.top);
      writeInt32(writer, slice.bounds.right);
      writeInt32(writer, slice.bounds.bottom);
      writeUnicodeString(writer, slice.url);
      writeUnicodeString(writer, slice.target);
      writeUnicodeString(writer, slice.message);
      writeUnicodeString(writer, slice.altTag);
      writeUint8(writer, slice.cellTextIsHTML ? 1 : 0);
      writeUnicodeString(writer, slice.cellText);
      writeUint32(writer, sliceAlignments.indexOf(slice.horizontalAlignment));
      writeUint32(writer, sliceAlignments.indexOf(slice.verticalAlignment));
      writeUint8(writer, a2);
      writeUint8(writer, r);
      writeUint8(writer, g2);
      writeUint8(writer, b2);
    }
    var desc = {
      bounds: boundsToBounds(bounds),
      slices: []
    };
    slices.forEach(function(s2) {
      var slice2 = __assign$5(__assign$5({ sliceID: s2.id, groupID: s2.groupId, origin: ESliceOrigin.encode(s2.origin), Type: ESliceType.encode(s2.type), bounds: boundsToBounds(s2.bounds) }, s2.name ? { "Nm  ": s2.name } : {}), { url: s2.url, null: s2.target, Msge: s2.message, altTag: s2.altTag, cellTextIsHTML: s2.cellTextIsHTML, cellText: s2.cellText, horzAlign: ESliceHorzAlign.encode(s2.horizontalAlignment), vertAlign: ESliceVertAlign.encode(s2.verticalAlignment), bgColorType: ESliceBGColorType.encode(s2.backgroundColorType) });
      if (s2.backgroundColorType === "color") {
        var _a2 = s2.backgroundColor, r2 = _a2.r, g3 = _a2.g, b3 = _a2.b, a3 = _a2.a;
        slice2.bgColor = { "Rd  ": r2, "Grn ": g3, "Bl  ": b3, alpha: a3 };
      }
      slice2.topOutset = s2.topOutset || 0;
      slice2.leftOutset = s2.leftOutset || 0;
      slice2.bottomOutset = s2.bottomOutset || 0;
      slice2.rightOutset = s2.rightOutset || 0;
      desc.slices.push(slice2);
    });
    writeVersionAndDescriptor(writer, "", "null", desc, "slices");
  }
);
addHandler$1(1064, function(target) {
  return target.pixelAspectRatio !== void 0;
}, function(reader, target) {
  if (readUint32(reader) > 2)
    throw new Error("Invalid pixelAspectRatio version");
  target.pixelAspectRatio = { aspect: readFloat64(reader) };
}, function(writer, target) {
  writeUint32(writer, 2);
  writeFloat64(writer, target.pixelAspectRatio.aspect);
});
addHandler$1(1041, function(target) {
  return target.iccUntaggedProfile !== void 0;
}, function(reader, target) {
  target.iccUntaggedProfile = !!readUint8(reader);
}, function(writer, target) {
  writeUint8(writer, target.iccUntaggedProfile ? 1 : 0);
});
addHandler$1(1044, function(target) {
  return target.idsSeedNumber !== void 0;
}, function(reader, target) {
  return target.idsSeedNumber = readUint32(reader);
}, function(writer, target) {
  return writeUint32(writer, target.idsSeedNumber);
});
addHandler$1(1036, function(target) {
  return target.thumbnail !== void 0 || target.thumbnailRaw !== void 0;
}, function(reader, target, left) {
  var format2 = readUint32(reader);
  var width = readUint32(reader);
  var height = readUint32(reader);
  readUint32(reader);
  readUint32(reader);
  readUint32(reader);
  var bitsPerPixel = readUint16(reader);
  var planes = readUint16(reader);
  if (format2 !== 1 || bitsPerPixel !== 24 || planes !== 1) {
    reader.logMissingFeatures && reader.log("Invalid thumbnail data (format: ".concat(format2, ", bitsPerPixel: ").concat(bitsPerPixel, ", planes: ").concat(planes, ")"));
    skipBytes(reader, left());
    return;
  }
  var size = left();
  var data3 = readBytes(reader, size);
  if (reader.useRawThumbnail) {
    target.thumbnailRaw = { width, height, data: data3 };
  } else if (data3.byteLength) {
    target.thumbnail = createCanvasFromData(data3);
  }
}, function(writer, target) {
  var _a;
  var width = 0;
  var height = 0;
  var data3 = new Uint8Array(0);
  if (target.thumbnailRaw) {
    width = target.thumbnailRaw.width;
    height = target.thumbnailRaw.height;
    data3 = target.thumbnailRaw.data;
  } else {
    try {
      var dataUrl = (_a = target.thumbnail.toDataURL("image/jpeg", 1)) === null || _a === void 0 ? void 0 : _a.substring("data:image/jpeg;base64,".length);
      if (dataUrl) {
        data3 = base64JsExports.toByteArray(dataUrl);
        width = target.thumbnail.width;
        height = target.thumbnail.height;
      }
    } catch (_b) {
    }
  }
  var bitsPerPixel = 24;
  var widthBytes = Math.floor((width * bitsPerPixel + 31) / 32) * 4;
  var planes = 1;
  var totalSize = widthBytes * height * planes;
  var sizeAfterCompression = data3.length;
  writeUint32(writer, 1);
  writeUint32(writer, width);
  writeUint32(writer, height);
  writeUint32(writer, widthBytes);
  writeUint32(writer, totalSize);
  writeUint32(writer, sizeAfterCompression);
  writeUint16(writer, bitsPerPixel);
  writeUint16(writer, planes);
  writeBytes(writer, data3);
});
addHandler$1(1057, function(target) {
  return target.versionInfo !== void 0;
}, function(reader, target, left) {
  var version2 = readUint32(reader);
  if (version2 !== 1)
    throw new Error("Invalid versionInfo version");
  target.versionInfo = {
    hasRealMergedData: !!readUint8(reader),
    writerName: readUnicodeString(reader),
    readerName: readUnicodeString(reader),
    fileVersion: readUint32(reader)
  };
  skipBytes(reader, left());
}, function(writer, target) {
  var versionInfo = target.versionInfo;
  writeUint32(writer, 1);
  writeUint8(writer, versionInfo.hasRealMergedData ? 1 : 0);
  writeUnicodeString(writer, versionInfo.writerName);
  writeUnicodeString(writer, versionInfo.readerName);
  writeUint32(writer, versionInfo.fileVersion);
});
addHandler$1(7e3, function(target) {
  return target.imageReadyVariables !== void 0;
}, function(reader, target, left) {
  target.imageReadyVariables = readUtf8String(reader, left());
}, function(writer, target) {
  writeUtf8String(writer, target.imageReadyVariables);
});
addHandler$1(7001, function(target) {
  return target.imageReadyDataSets !== void 0;
}, function(reader, target, left) {
  target.imageReadyDataSets = readUtf8String(reader, left());
}, function(writer, target) {
  writeUtf8String(writer, target.imageReadyDataSets);
});
addHandler$1(1088, function(target) {
  return target.pathSelectionState !== void 0;
}, function(reader, target, _left) {
  var desc = readVersionAndDescriptor(reader);
  target.pathSelectionState = desc["null"];
}, function(writer, target) {
  var desc = { "null": target.pathSelectionState };
  writeVersionAndDescriptor(writer, "", "null", desc);
});
var FrmD = createEnum("FrmD", "", {
  auto: "Auto",
  none: "None",
  dispose: "Disp"
});
addHandler$1(
  4e3,
  // Plug-In resource(s)
  function(target) {
    return target.animations !== void 0;
  },
  function(reader, target, left) {
    var key = readSignature(reader);
    if (key === "mani") {
      checkSignature(reader, "IRFR");
      readSection(reader, 1, function(left2) {
        var _loop_1 = function() {
          checkSignature(reader, "8BIM");
          var key_1 = readSignature(reader);
          readSection(reader, 1, function(left3) {
            if (key_1 === "AnDs") {
              var desc = readVersionAndDescriptor(reader);
              target.animations = {
                // desc.AFSt ???
                frames: desc.FrIn.map(function(x2) {
                  return {
                    id: x2.FrID,
                    delay: (x2.FrDl || 0) / 100,
                    dispose: x2.FrDs ? FrmD.decode(x2.FrDs) : "auto"
                    // missing == auto
                    // x.FrGA ???
                  };
                }),
                animations: desc.FSts.map(function(x2) {
                  return {
                    id: x2.FsID,
                    frames: x2.FsFr,
                    repeats: x2.LCnt,
                    activeFrame: x2.AFrm || 0
                  };
                })
              };
            } else if (key_1 === "Roll") {
              var bytes2 = readBytes(reader, left3());
              reader.logDevFeatures && reader.log("#4000 Roll", bytes2);
            } else {
              reader.logMissingFeatures && reader.log("Unhandled subsection in #4000", key_1);
            }
          });
        };
        while (left2() > 0) {
          _loop_1();
        }
      });
    } else if (key === "mopt") {
      var bytes = readBytes(reader, left());
      reader.logDevFeatures && reader.log("#4000 mopt", bytes);
    } else {
      reader.logMissingFeatures && reader.log("Unhandled key in #4000:", key);
    }
  },
  function(writer, target) {
    if (target.animations) {
      writeSignature(writer, "mani");
      writeSignature(writer, "IRFR");
      writeSection(writer, 1, function() {
        writeSignature(writer, "8BIM");
        writeSignature(writer, "AnDs");
        writeSection(writer, 1, function() {
          var desc = {
            // AFSt: 0, // ???
            FrIn: [],
            FSts: []
          };
          for (var i2 = 0; i2 < target.animations.frames.length; i2++) {
            var f2 = target.animations.frames[i2];
            var frame = {
              FrID: f2.id
            };
            if (f2.delay)
              frame.FrDl = f2.delay * 100 | 0;
            frame.FrDs = FrmD.encode(f2.dispose);
            desc.FrIn.push(frame);
          }
          for (var i2 = 0; i2 < target.animations.animations.length; i2++) {
            var a2 = target.animations.animations[i2];
            var anim = {
              FsID: a2.id,
              AFrm: a2.activeFrame | 0,
              FsFr: a2.frames,
              LCnt: a2.repeats | 0
            };
            desc.FSts.push(anim);
          }
          writeVersionAndDescriptor(writer, "", "null", desc);
        });
      });
    }
  }
);
(function(s2, e) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
});
function setupGrayscale(data3) {
  var size = data3.width * data3.height * 4;
  for (var i2 = 0; i2 < size; i2 += 4) {
    var c2 = data3.data[i2];
    data3.data[i2 + 1] = c2;
    data3.data[i2 + 2] = c2;
  }
}
function warnOrThrow(reader, message) {
  if (reader.strict)
    throw new Error(message);
  if (reader.debug)
    reader.log(message);
}
function readUint8(reader) {
  reader.offset += 1;
  return reader.view.getUint8(reader.offset - 1);
}
function readInt16(reader) {
  reader.offset += 2;
  return reader.view.getInt16(reader.offset - 2, false);
}
function readUint16(reader) {
  reader.offset += 2;
  return reader.view.getUint16(reader.offset - 2, false);
}
function readUint16LE(reader) {
  reader.offset += 2;
  return reader.view.getUint16(reader.offset - 2, true);
}
function readInt32(reader) {
  reader.offset += 4;
  return reader.view.getInt32(reader.offset - 4, false);
}
function readInt32LE(reader) {
  reader.offset += 4;
  return reader.view.getInt32(reader.offset - 4, true);
}
function readUint32(reader) {
  reader.offset += 4;
  return reader.view.getUint32(reader.offset - 4, false);
}
function readFloat32(reader) {
  reader.offset += 4;
  return reader.view.getFloat32(reader.offset - 4, false);
}
function readFloat64(reader) {
  reader.offset += 8;
  return reader.view.getFloat64(reader.offset - 8, false);
}
function readFixedPoint32(reader) {
  return readInt32(reader) / (1 << 16);
}
function readFixedPointPath32(reader) {
  return readInt32(reader) / (1 << 24);
}
function readBytes(reader, length) {
  var start = reader.view.byteOffset + reader.offset;
  reader.offset += length;
  if (start + length > reader.view.buffer.byteLength) {
    warnOrThrow(reader, "Reading bytes exceeding buffer length");
    if (length > 100 * 1024 * 1024)
      throw new Error("Reading past end of file");
    var result = new Uint8Array(length);
    var len = Math.min(length, reader.view.byteLength - start);
    if (len > 0)
      result.set(new Uint8Array(reader.view.buffer, start, len));
    return result;
  } else {
    return new Uint8Array(reader.view.buffer, start, length);
  }
}
function readSignature(reader) {
  return readShortString(reader, 4);
}
function validSignatureAt(reader, offset) {
  var sig = String.fromCharCode(reader.view.getUint8(offset)) + String.fromCharCode(reader.view.getUint8(offset + 1)) + String.fromCharCode(reader.view.getUint8(offset + 2)) + String.fromCharCode(reader.view.getUint8(offset + 3));
  return sig == "8BIM" || sig == "8B64";
}
function readPascalString(reader, padTo) {
  var length = readUint8(reader);
  var text = length ? readShortString(reader, length) : "";
  while (++length % padTo) {
    reader.offset++;
  }
  return text;
}
function readUnicodeString(reader) {
  var length = readUint32(reader);
  return readUnicodeStringWithLength(reader, length);
}
function readUnicodeStringWithLength(reader, length) {
  var text = "";
  while (length--) {
    var value = readUint16(reader);
    if (value || length > 0) {
      text += String.fromCharCode(value);
    }
  }
  return text;
}
function readUnicodeStringWithLengthLE(reader, length) {
  var text = "";
  while (length--) {
    var value = readUint16LE(reader);
    if (value || length > 0) {
      text += String.fromCharCode(value);
    }
  }
  return text;
}
function readAsciiString(reader, length) {
  var text = "";
  while (length--) {
    text += String.fromCharCode(readUint8(reader));
  }
  return text;
}
function skipBytes(reader, count) {
  reader.offset += count;
}
function checkSignature(reader, a2, b2) {
  var offset = reader.offset;
  var signature = readSignature(reader);
  if (signature !== a2 && signature !== b2) {
    throw new Error("Invalid signature: '".concat(signature, "' at 0x").concat(offset.toString(16)));
  }
}
function readShortString(reader, length) {
  var buffer = readBytes(reader, length);
  var result = "";
  for (var i2 = 0; i2 < buffer.length; i2++) {
    result += String.fromCharCode(buffer[i2]);
  }
  return result;
}
function readLayerInfo(reader, psd, imageResources) {
  var _a, _b;
  var _c = imageResources.layersGroup, layersGroup = _c === void 0 ? [] : _c, _d = imageResources.layerGroupsEnabledId, layerGroupsEnabledId = _d === void 0 ? [] : _d;
  var layerCount = readInt16(reader);
  if (layerCount < 0) {
    reader.globalAlpha = true;
    layerCount = -layerCount;
  }
  var layers = [];
  var layerChannels = [];
  for (var i2 = 0; i2 < layerCount; i2++) {
    var _e = readLayerRecord(reader, psd, imageResources), layer = _e.layer, channels2 = _e.channels;
    if (layersGroup[i2] !== void 0)
      layer.linkGroup = layersGroup[i2];
    if (layerGroupsEnabledId[i2] !== void 0)
      layer.linkGroupEnabled = !!layerGroupsEnabledId[i2];
    layers.push(layer);
    layerChannels.push(channels2);
  }
  if (!reader.skipLayerImageData) {
    for (var i2 = 0; i2 < layerCount; i2++) {
      readLayerChannelImageData(reader, psd, layers[i2], layerChannels[i2]);
    }
  }
  if (!psd.children)
    psd.children = [];
  var stack2 = [psd];
  for (var i2 = layers.length - 1; i2 >= 0; i2--) {
    var l2 = layers[i2];
    var type = l2.sectionDivider ? l2.sectionDivider.type : 0;
    if (type === 1 || type === 2) {
      l2.opened = type === 1;
      l2.children = [];
      if ((_a = l2.sectionDivider) === null || _a === void 0 ? void 0 : _a.key) {
        l2.blendMode = (_b = toBlendMode[l2.sectionDivider.key]) !== null && _b !== void 0 ? _b : l2.blendMode;
      }
      stack2[stack2.length - 1].children.unshift(l2);
      stack2.push(l2);
    } else if (type === 3) {
      stack2.pop();
    } else {
      stack2[stack2.length - 1].children.unshift(l2);
    }
  }
}
function readLayerRecord(reader, psd, imageResources) {
  var layer = {};
  layer.top = readInt32(reader);
  layer.left = readInt32(reader);
  layer.bottom = readInt32(reader);
  layer.right = readInt32(reader);
  var channelCount = readUint16(reader);
  var channels2 = [];
  for (var i2 = 0; i2 < channelCount; i2++) {
    var id = readInt16(reader);
    var length_1 = readUint32(reader);
    if (reader.large) {
      if (length_1 !== 0)
        throw new Error("Sizes larger than 4GB are not supported");
      length_1 = readUint32(reader);
    }
    channels2.push({ id, length: length_1 });
  }
  checkSignature(reader, "8BIM");
  var blendMode = readSignature(reader);
  if (!toBlendMode[blendMode])
    throw new Error("Invalid blend mode: '".concat(blendMode, "'"));
  layer.blendMode = toBlendMode[blendMode];
  layer.opacity = readUint8(reader) / 255;
  layer.clipping = readUint8(reader) === 1;
  var flags = readUint8(reader);
  layer.transparencyProtected = (flags & 1) !== 0;
  layer.hidden = (flags & 2) !== 0;
  if (flags & 32)
    layer.effectsOpen = true;
  skipBytes(reader, 1);
  readSection(reader, 1, function(left) {
    readLayerMaskData(reader, layer);
    var blendingRanges = readLayerBlendingRanges(reader);
    if (blendingRanges)
      layer.blendingRanges = blendingRanges;
    layer.name = readPascalString(reader, 1);
    while (left() > 4 && !validSignatureAt(reader, reader.offset))
      reader.offset++;
    while (left() >= 12)
      readAdditionalLayerInfo(reader, layer, psd, imageResources);
    skipBytes(reader, left());
  });
  return { layer, channels: channels2 };
}
function readLayerMaskData(reader, layer) {
  return readSection(reader, 1, function(left) {
    if (!left())
      return void 0;
    var mask3 = {};
    layer.mask = mask3;
    mask3.top = readInt32(reader);
    mask3.left = readInt32(reader);
    mask3.bottom = readInt32(reader);
    mask3.right = readInt32(reader);
    mask3.defaultColor = readUint8(reader);
    var flags = readUint8(reader);
    mask3.positionRelativeToLayer = (flags & 1) !== 0;
    mask3.disabled = (flags & 2) !== 0;
    mask3.fromVectorData = (flags & 8) !== 0;
    if (left() >= 18) {
      var realMask = {};
      layer.realMask = realMask;
      var realFlags = readUint8(reader);
      realMask.positionRelativeToLayer = (realFlags & 1) !== 0;
      realMask.disabled = (realFlags & 2) !== 0;
      realMask.fromVectorData = (realFlags & 8) !== 0;
      realMask.defaultColor = readUint8(reader);
      realMask.top = readInt32(reader);
      realMask.left = readInt32(reader);
      realMask.bottom = readInt32(reader);
      realMask.right = readInt32(reader);
    }
    if (flags & 16) {
      var params = readUint8(reader);
      if (params & 1)
        mask3.userMaskDensity = readUint8(reader) / 255;
      if (params & 2)
        mask3.userMaskFeather = readFloat64(reader);
      if (params & 4)
        mask3.vectorMaskDensity = readUint8(reader) / 255;
      if (params & 8)
        mask3.vectorMaskFeather = readFloat64(reader);
    }
    skipBytes(reader, left());
  });
}
function readBlendingRange(reader) {
  return [readUint8(reader), readUint8(reader), readUint8(reader), readUint8(reader)];
}
function readLayerBlendingRanges(reader) {
  return readSection(reader, 1, function(left) {
    var compositeGrayBlendSource = readBlendingRange(reader);
    var compositeGraphBlendDestinationRange = readBlendingRange(reader);
    var ranges = [];
    while (left() > 0) {
      var sourceRange = readBlendingRange(reader);
      var destRange = readBlendingRange(reader);
      ranges.push({ sourceRange, destRange });
    }
    return { compositeGrayBlendSource, compositeGraphBlendDestinationRange, ranges };
  });
}
function readLayerChannelImageData(reader, psd, layer, channels2) {
  var _a, _b, _c, _d;
  var layerWidth = (layer.right || 0) - (layer.left || 0);
  var layerHeight = (layer.bottom || 0) - (layer.top || 0);
  var cmyk = psd.colorMode === 4;
  var imageData;
  if (layerWidth && layerHeight) {
    if (cmyk) {
      if (psd.bitsPerChannel !== 8)
        throw new Error("bitsPerChannel Not supproted");
      imageData = { width: layerWidth, height: layerHeight, data: new Uint8ClampedArray(layerWidth * layerHeight * 5) };
      for (var p2 = 4; p2 < imageData.data.byteLength; p2 += 5)
        imageData.data[p2] = 255;
    } else {
      imageData = createImageDataBitDepth(layerWidth, layerHeight, (_a = psd.bitsPerChannel) !== null && _a !== void 0 ? _a : 8);
      resetImageData(imageData);
    }
  }
  for (var _i = 0, channels_1 = channels2; _i < channels_1.length; _i++) {
    var channel = channels_1[_i];
    if (channel.length === 0)
      continue;
    if (channel.length < 2)
      throw new Error("Invalid channel length");
    var start = reader.offset;
    var compression = readUint16(reader);
    if (compression > 3) {
      reader.offset -= 1;
      compression = readUint16(reader);
    }
    if (compression > 3) {
      reader.offset -= 3;
      compression = readUint16(reader);
    }
    if (compression > 3)
      throw new Error("Invalid compression: ".concat(compression));
    if (channel.id === -2 || channel.id === -3) {
      var mask3 = channel.id === -2 ? layer.mask : layer.realMask;
      if (!mask3)
        throw new Error("Missing layer ".concat(channel.id === -2 ? "mask" : "real mask", " data"));
      var maskWidth = (mask3.right || 0) - (mask3.left || 0);
      var maskHeight = (mask3.bottom || 0) - (mask3.top || 0);
      if (maskWidth < 0 || maskHeight < 0 || maskWidth > 3e4 || maskHeight > 3e4)
        throw new Error("Invalid mask size");
      if (maskWidth && maskHeight) {
        var maskData = createImageDataBitDepth(maskWidth, maskHeight, (_b = psd.bitsPerChannel) !== null && _b !== void 0 ? _b : 8);
        resetImageData(maskData);
        reader.offset;
        readData(reader, channel.length, maskData, compression, maskWidth, maskHeight, (_c = psd.bitsPerChannel) !== null && _c !== void 0 ? _c : 8, 0, reader.large, 4);
        setupGrayscale(maskData);
        if (reader.useImageData) {
          mask3.imageData = maskData;
        } else {
          mask3.canvas = imageDataToCanvas(maskData);
        }
      }
    } else {
      var offset = offsetForChannel(channel.id, cmyk);
      var targetData = imageData;
      if (offset < 0) {
        targetData = void 0;
        if (reader.throwForMissingFeatures) {
          throw new Error("Channel not supported: ".concat(channel.id));
        }
      }
      readData(reader, channel.length, targetData, compression, layerWidth, layerHeight, (_d = psd.bitsPerChannel) !== null && _d !== void 0 ? _d : 8, offset, reader.large, cmyk ? 5 : 4);
      reader.offset = start + channel.length;
      if (targetData && psd.colorMode === 1) {
        setupGrayscale(targetData);
      }
    }
  }
  if (imageData) {
    if (cmyk) {
      var cmykData = imageData;
      imageData = createImageData(cmykData.width, cmykData.height);
      cmykToRgb(cmykData, imageData);
    }
    if (reader.useImageData) {
      layer.imageData = imageData;
    } else {
      layer.canvas = imageDataToCanvas(imageData);
    }
  }
}
function readData(reader, length, data3, compression, width, height, bitDepth, offset, large, step) {
  if (compression === 0) {
    readDataRaw(reader, data3, width, height, bitDepth, step, offset);
  } else if (compression === 1) {
    readDataRLE(reader, data3, width, height, bitDepth, step, [offset], large);
  } else if (compression === 2) {
    readDataZip(reader, length, data3, width, height, bitDepth, step, offset, false);
  } else if (compression === 3) {
    readDataZip(reader, length, data3, width, height, bitDepth, step, offset, true);
  } else {
    throw new Error("Invalid Compression type: ".concat(compression));
  }
}
var fixOffsets = [0, 1, -1, 2, -2, 3, -3, 4, -4];
function realignWithSignature(reader, isValid) {
  var sigOffset = reader.offset;
  var sig = "";
  for (var _i = 0, fixOffsets_1 = fixOffsets; _i < fixOffsets_1.length; _i++) {
    var offset = fixOffsets_1[_i];
    try {
      reader.offset = sigOffset + offset;
      sig = readSignature(reader);
    } catch (_a) {
    }
    if (isValid(sig))
      break;
  }
  if (!isValid(sig)) {
    throw new Error("Invalid signature: '".concat(sig, "' at 0x").concat(sigOffset.toString(16)));
  }
  return sig;
}
function isValidAdditionalInfoSignature(sig) {
  return sig === "8BIM" || sig === "8B64";
}
function readAdditionalLayerInfo(reader, target, psd, imageResources) {
  var sig = realignWithSignature(reader, isValidAdditionalInfoSignature);
  var key = readSignature(reader);
  var u64 = sig === "8B64" || reader.large && largeAdditionalInfoKeys.indexOf(key) !== -1;
  readSection(reader, 2, function(left) {
    var handler3 = infoHandlersMap[key];
    if (handler3) {
      try {
        handler3.read(reader, target, left, psd, imageResources);
      } catch (e) {
        if (reader.throwForMissingFeatures)
          throw e;
      }
    } else {
      reader.logMissingFeatures && reader.log("Unhandled additional info: ".concat(key));
      skipBytes(reader, left());
    }
    if (left()) {
      reader.logMissingFeatures && reader.log("Unread ".concat(left(), " bytes left for additional info: ").concat(key));
      skipBytes(reader, left());
    }
  }, false, u64);
}
function createImageDataBitDepth(width, height, bitDepth, channels2) {
  if (channels2 === void 0) {
    channels2 = 4;
  }
  if (bitDepth === 1 || bitDepth === 8) {
    if (channels2 === 4) {
      return createImageData(width, height);
    } else {
      return { width, height, data: new Uint8ClampedArray(width * height * channels2) };
    }
  } else if (bitDepth === 16) {
    return { width, height, data: new Uint16Array(width * height * channels2) };
  } else if (bitDepth === 32) {
    return { width, height, data: new Float32Array(width * height * channels2) };
  } else {
    throw new Error("Invalid bitDepth (".concat(bitDepth, ")"));
  }
}
function cmykToRgb(cmyk, rgb, reverseAlpha) {
  var size = rgb.width * rgb.height * 4;
  var srcData = cmyk.data;
  var dstData = rgb.data;
  for (var src = 0, dst = 0; dst < size; src += 5, dst += 4) {
    var c2 = srcData[src];
    var m2 = srcData[src + 1];
    var y2 = srcData[src + 2];
    var k2 = srcData[src + 3];
    dstData[dst] = (c2 * k2 | 0) / 255 | 0;
    dstData[dst + 1] = (m2 * k2 | 0) / 255 | 0;
    dstData[dst + 2] = (y2 * k2 | 0) / 255 | 0;
    dstData[dst + 3] = srcData[src + 4];
  }
}
function verifyCompatible(a2, b2) {
  if (a2.byteLength / a2.length !== b2.byteLength / b2.length) {
    throw new Error("Invalid array types");
  }
}
function bytesToArray(bytes, bitDepth) {
  if (bitDepth === 8) {
    return bytes;
  } else if (bitDepth === 16) {
    if (bytes.byteOffset % 2) {
      var result = new Uint16Array(bytes.byteLength / 2);
      new Uint8Array(result.buffer, result.byteOffset, result.byteLength).set(bytes);
      return result;
    } else {
      return new Uint16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2);
    }
  } else if (bitDepth === 32) {
    if (bytes.byteOffset % 4) {
      var result = new Float32Array(bytes.byteLength / 4);
      new Uint8Array(result.buffer, result.byteOffset, result.byteLength).set(bytes);
      return result;
    } else {
      return new Float32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4);
    }
  } else {
    throw new Error("Invalid bitDepth (".concat(bitDepth, ")"));
  }
}
function copyChannelToPixelData(pixelData, channel, offset, step) {
  verifyCompatible(pixelData.data, channel);
  var size = pixelData.width * pixelData.height;
  var data3 = pixelData.data;
  for (var i2 = 0, p2 = offset | 0; i2 < size; i2++, p2 = p2 + step | 0) {
    data3[p2] = channel[i2];
  }
}
function readDataRaw(reader, pixelData, width, height, bitDepth, step, offset) {
  var buffer = readBytes(reader, width * height * Math.floor(bitDepth / 8));
  if (bitDepth == 32) {
    for (var i2 = 0; i2 < buffer.byteLength; i2 += 4) {
      var a2 = buffer[i2 + 0];
      var b2 = buffer[i2 + 1];
      var c2 = buffer[i2 + 2];
      var d2 = buffer[i2 + 3];
      buffer[i2 + 0] = d2;
      buffer[i2 + 1] = c2;
      buffer[i2 + 2] = b2;
      buffer[i2 + 3] = a2;
    }
  }
  var array = bytesToArray(buffer, bitDepth);
  if (pixelData && offset < step) {
    copyChannelToPixelData(pixelData, array, offset, step);
  }
}
function decodePredicted(data3, width, height, mod) {
  for (var y2 = 0; y2 < height; y2++) {
    var offset = y2 * width;
    for (var x2 = 1, o = offset + 1; x2 < width; x2++, o++) {
      data3[o] = (data3[o - 1] + data3[o]) % mod;
    }
  }
}
function readDataZip(reader, length, pixelData, width, height, bitDepth, step, offset, prediction) {
  var compressed = readBytes(reader, length);
  var decompressed = inflate_1(compressed);
  if (pixelData && offset < step) {
    var array = bytesToArray(decompressed, bitDepth);
    if (bitDepth === 8) {
      if (prediction)
        decodePredicted(decompressed, width, height, 256);
      copyChannelToPixelData(pixelData, decompressed, offset, step);
    } else if (bitDepth === 16) {
      if (prediction)
        decodePredicted(array, width, height, 65536);
      copyChannelToPixelData(pixelData, array, offset, step);
    } else if (bitDepth === 32) {
      if (prediction)
        decodePredicted(decompressed, width * 4, height, 256);
      var di = offset;
      var dst = new Uint32Array(pixelData.data.buffer, pixelData.data.byteOffset, pixelData.data.length);
      for (var y2 = 0; y2 < height; y2++) {
        var a2 = width * 4 * y2;
        for (var x2 = 0; x2 < width; x2++, a2++, di += step) {
          var b2 = a2 + width;
          var c2 = b2 + width;
          var d2 = c2 + width;
          dst[di] = (decompressed[a2] << 24 | decompressed[b2] << 16 | decompressed[c2] << 8 | decompressed[d2]) >>> 0;
        }
      }
    } else {
      throw new Error("Invalid bitDepth");
    }
  }
}
function readDataRLE(reader, pixelData, width, height, bitDepth, step, offsets, large) {
  var data3 = pixelData && pixelData.data;
  var lengths;
  if (large) {
    lengths = new Uint32Array(offsets.length * height);
    for (var o = 0, li = 0; o < offsets.length; o++) {
      for (var y2 = 0; y2 < height; y2++, li++) {
        lengths[li] = readUint32(reader);
      }
    }
  } else {
    lengths = new Uint16Array(offsets.length * height);
    for (var o = 0, li = 0; o < offsets.length; o++) {
      for (var y2 = 0; y2 < height; y2++, li++) {
        lengths[li] = readUint16(reader);
      }
    }
  }
  if (bitDepth !== 1 && bitDepth !== 8)
    throw new Error("Invalid bit depth (".concat(bitDepth, ")"));
  var extraLimit = step - 1 | 0;
  for (var c2 = 0, li = 0; c2 < offsets.length; c2++) {
    var offset = offsets[c2] | 0;
    var extra = c2 > extraLimit || offset > extraLimit;
    if (!data3 || extra) {
      for (var y2 = 0; y2 < height; y2++, li++) {
        skipBytes(reader, lengths[li]);
      }
    } else {
      for (var y2 = 0, p2 = offset | 0; y2 < height; y2++, li++) {
        var length_2 = lengths[li];
        var buffer = readBytes(reader, length_2);
        for (var i2 = 0, x2 = 0; i2 < length_2; i2++) {
          var header = buffer[i2];
          if (header > 128) {
            var value = buffer[++i2];
            header = 256 - header | 0;
            for (var j = 0; j <= header && x2 < width; j = j + 1 | 0, x2 = x2 + 1 | 0) {
              data3[p2] = value;
              p2 = p2 + step | 0;
            }
          } else if (header < 128) {
            for (var j = 0; j <= header && x2 < width; j = j + 1 | 0, x2 = x2 + 1 | 0) {
              data3[p2] = buffer[++i2];
              p2 = p2 + step | 0;
            }
          } else ;
        }
      }
    }
  }
}
function readSection(reader, round, func, skipEmpty, eightBytes) {
  if (skipEmpty === void 0) {
    skipEmpty = true;
  }
  if (eightBytes === void 0) {
    eightBytes = false;
  }
  var length = readUint32(reader);
  if (eightBytes) {
    if (length !== 0)
      throw new Error("Sizes larger than 4GB are not supported");
    length = readUint32(reader);
  }
  if (length <= 0 && skipEmpty)
    return void 0;
  var end = reader.offset + length;
  if (end > reader.view.byteLength)
    throw new Error("Section exceeds file size");
  var result = func(function() {
    return end - reader.offset;
  });
  if (reader.offset !== end) {
    if (reader.offset > end) {
      warnOrThrow(reader, "Exceeded section limits");
    } else {
      warnOrThrow(reader, "Unread section data");
    }
  }
  while (length % round) {
    length++;
    end++;
  }
  reader.offset = end;
  return result;
}
function readColor(reader) {
  var colorSpace = readUint16(reader);
  switch (colorSpace) {
    case 0: {
      var r = readUint16(reader) / 257;
      var g2 = readUint16(reader) / 257;
      var b2 = readUint16(reader) / 257;
      skipBytes(reader, 2);
      return { r, g: g2, b: b2 };
    }
    case 1: {
      var h2 = readUint16(reader) / 65535;
      var s2 = readUint16(reader) / 65535;
      var b2 = readUint16(reader) / 65535;
      skipBytes(reader, 2);
      return { h: h2, s: s2, b: b2 };
    }
    case 2: {
      var c2 = readUint16(reader) / 257;
      var m2 = readUint16(reader) / 257;
      var y2 = readUint16(reader) / 257;
      var k2 = readUint16(reader) / 257;
      return { c: c2, m: m2, y: y2, k: k2 };
    }
    case 7: {
      var l2 = readInt16(reader) / 1e4;
      var ta = readInt16(reader);
      var tb = readInt16(reader);
      var a2 = ta < 0 ? ta / 12800 : ta / 12700;
      var b2 = tb < 0 ? tb / 12800 : tb / 12700;
      skipBytes(reader, 2);
      return { l: l2, a: a2, b: b2 };
    }
    case 8: {
      var k2 = readUint16(reader) * 255 / 1e4;
      skipBytes(reader, 6);
      return { k: k2 };
    }
    default:
      throw new Error("Invalid color space");
  }
}
var bevelStyles = [
  void 0,
  "outer bevel",
  "inner bevel",
  "emboss",
  "pillow emboss",
  "stroke emboss"
];
function readBlendMode(reader) {
  checkSignature(reader, "8BIM");
  return toBlendMode[readSignature(reader)] || "normal";
}
function writeBlendMode(writer, mode) {
  writeSignature(writer, "8BIM");
  writeSignature(writer, fromBlendMode[mode] || "norm");
}
function readFixedPoint8(reader) {
  return readUint8(reader) / 255;
}
function writeFixedPoint8(writer, value) {
  writeUint8(writer, Math.round(value * 255) | 0);
}
function readEffects(reader) {
  var version2 = readUint16(reader);
  if (version2 !== 0)
    throw new Error("Invalid effects layer version: ".concat(version2));
  var effectsCount = readUint16(reader);
  var effects = {};
  for (var i2 = 0; i2 < effectsCount; i2++) {
    checkSignature(reader, "8BIM");
    var type = readSignature(reader);
    switch (type) {
      case "cmnS": {
        var size = readUint32(reader);
        var version_1 = readUint32(reader);
        var visible = !!readUint8(reader);
        skipBytes(reader, 2);
        if (size !== 7 || version_1 !== 0 || !visible)
          throw new Error("Invalid effects common state");
        break;
      }
      case "dsdw":
      // drop shadow (see See Effects layer, drop shadow and inner shadow info)
      case "isdw": {
        var blockSize = readUint32(reader);
        var version_2 = readUint32(reader);
        if (blockSize !== 41 && blockSize !== 51)
          throw new Error("Invalid shadow size: ".concat(blockSize));
        if (version_2 !== 0 && version_2 !== 2)
          throw new Error("Invalid shadow version: ".concat(version_2));
        var size = readFixedPoint32(reader);
        readFixedPoint32(reader);
        var angle = readFixedPoint32(reader);
        var distance = readFixedPoint32(reader);
        var color = readColor(reader);
        var blendMode = readBlendMode(reader);
        var enabled = !!readUint8(reader);
        var useGlobalLight = !!readUint8(reader);
        var opacity = readFixedPoint8(reader);
        if (blockSize >= 51)
          readColor(reader);
        var shadowInfo = {
          size: { units: "Pixels", value: size },
          distance: { units: "Pixels", value: distance },
          angle,
          color,
          blendMode,
          enabled,
          useGlobalLight,
          opacity
        };
        if (type === "dsdw") {
          effects.dropShadow = [shadowInfo];
        } else {
          effects.innerShadow = [shadowInfo];
        }
        break;
      }
      case "oglw": {
        var blockSize = readUint32(reader);
        var version_3 = readUint32(reader);
        if (blockSize !== 32 && blockSize !== 42)
          throw new Error("Invalid outer glow size: ".concat(blockSize));
        if (version_3 !== 0 && version_3 !== 2)
          throw new Error("Invalid outer glow version: ".concat(version_3));
        var size = readFixedPoint32(reader);
        readFixedPoint32(reader);
        var color = readColor(reader);
        var blendMode = readBlendMode(reader);
        var enabled = !!readUint8(reader);
        var opacity = readFixedPoint8(reader);
        if (blockSize >= 42)
          readColor(reader);
        effects.outerGlow = {
          size: { units: "Pixels", value: size },
          color,
          blendMode,
          enabled,
          opacity
        };
        break;
      }
      case "iglw": {
        var blockSize = readUint32(reader);
        var version_4 = readUint32(reader);
        if (blockSize !== 32 && blockSize !== 43)
          throw new Error("Invalid inner glow size: ".concat(blockSize));
        if (version_4 !== 0 && version_4 !== 2)
          throw new Error("Invalid inner glow version: ".concat(version_4));
        var size = readFixedPoint32(reader);
        readFixedPoint32(reader);
        var color = readColor(reader);
        var blendMode = readBlendMode(reader);
        var enabled = !!readUint8(reader);
        var opacity = readFixedPoint8(reader);
        if (blockSize >= 43) {
          readUint8(reader);
          readColor(reader);
        }
        effects.innerGlow = {
          size: { units: "Pixels", value: size },
          color,
          blendMode,
          enabled,
          opacity
        };
        break;
      }
      case "bevl": {
        var blockSize = readUint32(reader);
        var version_5 = readUint32(reader);
        if (blockSize !== 58 && blockSize !== 78)
          throw new Error("Invalid bevel size: ".concat(blockSize));
        if (version_5 !== 0 && version_5 !== 2)
          throw new Error("Invalid bevel version: ".concat(version_5));
        var angle = readFixedPoint32(reader);
        var strength = readFixedPoint32(reader);
        var size = readFixedPoint32(reader);
        var highlightBlendMode = readBlendMode(reader);
        var shadowBlendMode = readBlendMode(reader);
        var highlightColor = readColor(reader);
        var shadowColor = readColor(reader);
        var style2 = bevelStyles[readUint8(reader)] || "inner bevel";
        var highlightOpacity = readFixedPoint8(reader);
        var shadowOpacity = readFixedPoint8(reader);
        var enabled = !!readUint8(reader);
        var useGlobalLight = !!readUint8(reader);
        var direction = readUint8(reader) ? "down" : "up";
        if (blockSize >= 78) {
          readColor(reader);
          readColor(reader);
        }
        effects.bevel = {
          size: { units: "Pixels", value: size },
          angle,
          strength,
          highlightBlendMode,
          shadowBlendMode,
          highlightColor,
          shadowColor,
          style: style2,
          highlightOpacity,
          shadowOpacity,
          enabled,
          useGlobalLight,
          direction
        };
        break;
      }
      case "sofi": {
        var size = readUint32(reader);
        var version_6 = readUint32(reader);
        if (size !== 34)
          throw new Error("Invalid effects solid fill info size: ".concat(size));
        if (version_6 !== 2)
          throw new Error("Invalid effects solid fill info version: ".concat(version_6));
        var blendMode = readBlendMode(reader);
        var color = readColor(reader);
        var opacity = readFixedPoint8(reader);
        var enabled = !!readUint8(reader);
        readColor(reader);
        effects.solidFill = [{ blendMode, color, opacity, enabled }];
        break;
      }
      default:
        throw new Error("Invalid effect type: '".concat(type, "'"));
    }
  }
  return effects;
}
function writeShadowInfo(writer, shadow) {
  var _a;
  writeUint32(writer, 51);
  writeUint32(writer, 2);
  writeFixedPoint32(writer, shadow.size && shadow.size.value || 0);
  writeFixedPoint32(writer, 0);
  writeFixedPoint32(writer, shadow.angle || 0);
  writeFixedPoint32(writer, shadow.distance && shadow.distance.value || 0);
  writeColor(writer, shadow.color);
  writeBlendMode(writer, shadow.blendMode);
  writeUint8(writer, shadow.enabled ? 1 : 0);
  writeUint8(writer, shadow.useGlobalLight ? 1 : 0);
  writeFixedPoint8(writer, (_a = shadow.opacity) !== null && _a !== void 0 ? _a : 1);
  writeColor(writer, shadow.color);
}
function writeEffects(writer, effects) {
  var _a, _b, _c, _d, _e, _f;
  var dropShadow = (_a = effects.dropShadow) === null || _a === void 0 ? void 0 : _a[0];
  var innerShadow = (_b = effects.innerShadow) === null || _b === void 0 ? void 0 : _b[0];
  var outerGlow = effects.outerGlow;
  var innerGlow = effects.innerGlow;
  var bevel = effects.bevel;
  var solidFill = (_c = effects.solidFill) === null || _c === void 0 ? void 0 : _c[0];
  var count = 1;
  if (dropShadow)
    count++;
  if (innerShadow)
    count++;
  if (outerGlow)
    count++;
  if (innerGlow)
    count++;
  if (bevel)
    count++;
  if (solidFill)
    count++;
  writeUint16(writer, 0);
  writeUint16(writer, count);
  writeSignature(writer, "8BIM");
  writeSignature(writer, "cmnS");
  writeUint32(writer, 7);
  writeUint32(writer, 0);
  writeUint8(writer, 1);
  writeZeros(writer, 2);
  if (dropShadow) {
    writeSignature(writer, "8BIM");
    writeSignature(writer, "dsdw");
    writeShadowInfo(writer, dropShadow);
  }
  if (innerShadow) {
    writeSignature(writer, "8BIM");
    writeSignature(writer, "isdw");
    writeShadowInfo(writer, innerShadow);
  }
  if (outerGlow) {
    writeSignature(writer, "8BIM");
    writeSignature(writer, "oglw");
    writeUint32(writer, 42);
    writeUint32(writer, 2);
    writeFixedPoint32(writer, ((_d = outerGlow.size) === null || _d === void 0 ? void 0 : _d.value) || 0);
    writeFixedPoint32(writer, 0);
    writeColor(writer, outerGlow.color);
    writeBlendMode(writer, outerGlow.blendMode);
    writeUint8(writer, outerGlow.enabled ? 1 : 0);
    writeFixedPoint8(writer, outerGlow.opacity || 0);
    writeColor(writer, outerGlow.color);
  }
  if (innerGlow) {
    writeSignature(writer, "8BIM");
    writeSignature(writer, "iglw");
    writeUint32(writer, 43);
    writeUint32(writer, 2);
    writeFixedPoint32(writer, ((_e = innerGlow.size) === null || _e === void 0 ? void 0 : _e.value) || 0);
    writeFixedPoint32(writer, 0);
    writeColor(writer, innerGlow.color);
    writeBlendMode(writer, innerGlow.blendMode);
    writeUint8(writer, innerGlow.enabled ? 1 : 0);
    writeFixedPoint8(writer, innerGlow.opacity || 0);
    writeUint8(writer, 0);
    writeColor(writer, innerGlow.color);
  }
  if (bevel) {
    writeSignature(writer, "8BIM");
    writeSignature(writer, "bevl");
    writeUint32(writer, 78);
    writeUint32(writer, 2);
    writeFixedPoint32(writer, bevel.angle || 0);
    writeFixedPoint32(writer, bevel.strength || 0);
    writeFixedPoint32(writer, ((_f = bevel.size) === null || _f === void 0 ? void 0 : _f.value) || 0);
    writeBlendMode(writer, bevel.highlightBlendMode);
    writeBlendMode(writer, bevel.shadowBlendMode);
    writeColor(writer, bevel.highlightColor);
    writeColor(writer, bevel.shadowColor);
    var style2 = bevelStyles.indexOf(bevel.style);
    writeUint8(writer, style2 <= 0 ? 1 : style2);
    writeFixedPoint8(writer, bevel.highlightOpacity || 0);
    writeFixedPoint8(writer, bevel.shadowOpacity || 0);
    writeUint8(writer, bevel.enabled ? 1 : 0);
    writeUint8(writer, bevel.useGlobalLight ? 1 : 0);
    writeUint8(writer, bevel.direction === "down" ? 1 : 0);
    writeColor(writer, bevel.highlightColor);
    writeColor(writer, bevel.shadowColor);
  }
  if (solidFill) {
    writeSignature(writer, "8BIM");
    writeSignature(writer, "sofi");
    writeUint32(writer, 34);
    writeUint32(writer, 2);
    writeBlendMode(writer, solidFill.blendMode);
    writeColor(writer, solidFill.color);
    writeFixedPoint8(writer, solidFill.opacity || 0);
    writeUint8(writer, solidFill.enabled ? 1 : 0);
    writeColor(writer, solidFill.color);
  }
}
function isWhitespace(char) {
  return char === 32 || char === 10 || char === 13 || char === 9;
}
function isNumber(char) {
  return char >= 48 && char <= 57 || char === 46 || char === 45;
}
function parseEngineData(data3) {
  var index = 0;
  function skipWhitespace() {
    while (index < data3.length && isWhitespace(data3[index])) {
      index++;
    }
  }
  function getTextByte() {
    var byte = data3[index];
    index++;
    if (byte === 92) {
      byte = data3[index];
      index++;
    }
    return byte;
  }
  function getText() {
    var result = "";
    if (data3[index] === 41) {
      index++;
      return result;
    }
    if (data3[index] !== 254 || data3[index + 1] !== 255) {
      throw new Error("Invalid utf-16 BOM");
    }
    index += 2;
    while (index < data3.length && data3[index] !== 41) {
      var high = getTextByte();
      var low = getTextByte();
      var char2 = high << 8 | low;
      result += String.fromCharCode(char2);
    }
    index++;
    return result;
  }
  var root4 = null;
  var stack2 = [];
  function pushContainer(value2) {
    if (!stack2.length) {
      stack2.push(value2);
      root4 = value2;
    } else {
      pushValue(value2);
      stack2.push(value2);
    }
  }
  function pushValue(value2) {
    if (!stack2.length)
      throw new Error("Invalid data");
    var top = stack2[stack2.length - 1];
    if (typeof top === "string") {
      stack2[stack2.length - 2][top] = value2;
      pop();
    } else if (Array.isArray(top)) {
      top.push(value2);
    } else {
      throw new Error("Invalid data");
    }
  }
  function pushProperty(name) {
    if (!stack2.length)
      pushContainer({});
    var top = stack2[stack2.length - 1];
    if (top && typeof top === "string") {
      if (name === "nil") {
        pushValue(null);
      } else {
        pushValue("/".concat(name));
      }
    } else if (top && typeof top === "object") {
      stack2.push(name);
    } else {
      throw new Error("Invalid data");
    }
  }
  function pop() {
    if (!stack2.length)
      throw new Error("Invalid data");
    stack2.pop();
  }
  skipWhitespace();
  var dataLength = data3.length;
  while (dataLength > 0 && data3[dataLength - 1] === 0)
    dataLength--;
  while (index < dataLength) {
    var i2 = index;
    var char = data3[i2];
    if (char === 60 && data3[i2 + 1] === 60) {
      index += 2;
      pushContainer({});
    } else if (char === 62 && data3[i2 + 1] === 62) {
      index += 2;
      pop();
    } else if (char === 47) {
      index += 1;
      var start = index;
      while (index < data3.length && !isWhitespace(data3[index])) {
        index++;
      }
      var name_1 = "";
      for (var i_1 = start; i_1 < index; i_1++) {
        name_1 += String.fromCharCode(data3[i_1]);
      }
      pushProperty(name_1);
    } else if (char === 40) {
      index += 1;
      pushValue(getText());
    } else if (char === 91) {
      index += 1;
      pushContainer([]);
    } else if (char === 93) {
      index += 1;
      pop();
    } else if (char === 110 && data3[i2 + 1] === 117 && data3[i2 + 2] === 108 && data3[i2 + 3] === 108) {
      index += 4;
      pushValue(null);
    } else if (char === 116 && data3[i2 + 1] === 114 && data3[i2 + 2] === 117 && data3[i2 + 3] === 101) {
      index += 4;
      pushValue(true);
    } else if (char === 102 && data3[i2 + 1] === 97 && data3[i2 + 2] === 108 && data3[i2 + 3] === 115 && data3[i2 + 4] === 101) {
      index += 5;
      pushValue(false);
    } else if (isNumber(char)) {
      var value = "";
      while (index < data3.length && isNumber(data3[index])) {
        value += String.fromCharCode(data3[index]);
        index++;
      }
      pushValue(parseFloat(value));
    } else {
      index += 1;
      console.log(
        "Invalid token '".concat(String.fromCharCode(char), "' (").concat(char, ") at ").concat(index)
        // + ` near '${String.fromCharCode.apply(null, data.slice(index - 10, index + 20) as any)}'`
        // + ` data [${Array.from(data.slice(index - 10, index + 20)).join(', ')}]`
      );
    }
    skipWhitespace();
  }
  return root4;
}
var floatKeys = [
  "Axis",
  "XY",
  "Zone",
  "WordSpacing",
  "FirstLineIndent",
  "GlyphSpacing",
  "StartIndent",
  "EndIndent",
  "SpaceBefore",
  "SpaceAfter",
  "LetterSpacing",
  "Values",
  "GridSize",
  "GridLeading",
  "PointBase",
  "BoxBounds",
  "TransformPoint0",
  "TransformPoint1",
  "TransformPoint2",
  "FontSize",
  "Leading",
  "HorizontalScale",
  "VerticalScale",
  "BaselineShift",
  "Tsume",
  "OutlineWidth",
  "AutoLeading"
];
var intArrays = ["RunLengthArray"];
function serializeEngineData(data3, condensed) {
  if (condensed === void 0) {
    condensed = false;
  }
  var buffer = new Uint8Array(1024);
  var offset = 0;
  var indent = 0;
  function write(value) {
    if (offset >= buffer.length) {
      var newBuffer = new Uint8Array(buffer.length * 2);
      newBuffer.set(buffer);
      buffer = newBuffer;
    }
    buffer[offset] = value;
    offset++;
  }
  function writeString(value) {
    for (var i2 = 0; i2 < value.length; i2++) {
      write(value.charCodeAt(i2));
    }
  }
  function writeIndent() {
    if (condensed) {
      writeString(" ");
    } else {
      for (var i2 = 0; i2 < indent; i2++) {
        writeString("	");
      }
    }
  }
  function writeProperty(key2, value) {
    writeIndent();
    writeString("/".concat(key2));
    writeValue(value, key2, true);
    if (!condensed)
      writeString("\n");
  }
  function serializeInt(value) {
    return value.toString();
  }
  function serializeFloat(value) {
    return value.toFixed(5).replace(/(\d)0+$/g, "$1").replace(/^0+\.([1-9])/g, ".$1").replace(/^-0+\.0(\d)/g, "-.0$1");
  }
  function serializeNumber(value, key2) {
    var isFloat = key2 && floatKeys.indexOf(key2) !== -1 || (value | 0) !== value;
    return isFloat ? serializeFloat(value) : serializeInt(value);
  }
  function getKeys(value) {
    var keys = Object.keys(value);
    if (keys.indexOf("98") !== -1)
      keys.unshift.apply(keys, keys.splice(keys.indexOf("99"), 1));
    if (keys.indexOf("99") !== -1)
      keys.unshift.apply(keys, keys.splice(keys.indexOf("99"), 1));
    return keys;
  }
  function writeStringByte(value) {
    if (value === 40 || value === 41 || value === 92) {
      write(92);
    }
    write(value);
  }
  function writeValue(value, key2, inProperty) {
    if (inProperty === void 0) {
      inProperty = false;
    }
    function writePrefix() {
      if (inProperty) {
        writeString(" ");
      } else {
        writeIndent();
      }
    }
    if (value === null) {
      writePrefix();
      writeString(condensed ? "/nil" : "null");
    } else if (typeof value === "number") {
      writePrefix();
      writeString(serializeNumber(value, key2));
    } else if (typeof value === "boolean") {
      writePrefix();
      writeString(value ? "true" : "false");
    } else if (typeof value === "string") {
      writePrefix();
      if ((key2 === "99" || key2 === "98") && value.charAt(0) === "/") {
        writeString(value);
      } else {
        writeString("(");
        write(254);
        write(255);
        for (var i2 = 0; i2 < value.length; i2++) {
          var code2 = value.charCodeAt(i2);
          writeStringByte(code2 >> 8 & 255);
          writeStringByte(code2 & 255);
        }
        writeString(")");
      }
    } else if (Array.isArray(value)) {
      writePrefix();
      if (value.every(function(x3) {
        return typeof x3 === "number";
      })) {
        writeString("[");
        var intArray = intArrays.indexOf(key2) !== -1;
        for (var _i2 = 0, value_1 = value; _i2 < value_1.length; _i2++) {
          var x2 = value_1[_i2];
          writeString(" ");
          writeString(intArray ? serializeNumber(x2) : serializeFloat(x2));
        }
        writeString(" ]");
      } else {
        writeString("[");
        if (!condensed)
          writeString("\n");
        for (var _a2 = 0, value_2 = value; _a2 < value_2.length; _a2++) {
          var x2 = value_2[_a2];
          writeValue(x2, key2);
          if (!condensed)
            writeString("\n");
        }
        writeIndent();
        writeString("]");
      }
    } else if (typeof value === "object") {
      if (inProperty && !condensed)
        writeString("\n");
      writeIndent();
      writeString("<<");
      if (!condensed)
        writeString("\n");
      indent++;
      for (var _b = 0, _c = getKeys(value); _b < _c.length; _b++) {
        var key_1 = _c[_b];
        writeProperty(key_1, value[key_1]);
      }
      indent--;
      writeIndent();
      writeString(">>");
    }
    return void 0;
  }
  if (condensed) {
    if (typeof data3 === "object") {
      for (var _i = 0, _a = getKeys(data3); _i < _a.length; _i++) {
        var key = _a[_i];
        writeProperty(key, data3[key]);
      }
    }
  } else {
    writeString("\n\n");
    writeValue(data3);
  }
  return buffer.slice(0, offset);
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var defaultFont = {
  name: "MyriadPro-Regular",
  script: 0,
  type: 0,
  synthetic: 0
};
var defaultParagraphStyle = {
  justification: "left",
  firstLineIndent: 0,
  startIndent: 0,
  endIndent: 0,
  spaceBefore: 0,
  spaceAfter: 0,
  autoHyphenate: true,
  hyphenatedWordSize: 6,
  preHyphen: 2,
  postHyphen: 2,
  consecutiveHyphens: 8,
  zone: 36,
  wordSpacing: [0.8, 1, 1.33],
  letterSpacing: [0, 0, 0],
  glyphSpacing: [1, 1, 1],
  autoLeading: 1.2,
  leadingType: 0,
  hanging: false,
  burasagari: false,
  kinsokuOrder: 0,
  everyLineComposer: false
};
var defaultStyle = {
  font: defaultFont,
  fontSize: 12,
  fauxBold: false,
  fauxItalic: false,
  autoLeading: true,
  leading: 0,
  horizontalScale: 1,
  verticalScale: 1,
  tracking: 0,
  autoKerning: true,
  kerning: 0,
  baselineShift: 0,
  fontCaps: 0,
  fontBaseline: 0,
  underline: false,
  strikethrough: false,
  ligatures: true,
  dLigatures: false,
  baselineDirection: 2,
  tsume: 0,
  styleRunAlignment: 2,
  language: 0,
  noBreak: false,
  fillColor: { r: 0, g: 0, b: 0 },
  strokeColor: { r: 0, g: 0, b: 0 },
  fillFlag: true,
  strokeFlag: false,
  fillFirst: true,
  yUnderline: 1,
  outlineWidth: 1,
  characterDirection: 0,
  hindiNumbers: false,
  kashida: 1,
  diacriticPos: 2
};
var defaultGridInfo = {
  isOn: false,
  show: false,
  size: 18,
  leading: 22,
  color: { r: 0, g: 0, b: 255 },
  leadingFillColor: { r: 0, g: 0, b: 255 },
  alignLineHeightToGridFlags: false
};
var paragraphStyleKeys = [
  "justification",
  "firstLineIndent",
  "startIndent",
  "endIndent",
  "spaceBefore",
  "spaceAfter",
  "autoHyphenate",
  "hyphenatedWordSize",
  "preHyphen",
  "postHyphen",
  "consecutiveHyphens",
  "zone",
  "wordSpacing",
  "letterSpacing",
  "glyphSpacing",
  "autoLeading",
  "leadingType",
  "hanging",
  "burasagari",
  "kinsokuOrder",
  "everyLineComposer"
];
var styleKeys = [
  "font",
  "fontSize",
  "fauxBold",
  "fauxItalic",
  "autoLeading",
  "leading",
  "horizontalScale",
  "verticalScale",
  "tracking",
  "autoKerning",
  "kerning",
  "baselineShift",
  "fontCaps",
  "fontBaseline",
  "underline",
  "strikethrough",
  "ligatures",
  "dLigatures",
  "baselineDirection",
  "tsume",
  "styleRunAlignment",
  "language",
  "noBreak",
  "fillColor",
  "strokeColor",
  "fillFlag",
  "strokeFlag",
  "fillFirst",
  "yUnderline",
  "outlineWidth",
  "characterDirection",
  "hindiNumbers",
  "kashida",
  "diacriticPos"
];
var antialias = ["none", "crisp", "strong", "smooth", "sharp"];
var justification = [
  "left",
  "right",
  "center",
  "justify-left",
  "justify-right",
  "justify-center",
  "justify-all"
  // 6
];
function upperFirst(value) {
  return value.substring(0, 1).toUpperCase() + value.substring(1);
}
function decodeColor(color) {
  var c2 = color.Values;
  switch (color.Type) {
    case 0:
      return { k: c2[1] * 255 };
    // grayscale (alpha?)
    case 1:
      return c2[0] === 1 ? { r: c2[1] * 255, g: c2[2] * 255, b: c2[3] * 255 } : (
        // rgb
        { r: c2[1] * 255, g: c2[2] * 255, b: c2[3] * 255, a: c2[0] * 255 }
      );
    // rgba
    case 2:
      return { c: c2[1] * 255, m: c2[2] * 255, y: c2[3] * 255, k: c2[4] * 255 };
    // cmyk (alpha?)
    default:
      throw new Error("Unknown color type in text layer");
  }
}
function encodeColor(color) {
  if (!color) {
    return { Type: 1, Values: [0, 0, 0, 0] };
  } else if ("r" in color) {
    return { Type: 1, Values: ["a" in color ? color.a / 255 : 1, color.r / 255, color.g / 255, color.b / 255] };
  } else if ("c" in color) {
    return { Type: 2, Values: [1, color.c / 255, color.m / 255, color.y / 255, color.k / 255] };
  } else if ("k" in color) {
    return { Type: 0, Values: [1, color.k / 255] };
  } else {
    throw new Error("Invalid color type in text layer");
  }
}
function arraysEqual(a2, b2) {
  if (!a2 || !b2)
    return false;
  if (a2.length !== b2.length)
    return false;
  for (var i2 = 0; i2 < a2.length; i2++)
    if (a2[i2] !== b2[i2])
      return false;
  return true;
}
function objectsEqual(a2, b2) {
  if (!a2 || !b2)
    return false;
  for (var _i = 0, _a = Object.keys(a2); _i < _a.length; _i++) {
    var key = _a[_i];
    if (a2[key] !== b2[key])
      return false;
  }
  for (var _b = 0, _c = Object.keys(b2); _b < _c.length; _b++) {
    var key = _c[_b];
    if (a2[key] !== b2[key])
      return false;
  }
  return true;
}
function findOrAddFont(fonts, font) {
  for (var i2 = 0; i2 < fonts.length; i2++) {
    if (fonts[i2].name === font.name)
      return i2;
  }
  fonts.push(font);
  return fonts.length - 1;
}
function decodeObject(obj, keys, fonts) {
  var result = {};
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    var Key = upperFirst(key);
    if (obj[Key] === void 0)
      continue;
    if (key === "justification") {
      result[key] = justification[obj[Key]];
    } else if (key === "font") {
      result[key] = fonts[obj[Key]];
    } else if (key === "fillColor" || key === "strokeColor") {
      result[key] = decodeColor(obj[Key]);
    } else {
      result[key] = obj[Key];
    }
  }
  return result;
}
function encodeObject(obj, keys, fonts) {
  var _a;
  var result = {};
  for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
    var key = keys_2[_i];
    var Key = upperFirst(key);
    if (obj[key] === void 0)
      continue;
    if (key === "justification") {
      result[Key] = justification.indexOf((_a = obj[key]) !== null && _a !== void 0 ? _a : "left");
    } else if (key === "font") {
      result[Key] = findOrAddFont(fonts, obj[key]);
    } else if (key === "fillColor" || key === "strokeColor") {
      result[Key] = encodeColor(obj[key]);
    } else {
      result[Key] = obj[key];
    }
  }
  return result;
}
function decodeParagraphStyle(obj, fonts) {
  return decodeObject(obj, paragraphStyleKeys, fonts);
}
function decodeStyle(obj, fonts) {
  return decodeObject(obj, styleKeys, fonts);
}
function encodeParagraphStyle(obj, fonts) {
  return encodeObject(obj, paragraphStyleKeys, fonts);
}
function encodeStyle(obj, fonts) {
  return encodeObject(obj, styleKeys, fonts);
}
function deduplicateValues(base, runs, keys) {
  if (!runs.length)
    return;
  var _loop_1 = function(key2) {
    var value = runs[0].style[key2];
    if (value !== void 0) {
      var identical = false;
      if (Array.isArray(value)) {
        identical = runs.every(function(r2) {
          return arraysEqual(r2.style[key2], value);
        });
      } else if (typeof value === "object") {
        identical = runs.every(function(r2) {
          return objectsEqual(r2.style[key2], value);
        });
      } else {
        identical = runs.every(function(r2) {
          return r2.style[key2] === value;
        });
      }
      if (identical) {
        base[key2] = value;
      }
    }
    var styleValue = base[key2];
    if (styleValue !== void 0) {
      for (var _a = 0, runs_1 = runs; _a < runs_1.length; _a++) {
        var r = runs_1[_a];
        var same = false;
        if (Array.isArray(value)) {
          same = arraysEqual(r.style[key2], value);
        } else if (typeof value === "object") {
          same = objectsEqual(r.style[key2], value);
        } else {
          same = r.style[key2] === value;
        }
        if (same)
          delete r.style[key2];
      }
    }
  };
  for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
    var key = keys_3[_i];
    _loop_1(key);
  }
  if (runs.every(function(x2) {
    return Object.keys(x2.style).length === 0;
  })) {
    runs.length = 0;
  }
}
function decodeEngineData(engineData) {
  var _a, _b, _c, _d, _e, _f;
  var engineDict = engineData.EngineDict;
  var resourceDict = engineData.ResourceDict;
  var fonts = resourceDict.FontSet.map(function(f2) {
    return {
      name: f2.Name,
      script: f2.Script,
      type: f2.FontType,
      synthetic: f2.Synthetic
    };
  });
  var text = engineDict.Editor.Text.replace(/\r/g, "\n");
  var removedCharacters = 0;
  while (/\n$/.test(text)) {
    text = text.substring(0, text.length - 1);
    removedCharacters++;
  }
  var result = {
    text,
    antiAlias: (_a = antialias[engineDict.AntiAlias]) !== null && _a !== void 0 ? _a : "smooth",
    useFractionalGlyphWidths: !!engineDict.UseFractionalGlyphWidths,
    superscriptSize: resourceDict.SuperscriptSize,
    superscriptPosition: resourceDict.SuperscriptPosition,
    subscriptSize: resourceDict.SubscriptSize,
    subscriptPosition: resourceDict.SubscriptPosition,
    smallCapSize: resourceDict.SmallCapSize
  };
  var photoshop = (_f = (_e = (_d = (_c = (_b = engineDict.Rendered) === null || _b === void 0 ? void 0 : _b.Shapes) === null || _c === void 0 ? void 0 : _c.Children) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.Cookie) === null || _f === void 0 ? void 0 : _f.Photoshop;
  if (photoshop) {
    result.shapeType = photoshop.ShapeType === 1 ? "box" : "point";
    if (photoshop.PointBase)
      result.pointBase = photoshop.PointBase;
    if (photoshop.BoxBounds)
      result.boxBounds = photoshop.BoxBounds;
  }
  var paragraphRun = engineDict.ParagraphRun;
  result.paragraphStyle = {};
  result.paragraphStyleRuns = [];
  for (var i2 = 0; i2 < paragraphRun.RunArray.length; i2++) {
    var run_1 = paragraphRun.RunArray[i2];
    var length_1 = paragraphRun.RunLengthArray[i2];
    var style2 = decodeParagraphStyle(run_1.ParagraphSheet.Properties, fonts);
    result.paragraphStyleRuns.push({
      length: length_1,
      style: style2
      /*, adjustments*/
    });
  }
  for (var counter = removedCharacters; result.paragraphStyleRuns.length && counter > 0; counter--) {
    if (--result.paragraphStyleRuns[result.paragraphStyleRuns.length - 1].length === 0) {
      result.paragraphStyleRuns.pop();
    }
  }
  deduplicateValues(result.paragraphStyle, result.paragraphStyleRuns, paragraphStyleKeys);
  if (!result.paragraphStyleRuns.length)
    delete result.paragraphStyleRuns;
  var styleRun = engineDict.StyleRun;
  result.style = {};
  result.styleRuns = [];
  for (var i2 = 0; i2 < styleRun.RunArray.length; i2++) {
    var length_2 = styleRun.RunLengthArray[i2];
    var style2 = decodeStyle(styleRun.RunArray[i2].StyleSheet.StyleSheetData, fonts);
    if (!style2.font)
      style2.font = fonts[0];
    result.styleRuns.push({ length: length_2, style: style2 });
  }
  for (var counter = removedCharacters; result.styleRuns.length && counter > 0; counter--) {
    if (--result.styleRuns[result.styleRuns.length - 1].length === 0) {
      result.styleRuns.pop();
    }
  }
  deduplicateValues(result.style, result.styleRuns, styleKeys);
  if (!result.styleRuns.length)
    delete result.styleRuns;
  return result;
}
function encodeEngineData(data3) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  var text = "".concat((data3.text || "").replace(/\r?\n/g, "\r"), "\r");
  var fonts = [
    { name: "AdobeInvisFont", script: 0, type: 0, synthetic: 0 }
  ];
  var defFont = ((_a = data3.style) === null || _a === void 0 ? void 0 : _a.font) || ((_c = (_b = data3.styleRuns) === null || _b === void 0 ? void 0 : _b.find(function(s2) {
    return s2.style.font;
  })) === null || _c === void 0 ? void 0 : _c.style.font) || defaultFont;
  var paragraphRunArray = [];
  var paragraphRunLengthArray = [];
  var paragraphRuns = data3.paragraphStyleRuns;
  if (paragraphRuns && paragraphRuns.length) {
    var leftLength_1 = text.length;
    for (var _i = 0, paragraphRuns_1 = paragraphRuns; _i < paragraphRuns_1.length; _i++) {
      var run_2 = paragraphRuns_1[_i];
      var runLength = Math.min(run_2.length, leftLength_1);
      leftLength_1 -= runLength;
      if (!runLength)
        continue;
      if (leftLength_1 === 1 && run_2 === paragraphRuns[paragraphRuns.length - 1]) {
        runLength++;
        leftLength_1--;
      }
      paragraphRunLengthArray.push(runLength);
      paragraphRunArray.push({
        ParagraphSheet: {
          DefaultStyleSheet: 0,
          Properties: encodeParagraphStyle(__assign$4(__assign$4(__assign$4({}, defaultParagraphStyle), data3.paragraphStyle), run_2.style), fonts)
        },
        Adjustments: { Axis: [1, 0, 1], XY: [0, 0] }
      });
    }
    if (leftLength_1) {
      paragraphRunLengthArray.push(leftLength_1);
      paragraphRunArray.push({
        ParagraphSheet: {
          DefaultStyleSheet: 0,
          Properties: encodeParagraphStyle(__assign$4(__assign$4({}, defaultParagraphStyle), data3.paragraphStyle), fonts)
        },
        Adjustments: { Axis: [1, 0, 1], XY: [0, 0] }
      });
    }
  } else {
    for (var i2 = 0, last = 0; i2 < text.length; i2++) {
      if (text.charCodeAt(i2) === 13) {
        paragraphRunLengthArray.push(i2 - last + 1);
        paragraphRunArray.push({
          ParagraphSheet: {
            DefaultStyleSheet: 0,
            Properties: encodeParagraphStyle(__assign$4(__assign$4({}, defaultParagraphStyle), data3.paragraphStyle), fonts)
          },
          Adjustments: { Axis: [1, 0, 1], XY: [0, 0] }
        });
        last = i2 + 1;
      }
    }
  }
  var styleSheetData = encodeStyle(__assign$4(__assign$4({}, defaultStyle), { font: defFont }), fonts);
  var styleRuns = data3.styleRuns || [{ length: text.length, style: data3.style || {} }];
  var styleRunArray = [];
  var styleRunLengthArray = [];
  var leftLength = text.length;
  for (var _o = 0, styleRuns_1 = styleRuns; _o < styleRuns_1.length; _o++) {
    var run_3 = styleRuns_1[_o];
    var runLength = Math.min(run_3.length, leftLength);
    leftLength -= runLength;
    if (!runLength)
      continue;
    if (leftLength === 1 && run_3 === styleRuns[styleRuns.length - 1]) {
      runLength++;
      leftLength--;
    }
    styleRunLengthArray.push(runLength);
    styleRunArray.push({
      StyleSheet: {
        StyleSheetData: encodeStyle(__assign$4(__assign$4({ kerning: 0, autoKerning: true, fillColor: { r: 0, g: 0, b: 0 } }, data3.style), run_3.style), fonts)
      }
    });
  }
  if (leftLength && styleRuns.length) {
    styleRunLengthArray.push(leftLength);
    styleRunArray.push({
      StyleSheet: {
        StyleSheetData: encodeStyle(__assign$4({ kerning: 0, autoKerning: true, fillColor: { r: 0, g: 0, b: 0 } }, data3.style), fonts)
      }
    });
  }
  var gridInfo = __assign$4(__assign$4({}, defaultGridInfo), data3.gridInfo);
  var WritingDirection = data3.orientation === "vertical" ? 2 : 0;
  var Procession = data3.orientation === "vertical" ? 1 : 0;
  var ShapeType = data3.shapeType === "box" ? 1 : 0;
  var Photoshop = {
    ShapeType
  };
  if (ShapeType === 0) {
    Photoshop.PointBase = data3.pointBase || [0, 0];
  } else {
    Photoshop.BoxBounds = data3.boxBounds || [0, 0, 0, 0];
  }
  Photoshop.Base = {
    ShapeType,
    TransformPoint0: [1, 0],
    TransformPoint1: [0, 1],
    TransformPoint2: [0, 0]
  };
  var defaultResources = {
    KinsokuSet: [
      {
        Name: "PhotoshopKinsokuHard",
        NoStart: "?!)]},.:;",
        NoEnd: "([{",
        Keep: "",
        Hanging: ".,"
      },
      {
        Name: "PhotoshopKinsokuSoft",
        NoStart: "",
        NoEnd: "",
        Keep: "",
        Hanging: ".,"
      }
    ],
    MojiKumiSet: [
      { InternalName: "Photoshop6MojiKumiSet1" },
      { InternalName: "Photoshop6MojiKumiSet2" },
      { InternalName: "Photoshop6MojiKumiSet3" },
      { InternalName: "Photoshop6MojiKumiSet4" }
    ],
    TheNormalStyleSheet: 0,
    TheNormalParagraphSheet: 0,
    ParagraphSheetSet: [
      {
        Name: "Normal RGB",
        DefaultStyleSheet: 0,
        Properties: encodeParagraphStyle(__assign$4(__assign$4({}, defaultParagraphStyle), data3.paragraphStyle), fonts)
      }
    ],
    StyleSheetSet: [
      {
        Name: "Normal RGB",
        StyleSheetData: styleSheetData
      }
    ],
    FontSet: fonts.map(function(f2) {
      return {
        Name: f2.name,
        Script: f2.script || 0,
        FontType: f2.type || 0,
        Synthetic: f2.synthetic || 0
      };
    }),
    SuperscriptSize: (_d = data3.superscriptSize) !== null && _d !== void 0 ? _d : 0.583,
    SuperscriptPosition: (_e = data3.superscriptPosition) !== null && _e !== void 0 ? _e : 0.333,
    SubscriptSize: (_f = data3.subscriptSize) !== null && _f !== void 0 ? _f : 0.583,
    SubscriptPosition: (_g = data3.subscriptPosition) !== null && _g !== void 0 ? _g : 0.333,
    SmallCapSize: (_h = data3.smallCapSize) !== null && _h !== void 0 ? _h : 0.7
  };
  var engineData = {
    EngineDict: {
      Editor: { Text: text },
      ParagraphRun: {
        DefaultRunData: {
          ParagraphSheet: { DefaultStyleSheet: 0, Properties: {} },
          Adjustments: { Axis: [1, 0, 1], XY: [0, 0] }
        },
        RunArray: paragraphRunArray,
        RunLengthArray: paragraphRunLengthArray,
        IsJoinable: 1
      },
      StyleRun: {
        DefaultRunData: { StyleSheet: { StyleSheetData: {} } },
        RunArray: styleRunArray,
        RunLengthArray: styleRunLengthArray,
        IsJoinable: 2
      },
      GridInfo: {
        GridIsOn: !!gridInfo.isOn,
        ShowGrid: !!gridInfo.show,
        GridSize: (_j = gridInfo.size) !== null && _j !== void 0 ? _j : 18,
        GridLeading: (_k = gridInfo.leading) !== null && _k !== void 0 ? _k : 22,
        GridColor: encodeColor(gridInfo.color),
        GridLeadingFillColor: encodeColor(gridInfo.color),
        AlignLineHeightToGridFlags: !!gridInfo.alignLineHeightToGridFlags
      },
      AntiAlias: antialias.indexOf((_l = data3.antiAlias) !== null && _l !== void 0 ? _l : "sharp"),
      UseFractionalGlyphWidths: (_m = data3.useFractionalGlyphWidths) !== null && _m !== void 0 ? _m : true,
      Rendered: {
        Version: 1,
        Shapes: {
          WritingDirection,
          Children: [
            {
              ShapeType,
              Procession,
              Lines: { WritingDirection, Children: [] },
              Cookie: { Photoshop }
            }
          ]
        }
      }
    },
    ResourceDict: __assign$4({}, defaultResources),
    DocumentResources: __assign$4({}, defaultResources)
  };
  return engineData;
}
var keysColor = {
  "0": {
    uproot: true,
    children: {
      "0": { name: "Type" },
      "1": { name: "Values" }
    }
  }
};
var keysStyleSheet = {
  "0": { name: "Font" },
  "1": { name: "FontSize" },
  "2": { name: "FauxBold" },
  "3": { name: "FauxItalic" },
  "4": { name: "AutoLeading" },
  "5": { name: "Leading" },
  "6": { name: "HorizontalScale" },
  "7": { name: "VerticalScale" },
  "8": { name: "Tracking" },
  "9": { name: "BaselineShift" },
  // '10': ???
  "11": { name: "Kerning?" },
  "12": { name: "FontCaps" },
  "13": { name: "FontBaseline" },
  "15": { name: "Strikethrough?" },
  "16": { name: "Underline?" },
  "18": { name: "Ligatures" },
  "19": { name: "DLigatures" },
  // '20': ???
  // '21': ???
  // '22': ???
  "23": { name: "Fractions" },
  "24": { name: "Ordinals" },
  // '25': ???
  // '26': ???
  // '27': ???
  "28": { name: "StylisticAlternates" },
  // '29': ???
  "30": { name: "OldStyle?" },
  "35": { name: "BaselineDirection" },
  "38": { name: "Language" },
  "52": { name: "NoBreak" },
  "53": { name: "FillColor", children: keysColor },
  "54": { name: "StrokeColor", children: keysColor },
  "55": { children: { "99": { uproot: true } } },
  // '68': ???
  // '70': ???
  // '71': ???
  // '72': ???
  // '73': ???
  "79": { children: keysColor }
  // '85': ???
  // '87': ???
  // '88': ???
};
var keysParagraph = {
  "0": { name: "Justification" },
  "1": { name: "FirstLineIndent" },
  "2": { name: "StartIndent" },
  "3": { name: "EndIndent" },
  "4": { name: "SpaceBefore" },
  "5": { name: "SpaceAfter" },
  "7": { name: "AutoLeading" },
  "9": { name: "AutoHyphenate" },
  "10": { name: "HyphenatedWordSize" },
  "11": { name: "PreHyphen" },
  "12": { name: "PostHyphen" },
  "13": { name: "ConsecutiveHyphens?" },
  "14": { name: "Zone" },
  "15": { name: "HypenateCapitalizedWords" },
  "17": { name: "WordSpacing" },
  "18": { name: "LetterSpacing" },
  "19": { name: "GlyphSpacing" },
  "32": { name: "StyleSheet", children: keysStyleSheet }
};
var keysStyleSheetData = {
  name: "StyleSheetData",
  children: keysStyleSheet
};
var keysRoot = {
  "0": {
    name: "ResourceDict",
    children: {
      "1": {
        name: "FontSet",
        children: {
          "0": {
            uproot: true,
            children: {
              "0": {
                uproot: true,
                children: {
                  "0": {
                    uproot: true,
                    children: {
                      "0": { name: "Name" },
                      "2": { name: "FontType" }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "2": {
        name: "2",
        children: {}
      },
      "3": {
        name: "MojiKumiSet",
        children: {
          "0": {
            uproot: true,
            children: {
              "0": {
                uproot: true,
                children: {
                  "0": { name: "InternalName" }
                }
              }
            }
          }
        }
      },
      "4": {
        name: "KinsokuSet",
        children: {
          "0": {
            uproot: true,
            children: {
              "0": {
                uproot: true,
                children: {
                  "0": { name: "Name" },
                  "5": {
                    uproot: true,
                    children: {
                      "0": { name: "NoStart" },
                      "1": { name: "NoEnd" },
                      "2": { name: "Keep" },
                      "3": { name: "Hanging" },
                      "4": { name: "Name" }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "5": {
        name: "StyleSheetSet",
        children: {
          "0": {
            uproot: true,
            children: {
              "0": {
                uproot: true,
                children: {
                  "0": { name: "Name" },
                  "6": keysStyleSheetData
                }
              }
            }
          }
        }
      },
      "6": {
        name: "ParagraphSheetSet",
        children: {
          "0": {
            uproot: true,
            children: {
              "0": {
                uproot: true,
                children: {
                  "0": { name: "Name" },
                  "5": {
                    name: "Properties",
                    children: keysParagraph
                  },
                  "6": { name: "DefaultStyleSheet" }
                }
              }
            }
          }
        }
      },
      "8": {
        name: "TextFrameSet",
        children: {
          "0": {
            uproot: true,
            children: {
              "0": {
                name: "path",
                children: {
                  "0": { name: "name" },
                  "1": {
                    name: "bezierCurve",
                    children: {
                      "0": { name: "controlPoints" }
                    }
                  },
                  "2": {
                    name: "data",
                    children: {
                      "0": { name: "type" },
                      "1": { name: "orientation" },
                      "2": { name: "frameMatrix" },
                      "4": { name: "4" },
                      "6": { name: "textRange" },
                      "7": { name: "rowGutter" },
                      "8": { name: "columnGutter" },
                      "9": { name: "9" },
                      "10": {
                        name: "baselineAlignment",
                        children: {
                          "0": { name: "flag" },
                          "1": { name: "min" }
                        }
                      },
                      "11": {
                        name: "pathData",
                        children: {
                          "1": { name: "1" },
                          "0": { name: "reversed" },
                          "2": { name: "2" },
                          "3": { name: "3" },
                          "4": { name: "spacing" },
                          "5": { name: "5" },
                          "6": { name: "6" },
                          "7": { name: "7" },
                          "18": { name: "18" }
                        }
                      },
                      "12": { name: "12" },
                      "13": { name: "13" }
                    }
                  },
                  "3": { name: "3" },
                  "97": { name: "uuid" }
                }
              }
            }
          }
        }
      },
      "9": {
        name: "Predefined",
        children: {
          "0": {
            children: { "0": { uproot: true } }
          },
          "1": {
            children: { "0": { uproot: true } }
          }
        }
      }
    }
  },
  "1": {
    name: "EngineDict",
    children: {
      "0": {
        name: "0",
        children: {
          // 0: ???
          // 1: ???
          // 2: ???
          "3": { name: "SuperscriptSize" },
          "4": { name: "SuperscriptPosition" },
          "5": { name: "SubscriptSize" },
          "6": { name: "SubscriptPosition" },
          "7": { name: "SmallCapSize" },
          "8": { name: "UseFractionalGlyphWidths" },
          "15": { children: { "0": { uproot: true } } }
          // 16: ???
          // 17: ???
        }
      },
      "1": {
        name: "Editors?",
        children: {
          "0": {
            name: "Editor",
            children: {
              "0": { name: "Text" },
              "5": {
                name: "ParagraphRun",
                children: {
                  "0": {
                    name: "RunArray",
                    children: {
                      "0": {
                        name: "ParagraphSheet",
                        children: {
                          "0": {
                            uproot: true,
                            children: {
                              "0": { name: "0" },
                              "5": {
                                name: "5",
                                children: keysParagraph
                              },
                              "6": { name: "6" }
                            }
                          }
                        }
                      },
                      "1": { name: "RunLength" }
                    }
                  }
                }
              },
              "6": {
                name: "StyleRun",
                children: {
                  "0": {
                    name: "RunArray",
                    children: {
                      "0": {
                        name: "StyleSheet",
                        children: {
                          "0": {
                            uproot: true,
                            children: {
                              "6": keysStyleSheetData
                            }
                          }
                        }
                      },
                      "1": { name: "RunLength" }
                    }
                  }
                }
              }
            }
          },
          "1": {
            name: "FontVectorData ???"
            // children: {
            // 	'0': {},
            // 	'2': {
            // 		// '5'
            // 		// '6'
            // 	},
            // }
            //     "1": [ // this is probably bounding box? there seem to be many of them nested
            //       0,
            //       0,
            //       999,
            //       176.30014
            //     ],
            // various types: /PC, /F, /R, /L, /S, /G
          }
        }
      },
      "2": {
        name: "StyleSheet",
        children: keysStyleSheet
      },
      "3": {
        name: "ParagraphSheet",
        children: keysParagraph
      }
    }
  }
};
function decodeObj(obj, keys) {
  var _a, _b;
  if (obj === null)
    return obj;
  if (Array.isArray(obj))
    return obj.map(function(x2) {
      return decodeObj(x2, keys);
    });
  if (typeof obj !== "object")
    return obj;
  var result = {};
  for (var _i = 0, _c = Object.keys(obj); _i < _c.length; _i++) {
    var key = _c[_i];
    if (keys[key]) {
      if (keys[key].uproot) {
        if (key !== "99")
          result = decodeObj(obj[key], (_a = keys[key].children) !== null && _a !== void 0 ? _a : {});
        if (obj["99"])
          result._type = obj["99"];
        break;
      } else {
        result[keys[key].name || key] = decodeObj(obj[key], (_b = keys[key].children) !== null && _b !== void 0 ? _b : {});
      }
    } else if (key === "99") {
      result._type = obj[key];
    } else {
      result[key] = decodeObj(obj[key], {});
    }
  }
  return result;
}
function decodeEngineData2(data3) {
  return decodeObj(data3, keysRoot);
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var fromAtoZ = "abcdefghijklmnopqrstuvwxyz";
var infoHandlers = [];
var infoHandlersMap = {};
function addHandler(key, has, read, write) {
  var handler3 = { key, has, read, write };
  infoHandlers.push(handler3);
  infoHandlersMap[handler3.key] = handler3;
}
function addHandlerAlias(key, target) {
  infoHandlersMap[key] = infoHandlersMap[target];
}
function hasKey(key) {
  return function(target) {
    return target[key] !== void 0;
  };
}
function readLength64(reader) {
  if (readUint32(reader))
    throw new Error("Resource size above 4 GB limit at ".concat(reader.offset.toString(16)));
  return readUint32(reader);
}
function writeLength64(writer, length) {
  writeUint32(writer, 0);
  writeUint32(writer, length);
}
addHandler("TySh", hasKey("text"), function(reader, target, leftBytes) {
  if (readInt16(reader) !== 1)
    throw new Error("Invalid TySh version");
  var transform2 = [];
  for (var i2 = 0; i2 < 6; i2++)
    transform2.push(readFloat64(reader));
  if (readInt16(reader) !== 50)
    throw new Error("Invalid TySh text version");
  var text = readVersionAndDescriptor(reader);
  if (readInt16(reader) !== 1)
    throw new Error("Invalid TySh warp version");
  var warp = readVersionAndDescriptor(reader);
  target.text = {
    transform: transform2,
    left: readFloat32(reader),
    top: readFloat32(reader),
    right: readFloat32(reader),
    bottom: readFloat32(reader),
    text: text["Txt "].replace(/\r/g, "\n"),
    index: text.TextIndex || 0,
    gridding: textGridding.decode(text.textGridding),
    antiAlias: Annt.decode(text.AntA),
    orientation: Ornt.decode(text.Ornt),
    warp: {
      style: warpStyle.decode(warp.warpStyle),
      value: warp.warpValue || 0,
      perspective: warp.warpPerspective || 0,
      perspectiveOther: warp.warpPerspectiveOther || 0,
      rotate: Ornt.decode(warp.warpRotate)
    }
  };
  if (text.bounds)
    target.text.bounds = descBoundsToBounds(text.bounds);
  if (text.boundingBox)
    target.text.boundingBox = descBoundsToBounds(text.boundingBox);
  if (text.EngineData) {
    var engineData = parseEngineData(text.EngineData);
    var textData = decodeEngineData(engineData);
    target.text = __assign$3(__assign$3({}, target.text), textData);
  }
  skipBytes(reader, leftBytes());
}, function(writer, target) {
  var text = target.text;
  var warp = text.warp || {};
  var transform2 = text.transform || [1, 0, 0, 1, 0, 0];
  var textDescriptor = __assign$3(__assign$3(__assign$3({ "Txt ": (text.text || "").replace(/\r?\n/g, "\r"), textGridding: textGridding.encode(text.gridding), Ornt: Ornt.encode(text.orientation), AntA: Annt.encode(text.antiAlias) }, text.bounds ? { bounds: boundsToDescBounds(text.bounds) } : {}), text.boundingBox ? { boundingBox: boundsToDescBounds(text.boundingBox) } : {}), { TextIndex: text.index || 0, EngineData: serializeEngineData(encodeEngineData(text)) });
  writeInt16(writer, 1);
  for (var i2 = 0; i2 < 6; i2++) {
    writeFloat64(writer, transform2[i2]);
  }
  writeInt16(writer, 50);
  writeVersionAndDescriptor(writer, "", "TxLr", textDescriptor, "text");
  writeInt16(writer, 1);
  writeVersionAndDescriptor(writer, "", "warp", encodeWarp(warp));
  writeFloat32(writer, text.left);
  writeFloat32(writer, text.top);
  writeFloat32(writer, text.right);
  writeFloat32(writer, text.bottom);
});
addHandler("SoCo", function(target) {
  return target.vectorFill !== void 0 && target.vectorStroke === void 0 && target.vectorFill.type === "color";
}, function(reader, target) {
  var descriptor = readVersionAndDescriptor(reader);
  target.vectorFill = parseVectorContent(descriptor);
}, function(writer, target) {
  var descriptor = serializeVectorContent(target.vectorFill).descriptor;
  writeVersionAndDescriptor(writer, "", "null", descriptor);
});
addHandler("GdFl", function(target) {
  return target.vectorFill !== void 0 && target.vectorStroke === void 0 && (target.vectorFill.type === "solid" || target.vectorFill.type === "noise");
}, function(reader, target, left) {
  var descriptor = readVersionAndDescriptor(reader);
  target.vectorFill = parseVectorContent(descriptor);
  skipBytes(reader, left());
}, function(writer, target) {
  var descriptor = serializeVectorContent(target.vectorFill).descriptor;
  writeVersionAndDescriptor(writer, "", "null", descriptor);
});
addHandler("PtFl", function(target) {
  return target.vectorFill !== void 0 && target.vectorStroke === void 0 && target.vectorFill.type === "pattern";
}, function(reader, target) {
  var descriptor = readVersionAndDescriptor(reader);
  target.vectorFill = parseVectorContent(descriptor);
}, function(writer, target) {
  var descriptor = serializeVectorContent(target.vectorFill).descriptor;
  writeVersionAndDescriptor(writer, "", "null", descriptor);
});
addHandler("vscg", function(target) {
  return target.vectorFill !== void 0 && target.vectorStroke !== void 0;
}, function(reader, target, left) {
  readSignature(reader);
  var desc = readVersionAndDescriptor(reader);
  target.vectorFill = parseVectorContent(desc);
  skipBytes(reader, left());
}, function(writer, target) {
  var _a = serializeVectorContent(target.vectorFill), descriptor = _a.descriptor, key = _a.key;
  writeSignature(writer, key);
  writeVersionAndDescriptor(writer, "", "null", descriptor);
});
function readBezierKnot(reader, width, height) {
  var y0 = readFixedPointPath32(reader) * height;
  var x0 = readFixedPointPath32(reader) * width;
  var y1 = readFixedPointPath32(reader) * height;
  var x1 = readFixedPointPath32(reader) * width;
  var y2 = readFixedPointPath32(reader) * height;
  var x2 = readFixedPointPath32(reader) * width;
  return [x0, y0, x1, y1, x2, y2];
}
function writeBezierKnot(writer, points, width, height) {
  writeFixedPointPath32(writer, points[1] / height);
  writeFixedPointPath32(writer, points[0] / width);
  writeFixedPointPath32(writer, points[3] / height);
  writeFixedPointPath32(writer, points[2] / width);
  writeFixedPointPath32(writer, points[5] / height);
  writeFixedPointPath32(writer, points[4] / width);
}
var booleanOperations = ["exclude", "combine", "subtract", "intersect"];
function readVectorMask(reader, vectorMask, width, height, size) {
  var end = reader.offset + size;
  var paths = vectorMask.paths;
  var path = void 0;
  while (end - reader.offset >= 26) {
    var selector = readUint16(reader);
    switch (selector) {
      case 0:
      // Closed subpath length record
      case 3: {
        readUint16(reader);
        var boolOp = readInt16(reader);
        var flags = readUint16(reader);
        skipBytes(reader, 18);
        path = {
          open: selector === 3,
          knots: [],
          fillRule: flags === 2 ? "non-zero" : "even-odd"
        };
        if (boolOp !== -1)
          path.operation = booleanOperations[boolOp];
        paths.push(path);
        break;
      }
      case 1:
      // Closed subpath Bezier knot, linked
      case 2:
      // Closed subpath Bezier knot, unlinked
      case 4:
      // Open subpath Bezier knot, linked
      case 5:
        path.knots.push({ linked: selector === 1 || selector === 4, points: readBezierKnot(reader, width, height) });
        break;
      case 6:
        skipBytes(reader, 24);
        break;
      case 7: {
        var top_1 = readFixedPointPath32(reader);
        var left = readFixedPointPath32(reader);
        var bottom = readFixedPointPath32(reader);
        var right = readFixedPointPath32(reader);
        var resolution = readFixedPointPath32(reader);
        skipBytes(reader, 4);
        vectorMask.clipboard = { top: top_1, left, bottom, right, resolution };
        break;
      }
      case 8:
        vectorMask.fillStartsWithAllPixels = !!readUint16(reader);
        skipBytes(reader, 22);
        break;
      default:
        throw new Error("Invalid vmsk section");
    }
  }
  return paths;
}
addHandler("vmsk", hasKey("vectorMask"), function(reader, target, left, _a) {
  var width = _a.width, height = _a.height;
  if (readUint32(reader) !== 3)
    throw new Error("Invalid vmsk version");
  target.vectorMask = { paths: [] };
  var vectorMask = target.vectorMask;
  var flags = readUint32(reader);
  vectorMask.invert = (flags & 1) !== 0;
  vectorMask.notLink = (flags & 2) !== 0;
  vectorMask.disable = (flags & 4) !== 0;
  readVectorMask(reader, vectorMask, width, height, left());
  skipBytes(reader, left());
}, function(writer, target, _a) {
  var width = _a.width, height = _a.height;
  var vectorMask = target.vectorMask;
  var flags = (vectorMask.invert ? 1 : 0) | (vectorMask.notLink ? 2 : 0) | (vectorMask.disable ? 4 : 0);
  writeUint32(writer, 3);
  writeUint32(writer, flags);
  writeUint16(writer, 6);
  writeZeros(writer, 24);
  var clipboard = vectorMask.clipboard;
  if (clipboard) {
    writeUint16(writer, 7);
    writeFixedPointPath32(writer, clipboard.top);
    writeFixedPointPath32(writer, clipboard.left);
    writeFixedPointPath32(writer, clipboard.bottom);
    writeFixedPointPath32(writer, clipboard.right);
    writeFixedPointPath32(writer, clipboard.resolution);
    writeZeros(writer, 4);
  }
  writeUint16(writer, 8);
  writeUint16(writer, vectorMask.fillStartsWithAllPixels ? 1 : 0);
  writeZeros(writer, 22);
  for (var _i = 0, _b = vectorMask.paths; _i < _b.length; _i++) {
    var path = _b[_i];
    writeUint16(writer, path.open ? 3 : 0);
    writeUint16(writer, path.knots.length);
    writeUint16(writer, path.operation ? booleanOperations.indexOf(path.operation) : -1);
    writeUint16(writer, path.fillRule === "non-zero" ? 2 : 1);
    writeZeros(writer, 18);
    var linkedKnot = path.open ? 4 : 1;
    var unlinkedKnot = path.open ? 5 : 2;
    for (var _c = 0, _d = path.knots; _c < _d.length; _c++) {
      var _e = _d[_c], linked = _e.linked, points = _e.points;
      writeUint16(writer, linked ? linkedKnot : unlinkedKnot);
      writeBezierKnot(writer, points, width, height);
    }
  }
});
addHandlerAlias("vsms", "vmsk");
addHandler(
  "vowv",
  // something with vectors?
  hasKey("vowv"),
  function(reader, target) {
    target.vowv = readUint32(reader);
  },
  function(writer, target) {
    writeUint32(writer, target.vowv);
  }
);
addHandler("vogk", hasKey("vectorOrigination"), function(reader, target, left) {
  if (readInt32(reader) !== 1)
    throw new Error("Invalid vogk version");
  var desc = readVersionAndDescriptor(reader);
  target.vectorOrigination = { keyDescriptorList: [] };
  for (var _i = 0, _a = desc.keyDescriptorList; _i < _a.length; _i++) {
    var i2 = _a[_i];
    var item = {};
    if (i2.keyShapeInvalidated != null)
      item.keyShapeInvalidated = i2.keyShapeInvalidated;
    if (i2.keyOriginType != null)
      item.keyOriginType = i2.keyOriginType;
    if (i2.keyOriginResolution != null)
      item.keyOriginResolution = i2.keyOriginResolution;
    if (i2.keyOriginShapeBBox) {
      item.keyOriginShapeBoundingBox = {
        top: parseUnitsOrNumber(i2.keyOriginShapeBBox["Top "]),
        left: parseUnitsOrNumber(i2.keyOriginShapeBBox.Left),
        bottom: parseUnitsOrNumber(i2.keyOriginShapeBBox.Btom),
        right: parseUnitsOrNumber(i2.keyOriginShapeBBox.Rght)
      };
    }
    var rectRadii = i2.keyOriginRRectRadii;
    if (rectRadii) {
      item.keyOriginRRectRadii = {
        topRight: parseUnits(rectRadii.topRight),
        topLeft: parseUnits(rectRadii.topLeft),
        bottomLeft: parseUnits(rectRadii.bottomLeft),
        bottomRight: parseUnits(rectRadii.bottomRight)
      };
    }
    var corners = i2.keyOriginBoxCorners;
    if (corners) {
      item.keyOriginBoxCorners = [
        { x: corners.rectangleCornerA.Hrzn, y: corners.rectangleCornerA.Vrtc },
        { x: corners.rectangleCornerB.Hrzn, y: corners.rectangleCornerB.Vrtc },
        { x: corners.rectangleCornerC.Hrzn, y: corners.rectangleCornerC.Vrtc },
        { x: corners.rectangleCornerD.Hrzn, y: corners.rectangleCornerD.Vrtc }
      ];
    }
    var trnf = i2.Trnf;
    if (trnf) {
      item.transform = [trnf.xx, trnf.xy, trnf.yx, trnf.yy, trnf.tx, trnf.ty];
    }
    target.vectorOrigination.keyDescriptorList.push(item);
  }
  skipBytes(reader, left());
}, function(writer, target) {
  var orig = target.vectorOrigination;
  var desc = { keyDescriptorList: [] };
  for (var i2 = 0; i2 < orig.keyDescriptorList.length; i2++) {
    var item = orig.keyDescriptorList[i2];
    desc.keyDescriptorList.push({});
    var out = desc.keyDescriptorList[desc.keyDescriptorList.length - 1];
    if (item.keyOriginType != null)
      out.keyOriginType = item.keyOriginType;
    if (item.keyOriginResolution != null)
      out.keyOriginResolution = item.keyOriginResolution;
    var radii = item.keyOriginRRectRadii;
    if (radii) {
      out.keyOriginRRectRadii = {
        unitValueQuadVersion: 1,
        topRight: unitsValue(radii.topRight, "topRight"),
        topLeft: unitsValue(radii.topLeft, "topLeft"),
        bottomLeft: unitsValue(radii.bottomLeft, "bottomLeft"),
        bottomRight: unitsValue(radii.bottomRight, "bottomRight")
      };
    }
    var box = item.keyOriginShapeBoundingBox;
    if (box) {
      out.keyOriginShapeBBox = {
        unitValueQuadVersion: 1,
        "Top ": unitsValue(box.top, "top"),
        Left: unitsValue(box.left, "left"),
        Btom: unitsValue(box.bottom, "bottom"),
        Rght: unitsValue(box.right, "right")
      };
    }
    var corners = item.keyOriginBoxCorners;
    if (corners && corners.length === 4) {
      out.keyOriginBoxCorners = {
        rectangleCornerA: { Hrzn: corners[0].x, Vrtc: corners[0].y },
        rectangleCornerB: { Hrzn: corners[1].x, Vrtc: corners[1].y },
        rectangleCornerC: { Hrzn: corners[2].x, Vrtc: corners[2].y },
        rectangleCornerD: { Hrzn: corners[3].x, Vrtc: corners[3].y }
      };
    }
    var transform2 = item.transform;
    if (transform2 && transform2.length === 6) {
      out.Trnf = {
        xx: transform2[0],
        xy: transform2[1],
        yx: transform2[2],
        yy: transform2[3],
        tx: transform2[4],
        ty: transform2[5]
      };
    }
    if (item.keyShapeInvalidated != null)
      out.keyShapeInvalidated = item.keyShapeInvalidated;
    out.keyOriginIndex = i2;
  }
  writeInt32(writer, 1);
  writeVersionAndDescriptor(writer, "", "null", desc);
});
addHandler("lmfx", function(target) {
  return target.effects !== void 0 && hasMultiEffects(target.effects);
}, function(reader, target, left) {
  var version2 = readUint32(reader);
  if (version2 !== 0)
    throw new Error("Invalid lmfx version");
  var desc = readVersionAndDescriptor(reader);
  target.effects = parseEffects(desc, !!reader.logMissingFeatures);
  skipBytes(reader, left());
}, function(writer, target, _, options) {
  var desc = serializeEffects(target.effects, !!options.logMissingFeatures, true);
  writeUint32(writer, 0);
  writeVersionAndDescriptor(writer, "", "null", desc);
});
addHandler("lrFX", hasKey("effects"), function(reader, target, left) {
  if (!target.effects)
    target.effects = readEffects(reader);
  skipBytes(reader, left());
}, function(writer, target) {
  writeEffects(writer, target.effects);
});
addHandler("luni", hasKey("name"), function(reader, target, left) {
  if (left() > 4) {
    var length_1 = readUint32(reader);
    if (left() >= length_1 * 2) {
      target.name = readUnicodeStringWithLength(reader, length_1);
    } else {
      if (reader.logDevFeatures)
        reader.log("name in luni section is too long");
    }
  } else {
    if (reader.logDevFeatures)
      reader.log("empty luni section");
  }
  skipBytes(reader, left());
}, function(writer, target) {
  writeUnicodeString(writer, target.name);
});
addHandler("lnsr", hasKey("nameSource"), function(reader, target) {
  return target.nameSource = readSignature(reader);
}, function(writer, target) {
  return writeSignature(writer, target.nameSource);
});
addHandler("lyid", hasKey("id"), function(reader, target) {
  target.id = readUint32(reader);
}, function(writer, target, _psd, options) {
  var id = target.id;
  while (options.layerIds.has(id))
    id += 100;
  writeUint32(writer, id);
  options.layerIds.add(id);
  options.layerToId.set(target, id);
});
addHandler("lsct", hasKey("sectionDivider"), function(reader, target, left) {
  target.sectionDivider = { type: readUint32(reader) };
  if (left()) {
    checkSignature(reader, "8BIM");
    target.sectionDivider.key = readSignature(reader);
  }
  if (left()) {
    target.sectionDivider.subType = readUint32(reader);
  }
}, function(writer, target) {
  writeUint32(writer, target.sectionDivider.type);
  if (target.sectionDivider.key) {
    writeSignature(writer, "8BIM");
    writeSignature(writer, target.sectionDivider.key);
    if (target.sectionDivider.subType !== void 0) {
      writeUint32(writer, target.sectionDivider.subType);
    }
  }
});
addHandlerAlias("lsdk", "lsct");
addHandler("clbl", hasKey("blendClippendElements"), function(reader, target) {
  target.blendClippendElements = !!readUint8(reader);
  skipBytes(reader, 3);
}, function(writer, target) {
  writeUint8(writer, target.blendClippendElements ? 1 : 0);
  writeZeros(writer, 3);
});
addHandler("infx", hasKey("blendInteriorElements"), function(reader, target) {
  target.blendInteriorElements = !!readUint8(reader);
  skipBytes(reader, 3);
}, function(writer, target) {
  writeUint8(writer, target.blendInteriorElements ? 1 : 0);
  writeZeros(writer, 3);
});
addHandler("knko", hasKey("knockout"), function(reader, target) {
  target.knockout = !!readUint8(reader);
  skipBytes(reader, 3);
}, function(writer, target) {
  writeUint8(writer, target.knockout ? 1 : 0);
  writeZeros(writer, 3);
});
addHandler("lmgm", hasKey("layerMaskAsGlobalMask"), function(reader, target) {
  target.layerMaskAsGlobalMask = !!readUint8(reader);
  skipBytes(reader, 3);
}, function(writer, target) {
  writeUint8(writer, target.layerMaskAsGlobalMask ? 1 : 0);
  writeZeros(writer, 3);
});
addHandler("lspf", hasKey("protected"), function(reader, target) {
  var flags = readUint32(reader);
  target.protected = {
    transparency: (flags & 1) !== 0,
    composite: (flags & 2) !== 0,
    position: (flags & 4) !== 0
  };
  if (flags & 8)
    target.protected.artboards = true;
}, function(writer, target) {
  var flags = (target.protected.transparency ? 1 : 0) | (target.protected.composite ? 2 : 0) | (target.protected.position ? 4 : 0) | (target.protected.artboards ? 8 : 0);
  writeUint32(writer, flags);
});
addHandler("lclr", hasKey("layerColor"), function(reader, target) {
  var color = readUint16(reader);
  skipBytes(reader, 6);
  target.layerColor = layerColors[color];
}, function(writer, target) {
  var index = layerColors.indexOf(target.layerColor);
  writeUint16(writer, index === -1 ? 0 : index);
  writeZeros(writer, 6);
});
addHandler(
  "shmd",
  // Metadata setting
  function(target) {
    return target.timestamp !== void 0 || target.animationFrames !== void 0 || target.animationFrameFlags !== void 0 || target.timeline !== void 0 || target.comps !== void 0;
  },
  function(reader, target, left) {
    var count = readUint32(reader);
    var _loop_1 = function(i3) {
      checkSignature(reader, "8BIM");
      var key = readSignature(reader);
      readUint8(reader);
      skipBytes(reader, 3);
      readSection(reader, 1, function(left2) {
        if (key === "cust") {
          var desc = readVersionAndDescriptor(reader);
          if (desc.layerTime !== void 0)
            target.timestamp = desc.layerTime;
        } else if (key === "mlst") {
          var desc = readVersionAndDescriptor(reader);
          target.animationFrames = [];
          for (var i_1 = 0; i_1 < desc.LaSt.length; i_1++) {
            var f2 = desc.LaSt[i_1];
            var frame = { frames: f2.FrLs };
            if (f2.enab !== void 0)
              frame.enable = f2.enab;
            if (f2.Ofst)
              frame.offset = horzVrtcToXY(f2.Ofst);
            if (f2.FXRf)
              frame.referencePoint = horzVrtcToXY(f2.FXRf);
            if (f2.Lefx)
              frame.effects = parseEffects(f2.Lefx, !!reader.logMissingFeatures);
            if (f2.blendOptions && f2.blendOptions.Opct)
              frame.opacity = parsePercent(f2.blendOptions.Opct);
            target.animationFrames.push(frame);
          }
        } else if (key === "mdyn") {
          readUint16(reader);
          var propagate = readUint8(reader);
          var flags = readUint8(reader);
          target.animationFrameFlags = {
            propagateFrameOne: !propagate,
            unifyLayerPosition: (flags & 1) !== 0,
            unifyLayerStyle: (flags & 2) !== 0,
            unifyLayerVisibility: (flags & 4) !== 0
          };
        } else if (key === "tmln") {
          var desc = readVersionAndDescriptor(reader);
          var timeScope = desc.timeScope;
          var timeline = {
            start: frac(timeScope.Strt),
            duration: frac(timeScope.duration),
            inTime: frac(timeScope.inTime),
            outTime: frac(timeScope.outTime),
            autoScope: desc.autoScope,
            audioLevel: desc.audioLevel
          };
          if (desc.trackList) {
            timeline.tracks = parseTrackList(desc.trackList, !!reader.logMissingFeatures);
          }
          target.timeline = timeline;
        } else if (key === "cmls") {
          var desc = readVersionAndDescriptor(reader);
          target.comps = {
            settings: []
          };
          if (desc.origFXRefPoint)
            target.comps.originalEffectsReferencePoint = { x: desc.origFXRefPoint.Hrzn, y: desc.origFXRefPoint.Vrtc };
          for (var _i = 0, _a = desc.layerSettings; _i < _a.length; _i++) {
            var item = _a[_i];
            target.comps.settings.push({ compList: item.compList });
            var t2 = target.comps.settings[target.comps.settings.length - 1];
            if ("enab" in item)
              t2.enabled = item.enab;
            if (item.Ofst)
              t2.offset = { x: item.Ofst.Hrzn, y: item.Ofst.Vrtc };
            if (item.FXRefPoint)
              t2.effectsReferencePoint = { x: item.FXRefPoint.Hrzn, y: item.FXRefPoint.Vrtc };
          }
        } else if (key === "extn") {
          var desc = readVersionAndDescriptor(reader);
          reader.logMissingFeatures && reader.log('Unhandled "shmd" section key', key);
        } else {
          reader.logMissingFeatures && reader.log('Unhandled "shmd" section key', key);
        }
        skipBytes(reader, left2());
      });
    };
    for (var i2 = 0; i2 < count; i2++) {
      _loop_1();
    }
    skipBytes(reader, left());
  },
  function(writer, target, _, options) {
    var animationFrames = target.animationFrames, animationFrameFlags = target.animationFrameFlags, timestamp = target.timestamp, timeline = target.timeline, comps = target.comps;
    var count = 0;
    if (animationFrames)
      count++;
    if (animationFrameFlags)
      count++;
    if (timeline)
      count++;
    if (timestamp !== void 0)
      count++;
    if (comps)
      count++;
    writeUint32(writer, count);
    if (animationFrames) {
      writeSignature(writer, "8BIM");
      writeSignature(writer, "mlst");
      writeUint8(writer, 0);
      writeZeros(writer, 3);
      writeSection(writer, 2, function() {
        var _a;
        var desc = {
          LaID: (_a = target.id) !== null && _a !== void 0 ? _a : 0,
          LaSt: []
        };
        for (var i2 = 0; i2 < animationFrames.length; i2++) {
          var f2 = animationFrames[i2];
          var frame = {};
          if (f2.enable !== void 0)
            frame.enab = f2.enable;
          frame.FrLs = f2.frames;
          if (f2.offset)
            frame.Ofst = xyToHorzVrtc(f2.offset);
          if (f2.referencePoint)
            frame.FXRf = xyToHorzVrtc(f2.referencePoint);
          if (f2.effects)
            frame.Lefx = serializeEffects(f2.effects, false, false);
          if (f2.opacity !== void 0)
            frame.blendOptions = { Opct: unitsPercent(f2.opacity) };
          desc.LaSt.push(frame);
        }
        writeVersionAndDescriptor(writer, "", "null", desc);
      }, true);
    }
    if (animationFrameFlags) {
      writeSignature(writer, "8BIM");
      writeSignature(writer, "mdyn");
      writeUint8(writer, 0);
      writeZeros(writer, 3);
      writeSection(writer, 2, function() {
        writeUint16(writer, 0);
        writeUint8(writer, animationFrameFlags.propagateFrameOne ? 0 : 15);
        writeUint8(writer, (animationFrameFlags.unifyLayerPosition ? 1 : 0) | (animationFrameFlags.unifyLayerStyle ? 2 : 0) | (animationFrameFlags.unifyLayerVisibility ? 4 : 0));
      });
    }
    if (timeline) {
      writeSignature(writer, "8BIM");
      writeSignature(writer, "tmln");
      writeUint8(writer, 0);
      writeZeros(writer, 3);
      writeSection(writer, 2, function() {
        var desc = {
          Vrsn: 1,
          timeScope: {
            Vrsn: 1,
            Strt: timeline.start,
            duration: timeline.duration,
            inTime: timeline.inTime,
            outTime: timeline.outTime
          },
          autoScope: timeline.autoScope,
          audioLevel: timeline.audioLevel
        };
        if (timeline.tracks) {
          desc.trackList = serializeTrackList(timeline.tracks);
        }
        var id = options.layerToId.get(target) || target.id;
        if (!id)
          throw new Error("You need to provide layer.id value whan writing document with animations");
        desc.LyrI = id;
        writeVersionAndDescriptor(writer, "", "null", desc, "anim");
      }, true);
    }
    if (timestamp !== void 0) {
      writeSignature(writer, "8BIM");
      writeSignature(writer, "cust");
      writeUint8(writer, 0);
      writeZeros(writer, 3);
      writeSection(writer, 2, function() {
        var desc = {
          layerTime: timestamp
        };
        writeVersionAndDescriptor(writer, "", "metadata", desc);
      }, true);
    }
    if (comps) {
      writeSignature(writer, "8BIM");
      writeSignature(writer, "cmls");
      writeUint8(writer, 0);
      writeZeros(writer, 3);
      writeSection(writer, 2, function() {
        var id = options.layerToId.get(target) || target.id;
        if (!id)
          throw new Error("You need to provide layer.id value whan writing document with layer comps");
        var desc = {};
        if (comps.originalEffectsReferencePoint) {
          desc.origFXRefPoint = { Hrzn: comps.originalEffectsReferencePoint.x, Vrtc: comps.originalEffectsReferencePoint.y };
        }
        desc.LyrI = id;
        desc.layerSettings = [];
        for (var _i = 0, _a = comps.settings; _i < _a.length; _i++) {
          var item = _a[_i];
          var t2 = {};
          if (item.enabled !== void 0)
            t2.enab = item.enabled;
          if (item.offset)
            t2.Ofst = { Hrzn: item.offset.x, Vrtc: item.offset.y };
          if (item.effectsReferencePoint)
            t2.FXRefPoint = { Hrzn: item.effectsReferencePoint.x, Vrtc: item.effectsReferencePoint.y };
          t2.compList = item.compList;
          desc.layerSettings.push(t2);
        }
        writeVersionAndDescriptor(writer, "", "null", desc);
      }, true);
    }
  }
);
addHandler("PxSc", function() {
  return false;
}, function(reader, target) {
  var desc = readVersionAndDescriptor(reader, true);
  if (desc.pixelSourceType === 1986285651) {
    target.pixelSource = {
      type: "vdPS",
      origin: { x: desc.origin.Hrzn, y: desc.origin.Vrtc },
      interpretation: {
        interpretAlpha: desc.interpretation.interpretAlpha.split(".")[1],
        profile: desc.interpretation.profile
      },
      frameReader: {
        type: "QTFR",
        link: {
          name: desc.frameReader["Lnk "]["Nm  "],
          fullPath: desc.frameReader["Lnk "].fullPath,
          originalPath: desc.frameReader["Lnk "].originalPath,
          relativePath: desc.frameReader["Lnk "].relPath,
          alias: desc.frameReader["Lnk "].alis
        },
        mediaDescriptor: desc.frameReader.mediaDescriptor
      },
      showAlteredVideo: desc.showAlteredVideo
    };
  } else {
    reader.log("Unknown pixelSourceType");
  }
}, function(writer, target) {
  var source = target.pixelSource;
  var desc = {
    _name: "",
    _classID: "PixelSource",
    pixelSourceType: 1986285651,
    descVersion: 1,
    origin: { Hrzn: source.origin.x, Vrtc: source.origin.y },
    interpretation: {
      _name: "",
      _classID: "footageInterpretation",
      Vrsn: 1,
      interpretAlpha: "alphaInterpretation.".concat(source.interpretation.interpretAlpha),
      profile: source.interpretation.profile
    },
    frameReader: {
      _name: "",
      _classID: "FrameReader",
      frameReaderType: 1364477522,
      descVersion: 1,
      "Lnk ": {
        _name: "",
        _classID: "ExternalFileLink",
        descVersion: 2,
        "Nm  ": source.frameReader.link.name,
        fullPath: source.frameReader.link.fullPath,
        originalPath: source.frameReader.link.originalPath,
        alis: source.frameReader.link.alias,
        relPath: source.frameReader.link.relativePath
      },
      mediaDescriptor: source.frameReader.mediaDescriptor
    },
    showAlteredVideo: source.showAlteredVideo
  };
  writeVersionAndDescriptor(writer, "", "PixelSource", desc);
});
addHandler("vstk", hasKey("vectorStroke"), function(reader, target, left) {
  var desc = readVersionAndDescriptor(reader);
  target.vectorStroke = {
    strokeEnabled: desc.strokeEnabled,
    fillEnabled: desc.fillEnabled,
    lineWidth: parseUnits(desc.strokeStyleLineWidth),
    lineDashOffset: parseUnits(desc.strokeStyleLineDashOffset),
    miterLimit: desc.strokeStyleMiterLimit,
    lineCapType: strokeStyleLineCapType.decode(desc.strokeStyleLineCapType),
    lineJoinType: strokeStyleLineJoinType.decode(desc.strokeStyleLineJoinType),
    lineAlignment: strokeStyleLineAlignment.decode(desc.strokeStyleLineAlignment),
    scaleLock: desc.strokeStyleScaleLock,
    strokeAdjust: desc.strokeStyleStrokeAdjust,
    lineDashSet: desc.strokeStyleLineDashSet.map(parseUnits),
    blendMode: BlnM.decode(desc.strokeStyleBlendMode),
    opacity: parsePercent(desc.strokeStyleOpacity),
    content: parseVectorContent(desc.strokeStyleContent),
    resolution: desc.strokeStyleResolution
  };
  skipBytes(reader, left());
}, function(writer, target) {
  var _a, _b, _c;
  var stroke = target.vectorStroke;
  var desc = {
    strokeStyleVersion: 2,
    strokeEnabled: !!stroke.strokeEnabled,
    fillEnabled: !!stroke.fillEnabled,
    strokeStyleLineWidth: stroke.lineWidth || { value: 3, units: "Points" },
    strokeStyleLineDashOffset: stroke.lineDashOffset || { value: 0, units: "Points" },
    strokeStyleMiterLimit: (_a = stroke.miterLimit) !== null && _a !== void 0 ? _a : 100,
    strokeStyleLineCapType: strokeStyleLineCapType.encode(stroke.lineCapType),
    strokeStyleLineJoinType: strokeStyleLineJoinType.encode(stroke.lineJoinType),
    strokeStyleLineAlignment: strokeStyleLineAlignment.encode(stroke.lineAlignment),
    strokeStyleScaleLock: !!stroke.scaleLock,
    strokeStyleStrokeAdjust: !!stroke.strokeAdjust,
    strokeStyleLineDashSet: stroke.lineDashSet || [],
    strokeStyleBlendMode: BlnM.encode(stroke.blendMode),
    strokeStyleOpacity: unitsPercent((_b = stroke.opacity) !== null && _b !== void 0 ? _b : 1),
    strokeStyleContent: serializeVectorContent(stroke.content || { type: "color", color: { r: 0, g: 0, b: 0 } }).descriptor,
    strokeStyleResolution: (_c = stroke.resolution) !== null && _c !== void 0 ? _c : 72
  };
  writeVersionAndDescriptor(writer, "", "strokeStyle", desc);
});
addHandler(
  "artb",
  // per-layer arboard info
  hasKey("artboard"),
  function(reader, target, left) {
    var desc = readVersionAndDescriptor(reader);
    var rect = desc.artboardRect;
    target.artboard = {
      rect: { top: rect["Top "], left: rect.Left, bottom: rect.Btom, right: rect.Rght },
      guideIndices: desc.guideIndeces,
      presetName: desc.artboardPresetName,
      color: parseColor(desc["Clr "]),
      backgroundType: desc.artboardBackgroundType
    };
    skipBytes(reader, left());
  },
  function(writer, target) {
    var _a;
    var artboard = target.artboard;
    var rect = artboard.rect;
    var desc = {
      artboardRect: { "Top ": rect.top, Left: rect.left, Btom: rect.bottom, Rght: rect.right },
      guideIndeces: artboard.guideIndices || [],
      artboardPresetName: artboard.presetName || "",
      "Clr ": serializeColor(artboard.color),
      artboardBackgroundType: (_a = artboard.backgroundType) !== null && _a !== void 0 ? _a : 1
    };
    writeVersionAndDescriptor(writer, "", "artboard", desc);
  }
);
addHandler("sn2P", hasKey("usingAlignedRendering"), function(reader, target) {
  return target.usingAlignedRendering = !!readUint32(reader);
}, function(writer, target) {
  return writeUint32(writer, target.usingAlignedRendering ? 1 : 0);
});
var placedLayerTypes = ["unknown", "vector", "raster", "image stack"];
function parseWarp(warp) {
  var _a, _b, _c, _d, _e, _f;
  var result = __assign$3(__assign$3({ style: warpStyle.decode(warp.warpStyle) }, warp.warpValues ? { values: warp.warpValues } : { value: warp.warpValue || 0 }), { perspective: warp.warpPerspective || 0, perspectiveOther: warp.warpPerspectiveOther || 0, rotate: Ornt.decode(warp.warpRotate), bounds: warp.bounds && {
    top: parseUnitsOrNumber(warp.bounds["Top "]),
    left: parseUnitsOrNumber(warp.bounds.Left),
    bottom: parseUnitsOrNumber(warp.bounds.Btom),
    right: parseUnitsOrNumber(warp.bounds.Rght)
  }, uOrder: warp.uOrder, vOrder: warp.vOrder });
  if (warp.deformNumRows != null || warp.deformNumCols != null) {
    result.deformNumRows = warp.deformNumRows;
    result.deformNumCols = warp.deformNumCols;
  }
  var envelopeWarp = warp.customEnvelopeWarp;
  if (envelopeWarp) {
    result.customEnvelopeWarp = {
      meshPoints: []
    };
    var xs = ((_a = envelopeWarp.meshPoints.find(function(i3) {
      return i3.type === "Hrzn";
    })) === null || _a === void 0 ? void 0 : _a.values) || [];
    var ys = ((_b = envelopeWarp.meshPoints.find(function(i3) {
      return i3.type === "Vrtc";
    })) === null || _b === void 0 ? void 0 : _b.values) || [];
    for (var i2 = 0; i2 < xs.length; i2++) {
      result.customEnvelopeWarp.meshPoints.push({ x: xs[i2], y: ys[i2] });
    }
    if (envelopeWarp.quiltSliceX || envelopeWarp.quiltSliceY) {
      result.customEnvelopeWarp.quiltSliceX = ((_d = (_c = envelopeWarp.quiltSliceX) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.values) || [];
      result.customEnvelopeWarp.quiltSliceY = ((_f = (_e = envelopeWarp.quiltSliceY) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.values) || [];
    }
  }
  return result;
}
function isQuiltWarp(warp) {
  var _a, _b;
  return warp.deformNumCols != null || warp.deformNumRows != null || ((_a = warp.customEnvelopeWarp) === null || _a === void 0 ? void 0 : _a.quiltSliceX) || ((_b = warp.customEnvelopeWarp) === null || _b === void 0 ? void 0 : _b.quiltSliceY);
}
function encodeWarp(warp) {
  var bounds = warp.bounds;
  var desc = __assign$3(__assign$3({ warpStyle: warpStyle.encode(warp.style) }, warp.values ? { warpValues: warp.values } : { warpValue: warp.value || 0 }), { warpPerspective: warp.perspective || 0, warpPerspectiveOther: warp.perspectiveOther || 0, warpRotate: Ornt.encode(warp.rotate), bounds: (
    /*1 ? { // testing
        _classID: 'classFloatRect',
        'Top ': bounds && bounds.top && bounds.top.value || 0,
        Left: bounds && bounds.left && bounds.left.value || 0,
        Btom: bounds && bounds.bottom && bounds.bottom.value || 0,
        Rght: bounds && bounds.right && bounds.right.value || 0,
    } :*/
    {
      "Top ": unitsValue(bounds && bounds.top || { units: "Pixels", value: 0 }, "bounds.top"),
      Left: unitsValue(bounds && bounds.left || { units: "Pixels", value: 0 }, "bounds.left"),
      Btom: unitsValue(bounds && bounds.bottom || { units: "Pixels", value: 0 }, "bounds.bottom"),
      Rght: unitsValue(bounds && bounds.right || { units: "Pixels", value: 0 }, "bounds.right")
    }
  ), uOrder: warp.uOrder || 0, vOrder: warp.vOrder || 0 });
  var isQuilt = isQuiltWarp(warp);
  if (isQuilt) {
    var desc2 = desc;
    desc2.deformNumRows = warp.deformNumRows || 0;
    desc2.deformNumCols = warp.deformNumCols || 0;
  }
  var customEnvelopeWarp = warp.customEnvelopeWarp;
  if (customEnvelopeWarp) {
    var meshPoints = customEnvelopeWarp.meshPoints || [];
    if (isQuilt) {
      var desc2 = desc;
      desc2.customEnvelopeWarp = {
        _name: "",
        _classID: "customEnvelopeWarp",
        quiltSliceX: [{
          type: "quiltSliceX",
          values: customEnvelopeWarp.quiltSliceX || []
        }],
        quiltSliceY: [{
          type: "quiltSliceY",
          values: customEnvelopeWarp.quiltSliceY || []
        }],
        meshPoints: [
          { type: "Hrzn", values: meshPoints.map(function(p2) {
            return p2.x;
          }) },
          { type: "Vrtc", values: meshPoints.map(function(p2) {
            return p2.y;
          }) }
        ]
      };
    } else {
      desc.customEnvelopeWarp = {
        _name: "",
        _classID: "customEnvelopeWarp",
        meshPoints: [
          { type: "Hrzn", values: meshPoints.map(function(p2) {
            return p2.x;
          }) },
          { type: "Vrtc", values: meshPoints.map(function(p2) {
            return p2.y;
          }) }
        ]
      };
    }
  }
  return desc;
}
addHandler("PlLd", hasKey("placedLayer"), function(reader, target, left) {
  if (readSignature(reader) !== "plcL")
    throw new Error("Invalid PlLd signature");
  if (readInt32(reader) !== 3)
    throw new Error("Invalid PlLd version");
  var id = readPascalString(reader, 1);
  var pageNumber = readInt32(reader);
  var totalPages = readInt32(reader);
  readInt32(reader);
  var placedLayerType = readInt32(reader);
  if (!placedLayerTypes[placedLayerType])
    throw new Error("Invalid PlLd type");
  var transform2 = [];
  for (var i2 = 0; i2 < 8; i2++)
    transform2.push(readFloat64(reader));
  var warpVersion = readInt32(reader);
  if (warpVersion !== 0)
    throw new Error("Invalid Warp version ".concat(warpVersion));
  var warp = readVersionAndDescriptor(reader);
  target.placedLayer = target.placedLayer || {
    id,
    type: placedLayerTypes[placedLayerType],
    pageNumber,
    totalPages,
    transform: transform2,
    warp: parseWarp(warp)
  };
  skipBytes(reader, left());
}, function(writer, target) {
  var placed = target.placedLayer;
  writeSignature(writer, "plcL");
  writeInt32(writer, 3);
  if (!placed.id || typeof placed.id !== "string" || !/^[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/.test(placed.id)) {
    throw new Error("Placed layer ID must be in a GUID format (example: 20953ddb-9391-11ec-b4f1-c15674f50bc4)");
  }
  writePascalString(writer, placed.id, 1);
  writeInt32(writer, 1);
  writeInt32(writer, 1);
  writeInt32(writer, 16);
  if (placedLayerTypes.indexOf(placed.type) === -1)
    throw new Error("Invalid placedLayer type");
  writeInt32(writer, placedLayerTypes.indexOf(placed.type));
  for (var i2 = 0; i2 < 8; i2++)
    writeFloat64(writer, placed.transform[i2]);
  writeInt32(writer, 0);
  var warp = getWarpFromPlacedLayer(placed);
  var isQuilt = isQuiltWarp(warp);
  var type = isQuilt ? "quiltWarp" : "warp";
  writeVersionAndDescriptor(writer, "", type, encodeWarp(warp), type);
});
function uint8ToFloat32(array) {
  return new Float32Array(array.buffer.slice(array.byteOffset), 0, array.byteLength / 4);
}
function uint8ToUint32(array) {
  return new Uint32Array(array.buffer.slice(array.byteOffset), 0, array.byteLength / 4);
}
function toUint8(array) {
  return new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
}
function arrayToPoints(array) {
  var points = [];
  for (var i2 = 0; i2 < array.length; i2 += 2) {
    points.push({ x: array[i2], y: array[i2 + 1] });
  }
  return points;
}
function pointsToArray(points) {
  var array = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    array.push(points[i2].x, points[i2].y);
  }
  return array;
}
function uint8ToPoints(array) {
  return arrayToPoints(uint8ToFloat32(array));
}
function hrznVrtcToPoint(desc) {
  return {
    x: parseUnits(desc.Hrzn),
    y: parseUnits(desc.Vrtc)
  };
}
function pointToHrznVrtc(point) {
  return {
    _name: "",
    _classID: "Pnt ",
    Hrzn: unitsValue(point.x, "x"),
    Vrtc: unitsValue(point.y, "y")
  };
}
function parseFilterFXItem(f2, options) {
  var base = {
    name: f2["Nm  "],
    opacity: parsePercent(f2.blendOptions.Opct),
    blendMode: BlnM.decode(f2.blendOptions["Md  "]),
    enabled: f2.enab,
    hasOptions: f2.hasoptions,
    foregroundColor: parseColor(f2.FrgC),
    backgroundColor: parseColor(f2.BckC)
  };
  if ("Fltr" in f2) {
    switch (f2.Fltr._classID) {
      case "boxblur":
        return __assign$3(__assign$3({}, base), { type: "box blur", filter: {
          radius: parseUnits(f2.Fltr["Rds "])
        } });
      case "GsnB":
        return __assign$3(__assign$3({}, base), { type: "gaussian blur", filter: {
          radius: parseUnits(f2.Fltr["Rds "])
        } });
      case "MtnB":
        return __assign$3(__assign$3({}, base), { type: "motion blur", filter: {
          angle: f2.Fltr.Angl,
          distance: parseUnits(f2.Fltr.Dstn)
        } });
      case "RdlB":
        return __assign$3(__assign$3({}, base), { type: "radial blur", filter: {
          amount: f2.Fltr.Amnt,
          method: BlrM.decode(f2.Fltr.BlrM),
          quality: BlrQ.decode(f2.Fltr.BlrQ)
        } });
      case "shapeBlur":
        return __assign$3(__assign$3({}, base), { type: "shape blur", filter: {
          radius: parseUnits(f2.Fltr["Rds "]),
          customShape: { name: f2.Fltr.customShape["Nm  "], id: f2.Fltr.customShape.Idnt }
        } });
      case "SmrB":
        return __assign$3(__assign$3({}, base), { type: "smart blur", filter: {
          radius: f2.Fltr["Rds "],
          threshold: f2.Fltr.Thsh,
          quality: SmBQ.decode(f2.Fltr.SmBQ),
          mode: SmBM.decode(f2.Fltr.SmBM)
        } });
      case "surfaceBlur":
        return __assign$3(__assign$3({}, base), { type: "surface blur", filter: {
          radius: parseUnits(f2.Fltr["Rds "]),
          threshold: f2.Fltr.Thsh
        } });
      case "Dspl":
        return __assign$3(__assign$3({}, base), { type: "displace", filter: {
          horizontalScale: f2.Fltr.HrzS,
          verticalScale: f2.Fltr.VrtS,
          displacementMap: DspM.decode(f2.Fltr.DspM),
          undefinedAreas: UndA.decode(f2.Fltr.UndA),
          displacementFile: {
            signature: f2.Fltr.DspF.sig,
            path: f2.Fltr.DspF.path
            // TODO: this is decoded incorrectly ???
          }
        } });
      case "Pnch":
        return __assign$3(__assign$3({}, base), { type: "pinch", filter: {
          amount: f2.Fltr.Amnt
        } });
      case "Plr ":
        return __assign$3(__assign$3({}, base), { type: "polar coordinates", filter: {
          conversion: Cnvr.decode(f2.Fltr.Cnvr)
        } });
      case "Rple":
        return __assign$3(__assign$3({}, base), { type: "ripple", filter: {
          amount: f2.Fltr.Amnt,
          size: RplS.decode(f2.Fltr.RplS)
        } });
      case "Shr ":
        return __assign$3(__assign$3({}, base), { type: "shear", filter: {
          shearPoints: f2.Fltr.ShrP.map(function(p2) {
            return { x: p2.Hrzn, y: p2.Vrtc };
          }),
          shearStart: f2.Fltr.ShrS,
          shearEnd: f2.Fltr.ShrE,
          undefinedAreas: UndA.decode(f2.Fltr.UndA)
        } });
      case "Sphr":
        return __assign$3(__assign$3({}, base), { type: "spherize", filter: {
          amount: f2.Fltr.Amnt,
          mode: SphM.decode(f2.Fltr.SphM)
        } });
      case "Twrl":
        return __assign$3(__assign$3({}, base), { type: "twirl", filter: {
          angle: f2.Fltr.Angl
        } });
      case "Wave":
        return __assign$3(__assign$3({}, base), { type: "wave", filter: {
          numberOfGenerators: f2.Fltr.NmbG,
          type: Wvtp.decode(f2.Fltr.Wvtp),
          wavelength: { min: f2.Fltr.WLMn, max: f2.Fltr.WLMx },
          amplitude: { min: f2.Fltr.AmMn, max: f2.Fltr.AmMx },
          scale: { x: f2.Fltr.SclH, y: f2.Fltr.SclV },
          randomSeed: f2.Fltr.RndS,
          undefinedAreas: UndA.decode(f2.Fltr.UndA)
        } });
      case "ZgZg":
        return __assign$3(__assign$3({}, base), { type: "zigzag", filter: {
          amount: f2.Fltr.Amnt,
          ridges: f2.Fltr.NmbR,
          style: ZZTy.decode(f2.Fltr.ZZTy)
        } });
      case "AdNs":
        return __assign$3(__assign$3({}, base), { type: "add noise", filter: {
          amount: parsePercent(f2.Fltr.Nose),
          distribution: Dstr.decode(f2.Fltr.Dstr),
          monochromatic: f2.Fltr.Mnch,
          randomSeed: f2.Fltr.FlRs
        } });
      case "DstS":
        return __assign$3(__assign$3({}, base), { type: "dust and scratches", filter: {
          radius: f2.Fltr["Rds "],
          threshold: f2.Fltr.Thsh
        } });
      case "Mdn ":
        return __assign$3(__assign$3({}, base), { type: "median", filter: {
          radius: parseUnits(f2.Fltr["Rds "])
        } });
      case "denoise":
        return __assign$3(__assign$3({}, base), { type: "reduce noise", filter: {
          preset: f2.Fltr.preset,
          removeJpegArtifact: f2.Fltr.removeJPEGArtifact,
          reduceColorNoise: parsePercent(f2.Fltr.ClNs),
          sharpenDetails: parsePercent(f2.Fltr.Shrp),
          channelDenoise: f2.Fltr.channelDenoise.map(function(c2) {
            return __assign$3({ channels: c2.Chnl.map(Chnl.decode), amount: c2.Amnt }, c2.EdgF ? { preserveDetails: c2.EdgF } : {});
          })
        } });
      case "ClrH":
        return __assign$3(__assign$3({}, base), { type: "color halftone", filter: {
          radius: f2.Fltr["Rds "],
          angle1: f2.Fltr.Ang1,
          angle2: f2.Fltr.Ang2,
          angle3: f2.Fltr.Ang3,
          angle4: f2.Fltr.Ang4
        } });
      case "Crst":
        return __assign$3(__assign$3({}, base), { type: "crystallize", filter: {
          cellSize: f2.Fltr.ClSz,
          randomSeed: f2.Fltr.FlRs
        } });
      case "Mztn":
        return __assign$3(__assign$3({}, base), { type: "mezzotint", filter: {
          type: MztT.decode(f2.Fltr.MztT),
          randomSeed: f2.Fltr.FlRs
        } });
      case "Msc ":
        return __assign$3(__assign$3({}, base), { type: "mosaic", filter: {
          cellSize: parseUnits(f2.Fltr.ClSz)
        } });
      case "Pntl":
        return __assign$3(__assign$3({}, base), { type: "pointillize", filter: {
          cellSize: f2.Fltr.ClSz,
          randomSeed: f2.Fltr.FlRs
        } });
      case "Clds":
        return __assign$3(__assign$3({}, base), { type: "clouds", filter: {
          randomSeed: f2.Fltr.FlRs
        } });
      case "DfrC":
        return __assign$3(__assign$3({}, base), { type: "difference clouds", filter: {
          randomSeed: f2.Fltr.FlRs
        } });
      case "Fbrs":
        return __assign$3(__assign$3({}, base), { type: "fibers", filter: {
          variance: f2.Fltr.Vrnc,
          strength: f2.Fltr.Strg,
          randomSeed: f2.Fltr.RndS
        } });
      case "LnsF":
        return __assign$3(__assign$3({}, base), { type: "lens flare", filter: {
          brightness: f2.Fltr.Brgh,
          position: { x: f2.Fltr.FlrC.Hrzn, y: f2.Fltr.FlrC.Vrtc },
          lensType: Lns.decode(f2.Fltr["Lns "])
        } });
      case "smartSharpen":
        return __assign$3(__assign$3({}, base), { type: "smart sharpen", filter: {
          amount: parsePercent(f2.Fltr.Amnt),
          radius: parseUnits(f2.Fltr["Rds "]),
          threshold: f2.Fltr.Thsh,
          angle: f2.Fltr.Angl,
          moreAccurate: f2.Fltr.moreAccurate,
          blur: blurType.decode(f2.Fltr.blur),
          preset: f2.Fltr.preset,
          shadow: {
            fadeAmount: parsePercent(f2.Fltr.sdwM.Amnt),
            tonalWidth: parsePercent(f2.Fltr.sdwM.Wdth),
            radius: f2.Fltr.sdwM["Rds "]
          },
          highlight: {
            fadeAmount: parsePercent(f2.Fltr.hglM.Amnt),
            tonalWidth: parsePercent(f2.Fltr.hglM.Wdth),
            radius: f2.Fltr.hglM["Rds "]
          }
        } });
      case "UnsM":
        return __assign$3(__assign$3({}, base), { type: "unsharp mask", filter: {
          amount: parsePercent(f2.Fltr.Amnt),
          radius: parseUnits(f2.Fltr["Rds "]),
          threshold: f2.Fltr.Thsh
        } });
      case "Dfs ":
        return __assign$3(__assign$3({}, base), { type: "diffuse", filter: {
          mode: DfsM.decode(f2.Fltr["Md  "]),
          randomSeed: f2.Fltr.FlRs
        } });
      case "Embs":
        return __assign$3(__assign$3({}, base), { type: "emboss", filter: {
          angle: f2.Fltr.Angl,
          height: f2.Fltr.Hght,
          amount: f2.Fltr.Amnt
        } });
      case "Extr":
        return __assign$3(__assign$3({}, base), { type: "extrude", filter: {
          type: ExtT.decode(f2.Fltr.ExtT),
          size: f2.Fltr.ExtS,
          depth: f2.Fltr.ExtD,
          depthMode: ExtR.decode(f2.Fltr.ExtR),
          randomSeed: f2.Fltr.FlRs,
          solidFrontFaces: f2.Fltr.ExtF,
          maskIncompleteBlocks: f2.Fltr.ExtM
        } });
      case "Tls ":
        return __assign$3(__assign$3({}, base), { type: "tiles", filter: {
          numberOfTiles: f2.Fltr.TlNm,
          maximumOffset: f2.Fltr.TlOf,
          fillEmptyAreaWith: FlCl.decode(f2.Fltr.FlCl),
          randomSeed: f2.Fltr.FlRs
        } });
      case "TrcC":
        return __assign$3(__assign$3({}, base), { type: "trace contour", filter: {
          level: f2.Fltr["Lvl "],
          edge: CntE.decode(f2.Fltr["Edg "])
        } });
      case "Wnd ":
        return __assign$3(__assign$3({}, base), { type: "wind", filter: {
          method: WndM.decode(f2.Fltr.WndM),
          direction: Drct.decode(f2.Fltr.Drct)
        } });
      case "Dntr":
        return __assign$3(__assign$3({}, base), { type: "de-interlace", filter: {
          eliminate: IntE.decode(f2.Fltr.IntE),
          newFieldsBy: IntC.decode(f2.Fltr.IntC)
        } });
      case "Cstm":
        return __assign$3(__assign$3({}, base), { type: "custom", filter: {
          scale: f2.Fltr["Scl "],
          offset: f2.Fltr.Ofst,
          matrix: f2.Fltr.Mtrx
        } });
      case "HghP":
        return __assign$3(__assign$3({}, base), { type: "high pass", filter: {
          radius: parseUnits(f2.Fltr["Rds "])
        } });
      case "Mxm ":
        return __assign$3(__assign$3({}, base), { type: "maximum", filter: {
          radius: parseUnits(f2.Fltr["Rds "])
        } });
      case "Mnm ":
        return __assign$3(__assign$3({}, base), { type: "minimum", filter: {
          radius: parseUnits(f2.Fltr["Rds "])
        } });
      case "Ofst":
        return __assign$3(__assign$3({}, base), { type: "offset", filter: {
          horizontal: f2.Fltr.Hrzn,
          vertical: f2.Fltr.Vrtc,
          undefinedAreas: FlMd.decode(f2.Fltr["Fl  "])
        } });
      case "rigidTransform":
        return __assign$3(__assign$3({}, base), { type: "puppet", filter: {
          rigidType: f2.Fltr.rigidType,
          bounds: [
            { x: f2.Fltr.PuX0, y: f2.Fltr.PuY0 },
            { x: f2.Fltr.PuX1, y: f2.Fltr.PuY1 },
            { x: f2.Fltr.PuX2, y: f2.Fltr.PuY2 },
            { x: f2.Fltr.PuX3, y: f2.Fltr.PuY3 }
          ],
          puppetShapeList: f2.Fltr.puppetShapeList.map(function(p2) {
            return {
              rigidType: p2.rigidType,
              // TODO: VrsM
              // TODO: VrsN
              originalVertexArray: uint8ToPoints(p2.originalVertexArray),
              deformedVertexArray: uint8ToPoints(p2.deformedVertexArray),
              indexArray: Array.from(uint8ToUint32(p2.indexArray)),
              pinOffsets: arrayToPoints(p2.pinOffsets),
              posFinalPins: arrayToPoints(p2.posFinalPins),
              pinVertexIndices: p2.pinVertexIndices,
              selectedPin: p2.selectedPin,
              pinPosition: arrayToPoints(p2.PinP),
              pinRotation: p2.PnRt,
              pinOverlay: p2.PnOv,
              pinDepth: p2.PnDp,
              meshQuality: p2.meshQuality,
              meshExpansion: p2.meshExpansion,
              meshRigidity: p2.meshRigidity,
              imageResolution: p2.imageResolution,
              meshBoundaryPath: {
                pathComponents: p2.meshBoundaryPath.pathComponents.map(function(c2) {
                  return {
                    shapeOperation: c2.shapeOperation.split(".")[1],
                    paths: c2.SbpL.map(function(t2) {
                      return {
                        closed: t2.Clsp,
                        points: t2["Pts "].map(function(pt) {
                          return {
                            anchor: hrznVrtcToPoint(pt.Anch),
                            forward: hrznVrtcToPoint(pt["Fwd "]),
                            backward: hrznVrtcToPoint(pt["Bwd "]),
                            smooth: pt.Smoo
                          };
                        })
                      };
                    })
                  };
                })
              }
            };
          })
        } });
      case "PbPl": {
        var parameters = [];
        var Flrt = f2.Fltr;
        for (var i2 = 0; i2 < fromAtoZ.length; i2++) {
          if (!Flrt["PN".concat(fromAtoZ[i2], "a")])
            break;
          for (var j = 0; j < fromAtoZ.length; j++) {
            if (!Flrt["PN".concat(fromAtoZ[i2]).concat(fromAtoZ[j])])
              break;
            parameters.push({
              name: Flrt["PN".concat(fromAtoZ[i2]).concat(fromAtoZ[j])],
              value: Flrt["PF".concat(fromAtoZ[i2]).concat(fromAtoZ[j])]
            });
          }
        }
        return __assign$3(__assign$3({}, base), { type: "oil paint plugin", filter: {
          name: f2.Fltr.KnNm,
          gpu: f2.Fltr.GpuY,
          lighting: f2.Fltr.LIWy,
          parameters
        } });
      }
      // case 2089: return {
      // 	...base,
      // 	type: 'adaptive wide angle',
      // 	params: {
      // 		correction: prjM.decode(f.Fltr.prjM),
      // 		focalLength: f.Fltr.focL,
      // 		cropFactor: f.Fltr.CrpF,
      // 		imageScale: f.Fltr.imgS,
      // 		imageX: f.Fltr.imgX,
      // 		imageY: f.Fltr.imgY,
      // 	},
      // };
      case "HsbP":
        return __assign$3(__assign$3({}, base), { type: "hsb/hsl", filter: {
          inputMode: ClrS.decode(f2.Fltr.Inpt),
          rowOrder: ClrS.decode(f2.Fltr.Otpt)
        } });
      case "oilPaint":
        return __assign$3(__assign$3({}, base), { type: "oil paint", filter: {
          lightingOn: f2.Fltr.lightingOn,
          stylization: f2.Fltr.stylization,
          cleanliness: f2.Fltr.cleanliness,
          brushScale: f2.Fltr.brushScale,
          microBrush: f2.Fltr.microBrush,
          lightDirection: f2.Fltr.LghD,
          specularity: f2.Fltr.specularity
        } });
      case "LqFy": {
        return __assign$3(__assign$3({}, base), { type: "liquify", filter: {
          liquifyMesh: f2.Fltr.LqMe
        } });
      }
      case "perspectiveWarpTransform": {
        return __assign$3(__assign$3({}, base), { type: "perspective warp", filter: {
          vertices: f2.Fltr.vertices.map(hrznVrtcToPoint),
          warpedVertices: f2.Fltr.warpedVertices.map(hrznVrtcToPoint),
          quads: f2.Fltr.quads.map(function(q) {
            return q.indices;
          })
        } });
      }
      case "Crvs": {
        return __assign$3(__assign$3({}, base), { type: "curves", filter: __assign$3({ presetKind: presetKindType.decode(f2.Fltr.presetKind) }, f2.Fltr.Adjs ? {
          adjustments: f2.Fltr.Adjs.map(function(a2) {
            var channels2 = a2.Chnl.map(Chnl.decode);
            if (a2["Crv "]) {
              return {
                channels: channels2,
                curve: a2["Crv "].map(function(c2) {
                  var point = { x: c2.Hrzn, y: c2.Vrtc };
                  if (c2.Cnty)
                    point.curved = true;
                  return point;
                })
              };
            } else if (a2.Mpng) {
              return { channels: channels2, values: a2.Mpng };
            } else {
              throw new Error("Unknown curve adjustment");
            }
          })
        } : {}) });
      }
      case "BrgC": {
        return __assign$3(__assign$3({}, base), { type: "brightness/contrast", filter: {
          brightness: f2.Fltr.Brgh,
          contrast: f2.Fltr.Cntr,
          useLegacy: !!f2.Fltr.useLegacy
        } });
      }
      default:
        if (options.throwForMissingFeatures) {
          throw new Error("Unknown filter classId: ".concat(f2.Fltr._classID));
        }
        return void 0;
    }
  } else {
    switch (f2.filterID) {
      case 1098281575:
        return __assign$3(__assign$3({}, base), { type: "average" });
      case 1114403360:
        return __assign$3(__assign$3({}, base), { type: "blur" });
      case 1114403405:
        return __assign$3(__assign$3({}, base), { type: "blur more" });
      case 1148416099:
        return __assign$3(__assign$3({}, base), { type: "despeckle" });
      case 1180922912:
        return __assign$3(__assign$3({}, base), { type: "facet" });
      case 1181902701:
        return __assign$3(__assign$3({}, base), { type: "fragment" });
      case 1399353968:
        return __assign$3(__assign$3({}, base), { type: "sharpen" });
      case 1399353925:
        return __assign$3(__assign$3({}, base), { type: "sharpen edges" });
      case 1399353933:
        return __assign$3(__assign$3({}, base), { type: "sharpen more" });
      case 1181639749:
        return __assign$3(__assign$3({}, base), { type: "find edges" });
      case 1399616122:
        return __assign$3(__assign$3({}, base), { type: "solarize" });
      case 1314149187:
        return __assign$3(__assign$3({}, base), { type: "ntsc colors" });
      case 1231976050:
        return __assign$3(__assign$3({}, base), { type: "invert" });
      default:
        if (options.throwForMissingFeatures) {
          throw new Error("Unknown filterID: ".concat(f2.filterID));
        }
    }
  }
}
function parseFilterFX(desc, options) {
  return {
    enabled: desc.enab,
    validAtPosition: desc.validAtPosition,
    maskEnabled: desc.filterMaskEnable,
    maskLinked: desc.filterMaskLinked,
    maskExtendWithWhite: desc.filterMaskExtendWithWhite,
    list: desc.filterFXList.map(function(x2) {
      return parseFilterFXItem(x2, options);
    }).filter(function(x2) {
      return !!x2;
    })
  };
}
function uvRadius(t2) {
  return unitsValue(t2.radius, "radius");
}
function serializeFilterFXItem(f2) {
  var base = {
    _name: "",
    _classID: "filterFX",
    "Nm  ": f2.name,
    blendOptions: {
      _name: "",
      _classID: "blendOptions",
      Opct: unitsPercentF(f2.opacity),
      "Md  ": BlnM.encode(f2.blendMode)
    },
    enab: f2.enabled,
    hasoptions: f2.hasOptions,
    FrgC: serializeColor(f2.foregroundColor),
    BckC: serializeColor(f2.backgroundColor)
  };
  switch (f2.type) {
    case "average":
      return __assign$3(__assign$3({}, base), { filterID: 1098281575 });
    case "blur":
      return __assign$3(__assign$3({}, base), { filterID: 1114403360 });
    case "blur more":
      return __assign$3(__assign$3({}, base), { filterID: 1114403405 });
    case "box blur":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Box Blur",
        _classID: "boxblur",
        "Rds ": uvRadius(f2.filter)
      }, filterID: 697 });
    case "gaussian blur":
      return __assign$3(__assign$3({}, base), { Fltr: {
        // _name: '', // Testing
        _name: "Gaussian Blur",
        _classID: "GsnB",
        "Rds ": uvRadius(f2.filter)
      }, filterID: 1198747202 });
    case "motion blur":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Motion Blur",
        _classID: "MtnB",
        Angl: f2.filter.angle,
        Dstn: unitsValue(f2.filter.distance, "distance")
      }, filterID: 1299476034 });
    case "radial blur":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Radial Blur",
        _classID: "RdlB",
        Amnt: f2.filter.amount,
        BlrM: BlrM.encode(f2.filter.method),
        BlrQ: BlrQ.encode(f2.filter.quality)
      }, filterID: 1382313026 });
    case "shape blur":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Shape Blur",
        _classID: "shapeBlur",
        "Rds ": uvRadius(f2.filter),
        customShape: {
          _name: "",
          _classID: "customShape",
          "Nm  ": f2.filter.customShape.name,
          Idnt: f2.filter.customShape.id
        }
      }, filterID: 702 });
    case "smart blur":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Smart Blur",
        _classID: "SmrB",
        "Rds ": f2.filter.radius,
        Thsh: f2.filter.threshold,
        SmBQ: SmBQ.encode(f2.filter.quality),
        SmBM: SmBM.encode(f2.filter.mode)
      }, filterID: 1399681602 });
    case "surface blur":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Surface Blur",
        _classID: "surfaceBlur",
        "Rds ": uvRadius(f2.filter),
        Thsh: f2.filter.threshold
      }, filterID: 701 });
    case "displace":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Displace",
        _classID: "Dspl",
        HrzS: f2.filter.horizontalScale,
        VrtS: f2.filter.verticalScale,
        DspM: DspM.encode(f2.filter.displacementMap),
        UndA: UndA.encode(f2.filter.undefinedAreas),
        DspF: {
          sig: f2.filter.displacementFile.signature,
          path: f2.filter.displacementFile.path
        }
      }, filterID: 1148416108 });
    case "pinch":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Pinch",
        _classID: "Pnch",
        Amnt: f2.filter.amount
      }, filterID: 1349411688 });
    case "polar coordinates":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Polar Coordinates",
        _classID: "Plr ",
        Cnvr: Cnvr.encode(f2.filter.conversion)
      }, filterID: 1349284384 });
    case "ripple":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Ripple",
        _classID: "Rple",
        Amnt: f2.filter.amount,
        RplS: RplS.encode(f2.filter.size)
      }, filterID: 1383099493 });
    case "shear":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Shear",
        _classID: "Shr ",
        ShrP: f2.filter.shearPoints.map(function(p2) {
          return { _name: "", _classID: "Pnt ", Hrzn: p2.x, Vrtc: p2.y };
        }),
        UndA: UndA.encode(f2.filter.undefinedAreas),
        ShrS: f2.filter.shearStart,
        ShrE: f2.filter.shearEnd
      }, filterID: 1399353888 });
    case "spherize":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Spherize",
        _classID: "Sphr",
        Amnt: f2.filter.amount,
        SphM: SphM.encode(f2.filter.mode)
      }, filterID: 1399875698 });
    case "twirl":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Twirl",
        _classID: "Twrl",
        Angl: f2.filter.angle
      }, filterID: 1417114220 });
    case "wave":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Wave",
        _classID: "Wave",
        Wvtp: Wvtp.encode(f2.filter.type),
        NmbG: f2.filter.numberOfGenerators,
        WLMn: f2.filter.wavelength.min,
        WLMx: f2.filter.wavelength.max,
        AmMn: f2.filter.amplitude.min,
        AmMx: f2.filter.amplitude.max,
        SclH: f2.filter.scale.x,
        SclV: f2.filter.scale.y,
        UndA: UndA.encode(f2.filter.undefinedAreas),
        RndS: f2.filter.randomSeed
      }, filterID: 1466005093 });
    case "zigzag":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "ZigZag",
        _classID: "ZgZg",
        Amnt: f2.filter.amount,
        NmbR: f2.filter.ridges,
        ZZTy: ZZTy.encode(f2.filter.style)
      }, filterID: 1516722791 });
    case "add noise":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Add Noise",
        _classID: "AdNs",
        Dstr: Dstr.encode(f2.filter.distribution),
        Nose: unitsPercentF(f2.filter.amount),
        Mnch: f2.filter.monochromatic,
        FlRs: f2.filter.randomSeed
      }, filterID: 1097092723 });
    case "despeckle":
      return __assign$3(__assign$3({}, base), { filterID: 1148416099 });
    case "dust and scratches":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Dust & Scratches",
        _classID: "DstS",
        "Rds ": f2.filter.radius,
        Thsh: f2.filter.threshold
      }, filterID: 1148417107 });
    case "median":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Median",
        _classID: "Mdn ",
        "Rds ": uvRadius(f2.filter)
      }, filterID: 1298427424 });
    case "reduce noise":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Reduce Noise",
        _classID: "denoise",
        ClNs: unitsPercentF(f2.filter.reduceColorNoise),
        Shrp: unitsPercentF(f2.filter.sharpenDetails),
        removeJPEGArtifact: f2.filter.removeJpegArtifact,
        channelDenoise: f2.filter.channelDenoise.map(function(c2) {
          return __assign$3({ _name: "", _classID: "channelDenoiseParams", Chnl: c2.channels.map(function(i3) {
            return Chnl.encode(i3);
          }), Amnt: c2.amount }, c2.preserveDetails ? { EdgF: c2.preserveDetails } : {});
        }),
        preset: f2.filter.preset
      }, filterID: 633 });
    case "color halftone":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Color Halftone",
        _classID: "ClrH",
        "Rds ": f2.filter.radius,
        Ang1: f2.filter.angle1,
        Ang2: f2.filter.angle2,
        Ang3: f2.filter.angle3,
        Ang4: f2.filter.angle4
      }, filterID: 1131180616 });
    case "crystallize":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Crystallize",
        _classID: "Crst",
        ClSz: f2.filter.cellSize,
        FlRs: f2.filter.randomSeed
      }, filterID: 1131574132 });
    case "facet":
      return __assign$3(__assign$3({}, base), { filterID: 1180922912 });
    case "fragment":
      return __assign$3(__assign$3({}, base), { filterID: 1181902701 });
    case "mezzotint":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Mezzotint",
        _classID: "Mztn",
        MztT: MztT.encode(f2.filter.type),
        FlRs: f2.filter.randomSeed
      }, filterID: 1299870830 });
    case "mosaic":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Mosaic",
        _classID: "Msc ",
        ClSz: unitsValue(f2.filter.cellSize, "cellSize")
      }, filterID: 1299407648 });
    case "pointillize":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Pointillize",
        _classID: "Pntl",
        ClSz: f2.filter.cellSize,
        FlRs: f2.filter.randomSeed
      }, filterID: 1349416044 });
    case "clouds":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Clouds",
        _classID: "Clds",
        FlRs: f2.filter.randomSeed
      }, filterID: 1131177075 });
    case "difference clouds":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Difference Clouds",
        _classID: "DfrC",
        FlRs: f2.filter.randomSeed
      }, filterID: 1147564611 });
    case "fibers":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Fibers",
        _classID: "Fbrs",
        Vrnc: f2.filter.variance,
        Strg: f2.filter.strength,
        RndS: f2.filter.randomSeed
      }, filterID: 1180856947 });
    case "lens flare":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Lens Flare",
        _classID: "LnsF",
        Brgh: f2.filter.brightness,
        FlrC: {
          _name: "",
          _classID: "Pnt ",
          Hrzn: f2.filter.position.x,
          Vrtc: f2.filter.position.y
        },
        "Lns ": Lns.encode(f2.filter.lensType)
      }, filterID: 1282306886 });
    case "sharpen":
      return __assign$3(__assign$3({}, base), { filterID: 1399353968 });
    case "sharpen edges":
      return __assign$3(__assign$3({}, base), { filterID: 1399353925 });
    case "sharpen more":
      return __assign$3(__assign$3({}, base), { filterID: 1399353933 });
    case "smart sharpen":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Smart Sharpen",
        _classID: "smartSharpen",
        Amnt: unitsPercentF(f2.filter.amount),
        "Rds ": uvRadius(f2.filter),
        Thsh: f2.filter.threshold,
        Angl: f2.filter.angle,
        moreAccurate: f2.filter.moreAccurate,
        blur: blurType.encode(f2.filter.blur),
        preset: f2.filter.preset,
        sdwM: {
          _name: "Parameters",
          _classID: "adaptCorrectTones",
          Amnt: unitsPercentF(f2.filter.shadow.fadeAmount),
          Wdth: unitsPercentF(f2.filter.shadow.tonalWidth),
          "Rds ": f2.filter.shadow.radius
        },
        hglM: {
          _name: "Parameters",
          _classID: "adaptCorrectTones",
          Amnt: unitsPercentF(f2.filter.highlight.fadeAmount),
          Wdth: unitsPercentF(f2.filter.highlight.tonalWidth),
          "Rds ": f2.filter.highlight.radius
        }
      }, filterID: 698 });
    case "unsharp mask":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Unsharp Mask",
        _classID: "UnsM",
        Amnt: unitsPercentF(f2.filter.amount),
        "Rds ": uvRadius(f2.filter),
        Thsh: f2.filter.threshold
      }, filterID: 1433301837 });
    case "diffuse":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Diffuse",
        _classID: "Dfs ",
        "Md  ": DfsM.encode(f2.filter.mode),
        FlRs: f2.filter.randomSeed
      }, filterID: 1147564832 });
    case "emboss":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Emboss",
        _classID: "Embs",
        Angl: f2.filter.angle,
        Hght: f2.filter.height,
        Amnt: f2.filter.amount
      }, filterID: 1164796531 });
    case "extrude":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Extrude",
        _classID: "Extr",
        ExtS: f2.filter.size,
        ExtD: f2.filter.depth,
        ExtF: f2.filter.solidFrontFaces,
        ExtM: f2.filter.maskIncompleteBlocks,
        ExtT: ExtT.encode(f2.filter.type),
        ExtR: ExtR.encode(f2.filter.depthMode),
        FlRs: f2.filter.randomSeed
      }, filterID: 1165522034 });
    case "find edges":
      return __assign$3(__assign$3({}, base), { filterID: 1181639749 });
    case "solarize":
      return __assign$3(__assign$3({}, base), { filterID: 1399616122 });
    case "tiles":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Tiles",
        _classID: "Tls ",
        TlNm: f2.filter.numberOfTiles,
        TlOf: f2.filter.maximumOffset,
        FlCl: FlCl.encode(f2.filter.fillEmptyAreaWith),
        FlRs: f2.filter.randomSeed
      }, filterID: 1416393504 });
    case "trace contour":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Trace Contour",
        _classID: "TrcC",
        "Lvl ": f2.filter.level,
        "Edg ": CntE.encode(f2.filter.edge)
      }, filterID: 1416782659 });
    case "wind":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Wind",
        _classID: "Wnd ",
        WndM: WndM.encode(f2.filter.method),
        Drct: Drct.encode(f2.filter.direction)
      }, filterID: 1466852384 });
    case "de-interlace":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "De-Interlace",
        _classID: "Dntr",
        IntE: IntE.encode(f2.filter.eliminate),
        IntC: IntC.encode(f2.filter.newFieldsBy)
      }, filterID: 1148089458 });
    case "ntsc colors":
      return __assign$3(__assign$3({}, base), { filterID: 1314149187 });
    case "invert":
      return __assign$3(__assign$3({}, base), { filterID: 1231976050 });
    case "custom":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Custom",
        _classID: "Cstm",
        "Scl ": f2.filter.scale,
        Ofst: f2.filter.offset,
        Mtrx: f2.filter.matrix
      }, filterID: 1131639917 });
    case "high pass":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "High Pass",
        _classID: "HghP",
        "Rds ": uvRadius(f2.filter)
      }, filterID: 1214736464 });
    case "maximum":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Maximum",
        _classID: "Mxm ",
        "Rds ": uvRadius(f2.filter)
      }, filterID: 1299737888 });
    case "minimum":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Minimum",
        _classID: "Mnm ",
        "Rds ": uvRadius(f2.filter)
      }, filterID: 1299082528 });
    case "offset":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Offset",
        _classID: "Ofst",
        Hrzn: f2.filter.horizontal,
        Vrtc: f2.filter.vertical,
        "Fl  ": FlMd.encode(f2.filter.undefinedAreas)
      }, filterID: 1332114292 });
    case "puppet":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Rigid Transform",
        _classID: "rigidTransform",
        "null": ["Ordn.Trgt"],
        rigidType: f2.filter.rigidType,
        puppetShapeList: f2.filter.puppetShapeList.map(function(p2) {
          return {
            _name: "",
            _classID: "puppetShape",
            rigidType: p2.rigidType,
            VrsM: 1,
            VrsN: 0,
            originalVertexArray: toUint8(new Float32Array(pointsToArray(p2.originalVertexArray))),
            deformedVertexArray: toUint8(new Float32Array(pointsToArray(p2.deformedVertexArray))),
            indexArray: toUint8(new Uint32Array(p2.indexArray)),
            pinOffsets: pointsToArray(p2.pinOffsets),
            posFinalPins: pointsToArray(p2.posFinalPins),
            pinVertexIndices: p2.pinVertexIndices,
            PinP: pointsToArray(p2.pinPosition),
            PnRt: p2.pinRotation,
            PnOv: p2.pinOverlay,
            PnDp: p2.pinDepth,
            meshQuality: p2.meshQuality,
            meshExpansion: p2.meshExpansion,
            meshRigidity: p2.meshRigidity,
            imageResolution: p2.imageResolution,
            meshBoundaryPath: {
              _name: "",
              _classID: "pathClass",
              pathComponents: p2.meshBoundaryPath.pathComponents.map(function(c2) {
                return {
                  _name: "",
                  _classID: "PaCm",
                  shapeOperation: "shapeOperation.".concat(c2.shapeOperation),
                  SbpL: c2.paths.map(function(path) {
                    return {
                      _name: "",
                      _classID: "Sbpl",
                      Clsp: path.closed,
                      "Pts ": path.points.map(function(pt) {
                        return {
                          _name: "",
                          _classID: "Pthp",
                          Anch: pointToHrznVrtc(pt.anchor),
                          "Fwd ": pointToHrznVrtc(pt.forward),
                          "Bwd ": pointToHrznVrtc(pt.backward),
                          Smoo: pt.smooth
                        };
                      })
                    };
                  })
                };
              })
            },
            selectedPin: p2.selectedPin
          };
        }),
        PuX0: f2.filter.bounds[0].x,
        PuX1: f2.filter.bounds[1].x,
        PuX2: f2.filter.bounds[2].x,
        PuX3: f2.filter.bounds[3].x,
        PuY0: f2.filter.bounds[0].y,
        PuY1: f2.filter.bounds[1].y,
        PuY2: f2.filter.bounds[2].y,
        PuY3: f2.filter.bounds[3].y
      }, filterID: 991 });
    case "oil paint plugin": {
      var params = {};
      for (var i2 = 0; i2 < f2.filter.parameters.length; i2++) {
        var _a = f2.filter.parameters[i2], name_1 = _a.name, value = _a.value;
        var suffix = "".concat(fromAtoZ[Math.floor(i2 / fromAtoZ.length)]).concat(fromAtoZ[i2 % fromAtoZ.length]);
        params["PN".concat(suffix)] = name_1;
        params["PT".concat(suffix)] = 0;
        params["PF".concat(suffix)] = value;
      }
      return __assign$3(__assign$3({}, base), { Fltr: __assign$3({ _name: "Oil Paint Plugin", _classID: "PbPl", KnNm: f2.filter.name, GpuY: f2.filter.gpu, LIWy: f2.filter.lighting, FPth: "1" }, params), filterID: 1348620396 });
    }
    case "oil paint":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Oil Paint",
        _classID: "oilPaint",
        lightingOn: f2.filter.lightingOn,
        stylization: f2.filter.stylization,
        cleanliness: f2.filter.cleanliness,
        brushScale: f2.filter.brushScale,
        microBrush: f2.filter.microBrush,
        LghD: f2.filter.lightDirection,
        specularity: f2.filter.specularity
      }, filterID: 1122 });
    case "liquify":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Liquify",
        _classID: "LqFy",
        LqMe: f2.filter.liquifyMesh
      }, filterID: 1282492025 });
    case "perspective warp":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Perspective Warp",
        _classID: "perspectiveWarpTransform",
        vertices: f2.filter.vertices.map(pointToHrznVrtc),
        warpedVertices: f2.filter.warpedVertices.map(pointToHrznVrtc),
        quads: f2.filter.quads.map(function(indices) {
          return { indices };
        })
      }, filterID: 442 });
    case "curves":
      return __assign$3(__assign$3({}, base), { Fltr: __assign$3({ _name: "Curves", _classID: "Crvs", presetKind: presetKindType.encode(f2.filter.presetKind) }, f2.filter.adjustments ? {
        Adjs: f2.filter.adjustments.map(function(a2) {
          return "curve" in a2 ? {
            _name: "",
            _classID: "CrvA",
            Chnl: a2.channels.map(Chnl.encode),
            "Crv ": a2.curve.map(function(c2) {
              return __assign$3({ _name: "", _classID: "Pnt ", Hrzn: c2.x, Vrtc: c2.y }, c2.curved ? { Cnty: true } : {});
            })
          } : {
            _name: "",
            _classID: "CrvA",
            Chnl: a2.channels.map(Chnl.encode),
            Mpng: a2.values
          };
        })
      } : {}), filterID: 1131574899 });
    case "brightness/contrast":
      return __assign$3(__assign$3({}, base), { Fltr: {
        _name: "Brightness/Contrast",
        _classID: "BrgC",
        Brgh: f2.filter.brightness,
        Cntr: f2.filter.contrast,
        useLegacy: !!f2.filter.useLegacy
      }, filterID: 1114793795 });
    // case 'hsb/hsl': return {
    // TODO: ...
    // };
    default:
      throw new Error("Unknow filter type: ".concat(f2.type));
  }
}
function getWarpFromPlacedLayer(placed) {
  if (placed.warp)
    return placed.warp;
  if (!placed.width || !placed.height)
    throw new Error("You must provide width and height of the linked image in placedLayer");
  var w2 = placed.width;
  var h2 = placed.height;
  var x0 = 0, x1 = w2 / 3, x2 = w2 * 2 / 3, x3 = w2;
  var y0 = 0, y1 = h2 / 3, y2 = h2 * 2 / 3, y3 = h2;
  return {
    style: "custom",
    value: 0,
    perspective: 0,
    perspectiveOther: 0,
    rotate: "horizontal",
    bounds: {
      top: { value: 0, units: "Pixels" },
      left: { value: 0, units: "Pixels" },
      bottom: { value: h2, units: "Pixels" },
      right: { value: w2, units: "Pixels" }
    },
    uOrder: 4,
    vOrder: 4,
    customEnvelopeWarp: {
      meshPoints: [
        { x: x0, y: y0 },
        { x: x1, y: y0 },
        { x: x2, y: y0 },
        { x: x3, y: y0 },
        { x: x0, y: y1 },
        { x: x1, y: y1 },
        { x: x2, y: y1 },
        { x: x3, y: y1 },
        { x: x0, y: y2 },
        { x: x1, y: y2 },
        { x: x2, y: y2 },
        { x: x3, y: y2 },
        { x: x0, y: y3 },
        { x: x1, y: y3 },
        { x: x2, y: y3 },
        { x: x3, y: y3 }
      ]
    }
  };
}
addHandler("SoLd", hasKey("placedLayer"), function(reader, target, left) {
  if (readSignature(reader) !== "soLD")
    throw new Error("Invalid SoLd type");
  var version2 = readInt32(reader);
  if (version2 !== 4 && version2 !== 5)
    throw new Error("Invalid SoLd version");
  var desc = readVersionAndDescriptor(reader, true);
  target.placedLayer = {
    id: desc.Idnt,
    placed: desc.placed,
    type: placedLayerTypes[desc.Type],
    pageNumber: desc.PgNm,
    totalPages: desc.totalPages,
    frameStep: frac(desc.frameStep),
    duration: frac(desc.duration),
    frameCount: desc.frameCount,
    transform: desc.Trnf,
    width: desc["Sz  "].Wdth,
    height: desc["Sz  "].Hght,
    resolution: parseUnits(desc.Rslt),
    warp: parseWarp(desc.quiltWarp || desc.warp)
  };
  if (desc.nonAffineTransform && desc.nonAffineTransform.some(function(x2, i2) {
    return x2 !== desc.Trnf[i2];
  })) {
    target.placedLayer.nonAffineTransform = desc.nonAffineTransform;
  }
  if (desc.Crop)
    target.placedLayer.crop = desc.Crop;
  if (desc.comp)
    target.placedLayer.comp = desc.comp;
  if (desc.compInfo) {
    target.placedLayer.compInfo = {
      compID: desc.compInfo.compID,
      originalCompID: desc.compInfo.originalCompID
    };
  }
  if (desc.filterFX)
    target.placedLayer.filter = parseFilterFX(desc.filterFX, reader);
  skipBytes(reader, left());
}, function(writer, target) {
  var _a, _b;
  writeSignature(writer, "soLD");
  writeInt32(writer, 4);
  var placed = target.placedLayer;
  if (!placed.id || typeof placed.id !== "string" || !/^[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/.test(placed.id)) {
    throw new Error("Placed layer ID must be in a GUID format (example: 20953ddb-9391-11ec-b4f1-c15674f50bc4)");
  }
  var desc = __assign$3(__assign$3({ Idnt: placed.id, placed: (_a = placed.placed) !== null && _a !== void 0 ? _a : placed.id, PgNm: placed.pageNumber || 1, totalPages: placed.totalPages || 1 }, placed.crop ? { Crop: placed.crop } : {}), {
    frameStep: placed.frameStep || { numerator: 0, denominator: 600 },
    duration: placed.duration || { numerator: 0, denominator: 600 },
    frameCount: placed.frameCount || 0,
    Annt: 16,
    Type: placedLayerTypes.indexOf(placed.type),
    Trnf: placed.transform,
    nonAffineTransform: (_b = placed.nonAffineTransform) !== null && _b !== void 0 ? _b : placed.transform,
    // quiltWarp: {} as any,
    warp: encodeWarp(getWarpFromPlacedLayer(placed)),
    "Sz  ": {
      _name: "",
      _classID: "Pnt ",
      Wdth: placed.width || 0,
      Hght: placed.height || 0
      // TODO: find size ?
    },
    Rslt: placed.resolution ? unitsValue(placed.resolution, "resolution") : { units: "Density", value: 72 }
  });
  if (placed.filter) {
    desc.filterFX = {
      _name: "",
      _classID: "filterFXStyle",
      enab: placed.filter.enabled,
      validAtPosition: placed.filter.validAtPosition,
      filterMaskEnable: placed.filter.maskEnabled,
      filterMaskLinked: placed.filter.maskLinked,
      filterMaskExtendWithWhite: placed.filter.maskExtendWithWhite,
      filterFXList: placed.filter.list.map(function(f2) {
        return serializeFilterFXItem(f2);
      })
    };
  }
  if (placed.warp && isQuiltWarp(placed.warp)) {
    var quiltWarp = encodeWarp(placed.warp);
    desc.quiltWarp = quiltWarp;
    desc.warp = {
      warpStyle: "warpStyle.warpNone",
      warpValue: quiltWarp.warpValue,
      warpPerspective: quiltWarp.warpPerspective,
      warpPerspectiveOther: quiltWarp.warpPerspectiveOther,
      warpRotate: quiltWarp.warpRotate,
      bounds: quiltWarp.bounds,
      uOrder: quiltWarp.uOrder,
      vOrder: quiltWarp.vOrder
    };
  } else {
    delete desc.quiltWarp;
  }
  if (placed.comp)
    desc.comp = placed.comp;
  if (placed.compInfo)
    desc.compInfo = placed.compInfo;
  writeVersionAndDescriptor(writer, "", "null", desc, desc.quiltWarp ? "quiltWarp" : "warp");
});
addHandlerAlias("SoLE", "SoLd");
addHandler("fxrp", hasKey("referencePoint"), function(reader, target) {
  target.referencePoint = {
    x: readFloat64(reader),
    y: readFloat64(reader)
  };
}, function(writer, target) {
  writeFloat64(writer, target.referencePoint.x);
  writeFloat64(writer, target.referencePoint.y);
});
addHandler("Lr16", function() {
  return false;
}, function(reader, _target, _left, psd, imageResources) {
  readLayerInfo(reader, psd, imageResources);
}, function(_writer, _target) {
});
addHandler("Lr32", function() {
  return false;
}, function(reader, _target, _left, psd, imageResources) {
  readLayerInfo(reader, psd, imageResources);
}, function(_writer, _target) {
});
addHandler("LMsk", hasKey("userMask"), function(reader, target) {
  target.userMask = {
    colorSpace: readColor(reader),
    opacity: readUint16(reader) / 255
  };
  var flag = readUint8(reader);
  if (flag !== 128)
    throw new Error("Invalid flag value");
  skipBytes(reader, 1);
}, function(writer, target) {
  var userMask = target.userMask;
  writeColor(writer, userMask.colorSpace);
  writeUint16(writer, clamp(userMask.opacity, 0, 1) * 255);
  writeUint8(writer, 128);
  writeZeros(writer, 1);
});
{
  addHandler(
    "Patt",
    // TODO: handle also Pat2 & Pat3
    function(target) {
      return !target;
    },
    function(reader, target, left) {
      if (!left())
        return;
      skipBytes(reader, left());
      return;
    },
    function(_writer, _target) {
    }
  );
}
function readRect(reader) {
  var top = readInt32(reader);
  var left = readInt32(reader);
  var bottom = readInt32(reader);
  var right = readInt32(reader);
  return { top, left, bottom, right };
}
function writeRect(writer, rect) {
  writeInt32(writer, rect.top);
  writeInt32(writer, rect.left);
  writeInt32(writer, rect.bottom);
  writeInt32(writer, rect.right);
}
addHandler("Anno", function(target) {
  return target.annotations !== void 0;
}, function(reader, target, left) {
  var major = readUint16(reader);
  var minor = readUint16(reader);
  if (major !== 2 || minor !== 1)
    throw new Error("Invalid Anno version");
  var count = readUint32(reader);
  var annotations = [];
  for (var i2 = 0; i2 < count; i2++) {
    readUint32(reader);
    var type = readSignature(reader);
    var open_1 = !!readUint8(reader);
    readUint8(reader);
    readUint16(reader);
    var iconLocation = readRect(reader);
    var popupLocation = readRect(reader);
    var color = readColor(reader);
    var author = readPascalString(reader, 2);
    var name_2 = readPascalString(reader, 2);
    var date = readPascalString(reader, 2);
    readUint32(reader);
    readSignature(reader);
    var dataLength = readUint32(reader);
    var data3 = void 0;
    if (type === "txtA") {
      if (dataLength >= 2 && readUint16(reader) === 65279) {
        data3 = readUnicodeStringWithLength(reader, (dataLength - 2) / 2);
      } else {
        reader.offset -= 2;
        data3 = readAsciiString(reader, dataLength);
      }
      data3 = data3.replace(/\r/g, "\n");
    } else if (type === "sndA") {
      data3 = readBytes(reader, dataLength);
    } else {
      throw new Error("Unknown annotation type");
    }
    annotations.push({
      type: type === "txtA" ? "text" : "sound",
      open: open_1,
      iconLocation,
      popupLocation,
      color,
      author,
      name: name_2,
      date,
      data: data3
    });
  }
  target.annotations = annotations;
  skipBytes(reader, left());
}, function(writer, target) {
  var annotations = target.annotations;
  writeUint16(writer, 2);
  writeUint16(writer, 1);
  writeUint32(writer, annotations.length);
  for (var _i = 0, annotations_1 = annotations; _i < annotations_1.length; _i++) {
    var annotation = annotations_1[_i];
    var sound = annotation.type === "sound";
    if (sound && !(annotation.data instanceof Uint8Array))
      throw new Error("Sound annotation data should be Uint8Array");
    if (!sound && typeof annotation.data !== "string")
      throw new Error("Text annotation data should be string");
    var lengthOffset = writer.offset;
    writeUint32(writer, 0);
    writeSignature(writer, sound ? "sndA" : "txtA");
    writeUint8(writer, annotation.open ? 1 : 0);
    writeUint8(writer, 28);
    writeUint16(writer, 1);
    writeRect(writer, annotation.iconLocation);
    writeRect(writer, annotation.popupLocation);
    writeColor(writer, annotation.color);
    writePascalString(writer, annotation.author || "", 2);
    writePascalString(writer, annotation.name || "", 2);
    writePascalString(writer, annotation.date || "", 2);
    var contentOffset = writer.offset;
    writeUint32(writer, 0);
    writeSignature(writer, sound ? "sndM" : "txtC");
    writeUint32(writer, 0);
    var dataOffset = writer.offset;
    if (sound) {
      writeBytes(writer, annotation.data);
    } else {
      writeUint16(writer, 65279);
      var text = annotation.data.replace(/\n/g, "\r");
      for (var i2 = 0; i2 < text.length; i2++)
        writeUint16(writer, text.charCodeAt(i2));
    }
    writer.view.setUint32(lengthOffset, writer.offset - lengthOffset, false);
    writer.view.setUint32(contentOffset, writer.offset - contentOffset, false);
    writer.view.setUint32(dataOffset - 4, writer.offset - dataOffset, false);
  }
});
function createLnkHandler(tag) {
  addHandler(tag, function(target) {
    var psd = target;
    if (!psd.linkedFiles || !psd.linkedFiles.length)
      return false;
    if (tag === "lnkE" && !psd.linkedFiles.some(function(f2) {
      return f2.linkedFile;
    }))
      return false;
    return true;
  }, function(reader, target, left, _psd) {
    var psd = target;
    psd.linkedFiles = psd.linkedFiles || [];
    while (left() > 8) {
      var size = readLength64(reader);
      var startOffset = reader.offset;
      var type = readSignature(reader);
      var version2 = readInt32(reader);
      var id = readPascalString(reader, 1);
      var name_3 = readUnicodeString(reader);
      var fileType = readSignature(reader).trim();
      var fileCreator = readSignature(reader).trim();
      var dataSize = readLength64(reader);
      var hasFileOpenDescriptor = readUint8(reader);
      var fileOpenDescriptor = hasFileOpenDescriptor ? readVersionAndDescriptor(reader) : void 0;
      var linkedFileDescriptor = type === "liFE" ? readVersionAndDescriptor(reader) : void 0;
      var file = { id, name: name_3 };
      if (fileType)
        file.type = fileType;
      if (fileCreator)
        file.creator = fileCreator;
      if (fileOpenDescriptor) {
        file.descriptor = {
          compInfo: {
            compID: fileOpenDescriptor.compInfo.compID,
            originalCompID: fileOpenDescriptor.compInfo.originalCompID
          }
        };
      }
      if (type === "liFE" && version2 > 3) {
        var year = readInt32(reader);
        var month = readUint8(reader);
        var day = readUint8(reader);
        var hour = readUint8(reader);
        var minute = readUint8(reader);
        var seconds = readFloat64(reader);
        var wholeSeconds = Math.floor(seconds);
        var ms = (seconds - wholeSeconds) * 1e3;
        file.time = new Date(Date.UTC(year, month, day, hour, minute, wholeSeconds, ms)).toISOString();
      }
      var fileSize = type === "liFE" ? readLength64(reader) : 0;
      if (type === "liFA")
        skipBytes(reader, 8);
      if (type === "liFD")
        file.data = readBytes(reader, dataSize);
      if (version2 >= 5)
        file.childDocumentID = readUnicodeString(reader);
      if (version2 >= 6)
        file.assetModTime = readFloat64(reader);
      if (version2 >= 7)
        file.assetLockedState = readUint8(reader);
      if (type === "liFE" && version2 === 2)
        file.data = readBytes(reader, fileSize);
      if (reader.skipLinkedFilesData)
        file.data = void 0;
      if (tag === "lnkE") {
        file.linkedFile = {
          fileSize,
          name: (linkedFileDescriptor === null || linkedFileDescriptor === void 0 ? void 0 : linkedFileDescriptor["Nm  "]) || "",
          fullPath: (linkedFileDescriptor === null || linkedFileDescriptor === void 0 ? void 0 : linkedFileDescriptor.fullPath) || "",
          originalPath: (linkedFileDescriptor === null || linkedFileDescriptor === void 0 ? void 0 : linkedFileDescriptor.originalPath) || "",
          relativePath: (linkedFileDescriptor === null || linkedFileDescriptor === void 0 ? void 0 : linkedFileDescriptor.relPath) || ""
        };
      }
      psd.linkedFiles.push(file);
      while (size % 4)
        size++;
      reader.offset = startOffset + size;
    }
    skipBytes(reader, left());
  }, function(writer, target) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var psd = target;
    for (var _i = 0, _k = psd.linkedFiles; _i < _k.length; _i++) {
      var file = _k[_i];
      if (tag === "lnkE" !== !!file.linkedFile)
        continue;
      var version2 = 2;
      if (file.assetLockedState != null)
        version2 = 7;
      else if (file.assetModTime != null)
        version2 = 6;
      else if (file.childDocumentID != null)
        version2 = 5;
      else if (tag == "lnkE")
        version2 = 3;
      writeLength64(writer, 0);
      var sizeOffset = writer.offset;
      writeSignature(writer, tag === "lnkE" ? "liFE" : file.data ? "liFD" : "liFA");
      writeInt32(writer, version2);
      if (!file.id || typeof file.id !== "string" || !/^[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/.test(file.id)) {
        throw new Error("Linked file ID must be in a GUID format (example: 20953ddb-9391-11ec-b4f1-c15674f50bc4)");
      }
      writePascalString(writer, file.id, 1);
      writeUnicodeStringWithPadding(writer, file.name || "");
      writeSignature(writer, file.type ? "".concat(file.type, "    ").substring(0, 4) : "    ");
      writeSignature(writer, file.creator ? "".concat(file.creator, "    ").substring(0, 4) : "\0\0\0\0");
      writeLength64(writer, file.data ? file.data.byteLength : 0);
      if (file.descriptor && file.descriptor.compInfo) {
        var desc = {
          compInfo: {
            compID: file.descriptor.compInfo.compID,
            originalCompID: file.descriptor.compInfo.originalCompID
          }
        };
        writeUint8(writer, 1);
        writeVersionAndDescriptor(writer, "", "null", desc);
      } else {
        writeUint8(writer, 0);
      }
      if (tag === "lnkE") {
        var desc = {
          descVersion: 2,
          "Nm  ": (_b = (_a = file.linkedFile) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "",
          fullPath: (_d = (_c = file.linkedFile) === null || _c === void 0 ? void 0 : _c.fullPath) !== null && _d !== void 0 ? _d : "",
          originalPath: (_f = (_e = file.linkedFile) === null || _e === void 0 ? void 0 : _e.originalPath) !== null && _f !== void 0 ? _f : "",
          relPath: (_h = (_g = file.linkedFile) === null || _g === void 0 ? void 0 : _g.relativePath) !== null && _h !== void 0 ? _h : ""
        };
        writeVersionAndDescriptor(writer, "", "ExternalFileLink", desc);
        var time = file.time ? new Date(file.time) : /* @__PURE__ */ new Date();
        writeInt32(writer, time.getUTCFullYear());
        writeUint8(writer, time.getUTCMonth());
        writeUint8(writer, time.getUTCDate());
        writeUint8(writer, time.getUTCHours());
        writeUint8(writer, time.getUTCMinutes());
        writeFloat64(writer, time.getUTCSeconds() + time.getUTCMilliseconds() / 1e3);
      }
      if (file.data) {
        writeBytes(writer, file.data);
      } else {
        writeLength64(writer, ((_j = file.linkedFile) === null || _j === void 0 ? void 0 : _j.fileSize) || 0);
      }
      if (version2 >= 5)
        writeUnicodeStringWithPadding(writer, file.childDocumentID || "");
      if (version2 >= 6)
        writeFloat64(writer, file.assetModTime || 0);
      if (version2 >= 7)
        writeUint8(writer, file.assetLockedState || 0);
      var size = writer.offset - sizeOffset;
      writer.view.setUint32(sizeOffset - 4, size, false);
      while (size % 4) {
        size++;
        writeUint8(writer, 0);
      }
    }
  });
}
createLnkHandler("lnk2");
createLnkHandler("lnkE");
addHandlerAlias("lnkD", "lnk2");
addHandlerAlias("lnk3", "lnk2");
addHandler("pths", hasKey("pathList"), function(reader, target) {
  readVersionAndDescriptor(reader, true);
  target.pathList = [];
}, function(writer, _target) {
  var desc = {
    pathList: []
    // TODO: write paths
  };
  writeVersionAndDescriptor(writer, "", "pathsDataClass", desc);
});
addHandler("lyvr", hasKey("version"), function(reader, target) {
  return target.version = readUint32(reader);
}, function(writer, target) {
  return writeUint32(writer, target.version);
});
addHandler(
  "lfxs",
  function() {
    return false;
  },
  // TODO: not sure when we actually need to write this section
  // NOTE: this might be insufficient
  // target => target.effects !== undefined && (
  // 	!!target.effects.dropShadow?.some(e => e.choke) ||
  // 	!!target.effects.innerShadow?.some(e => e.choke) ||
  // 	!!target.effects.outerGlow?.choke ||
  // 	!!target.effects.innerGlow?.choke
  // ),
  function(reader, target, left) {
    var version2 = readUint32(reader);
    if (version2 !== 0)
      throw new Error("Invalid lfxs version");
    var desc = readVersionAndDescriptor(reader);
    target.effects = parseEffects(desc, !!reader.logMissingFeatures);
    skipBytes(reader, left());
  },
  function(writer, target, _, options) {
    var desc = serializeEffects(target.effects, !!options.logMissingFeatures, true);
    writeUint32(writer, 0);
    writeVersionAndDescriptor(writer, "", "null", desc);
  }
);
function adjustmentType(type) {
  return function(target) {
    return !!target.adjustment && target.adjustment.type === type;
  };
}
addHandler("brit", adjustmentType("brightness/contrast"), function(reader, target, left) {
  if (!target.adjustment) {
    target.adjustment = {
      type: "brightness/contrast",
      brightness: readInt16(reader),
      contrast: readInt16(reader),
      meanValue: readInt16(reader),
      labColorOnly: !!readUint8(reader),
      useLegacy: true
    };
  }
  skipBytes(reader, left());
}, function(writer, target) {
  var _a;
  var info = target.adjustment;
  writeInt16(writer, info.brightness || 0);
  writeInt16(writer, info.contrast || 0);
  writeInt16(writer, (_a = info.meanValue) !== null && _a !== void 0 ? _a : 127);
  writeUint8(writer, info.labColorOnly ? 1 : 0);
  writeZeros(writer, 1);
});
function readLevelsChannel(reader) {
  var shadowInput = readInt16(reader);
  var highlightInput = readInt16(reader);
  var shadowOutput = readInt16(reader);
  var highlightOutput = readInt16(reader);
  var midtoneInput = readInt16(reader) / 100;
  return { shadowInput, highlightInput, shadowOutput, highlightOutput, midtoneInput };
}
function writeLevelsChannel(writer, channel) {
  writeInt16(writer, channel.shadowInput);
  writeInt16(writer, channel.highlightInput);
  writeInt16(writer, channel.shadowOutput);
  writeInt16(writer, channel.highlightOutput);
  writeInt16(writer, Math.round(channel.midtoneInput * 100));
}
addHandler("levl", adjustmentType("levels"), function(reader, target, left) {
  if (readUint16(reader) !== 2)
    throw new Error("Invalid levl version");
  target.adjustment = __assign$3(__assign$3({}, target.adjustment), { type: "levels", rgb: readLevelsChannel(reader), red: readLevelsChannel(reader), green: readLevelsChannel(reader), blue: readLevelsChannel(reader) });
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  var defaultChannel = {
    shadowInput: 0,
    highlightInput: 255,
    shadowOutput: 0,
    highlightOutput: 255,
    midtoneInput: 1
  };
  writeUint16(writer, 2);
  writeLevelsChannel(writer, info.rgb || defaultChannel);
  writeLevelsChannel(writer, info.red || defaultChannel);
  writeLevelsChannel(writer, info.blue || defaultChannel);
  writeLevelsChannel(writer, info.green || defaultChannel);
  for (var i2 = 0; i2 < 59; i2++)
    writeLevelsChannel(writer, defaultChannel);
});
function readCurveChannel(reader) {
  var nodes = readUint16(reader);
  var channel = [];
  for (var j = 0; j < nodes; j++) {
    var output = readInt16(reader);
    var input = readInt16(reader);
    channel.push({ input, output });
  }
  return channel;
}
function writeCurveChannel(writer, channel) {
  writeUint16(writer, channel.length);
  for (var _i = 0, channel_1 = channel; _i < channel_1.length; _i++) {
    var n = channel_1[_i];
    writeUint16(writer, n.output);
    writeUint16(writer, n.input);
  }
}
addHandler("curv", adjustmentType("curves"), function(reader, target, left) {
  readUint8(reader);
  if (readUint16(reader) !== 1)
    throw new Error("Invalid curv version");
  readUint16(reader);
  var channels2 = readUint16(reader);
  var info = { type: "curves" };
  if (channels2 & 1)
    info.rgb = readCurveChannel(reader);
  if (channels2 & 2)
    info.red = readCurveChannel(reader);
  if (channels2 & 4)
    info.green = readCurveChannel(reader);
  if (channels2 & 8)
    info.blue = readCurveChannel(reader);
  target.adjustment = __assign$3(__assign$3({}, target.adjustment), info);
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  var rgb = info.rgb, red = info.red, green = info.green, blue = info.blue;
  var channels2 = 0;
  var channelCount = 0;
  if (rgb && rgb.length) {
    channels2 |= 1;
    channelCount++;
  }
  if (red && red.length) {
    channels2 |= 2;
    channelCount++;
  }
  if (green && green.length) {
    channels2 |= 4;
    channelCount++;
  }
  if (blue && blue.length) {
    channels2 |= 8;
    channelCount++;
  }
  writeUint8(writer, 0);
  writeUint16(writer, 1);
  writeUint16(writer, 0);
  writeUint16(writer, channels2);
  if (rgb && rgb.length)
    writeCurveChannel(writer, rgb);
  if (red && red.length)
    writeCurveChannel(writer, red);
  if (green && green.length)
    writeCurveChannel(writer, green);
  if (blue && blue.length)
    writeCurveChannel(writer, blue);
  writeSignature(writer, "Crv ");
  writeUint16(writer, 4);
  writeUint16(writer, 0);
  writeUint16(writer, channelCount);
  if (rgb && rgb.length) {
    writeUint16(writer, 0);
    writeCurveChannel(writer, rgb);
  }
  if (red && red.length) {
    writeUint16(writer, 1);
    writeCurveChannel(writer, red);
  }
  if (green && green.length) {
    writeUint16(writer, 2);
    writeCurveChannel(writer, green);
  }
  if (blue && blue.length) {
    writeUint16(writer, 3);
    writeCurveChannel(writer, blue);
  }
});
addHandler("expA", adjustmentType("exposure"), function(reader, target, left) {
  if (readUint16(reader) !== 1)
    throw new Error("Invalid expA version");
  target.adjustment = __assign$3(__assign$3({}, target.adjustment), { type: "exposure", exposure: readFloat32(reader), offset: readFloat32(reader), gamma: readFloat32(reader) });
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  writeUint16(writer, 1);
  writeFloat32(writer, info.exposure);
  writeFloat32(writer, info.offset);
  writeFloat32(writer, info.gamma);
  writeZeros(writer, 2);
});
addHandler("vibA", adjustmentType("vibrance"), function(reader, target, left) {
  var desc = readVersionAndDescriptor(reader);
  target.adjustment = { type: "vibrance" };
  if (desc.vibrance !== void 0)
    target.adjustment.vibrance = desc.vibrance;
  if (desc.Strt !== void 0)
    target.adjustment.saturation = desc.Strt;
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  var desc = {};
  if (info.vibrance !== void 0)
    desc.vibrance = info.vibrance;
  if (info.saturation !== void 0)
    desc.Strt = info.saturation;
  writeVersionAndDescriptor(writer, "", "null", desc);
});
function readHueChannel(reader) {
  return {
    a: readInt16(reader),
    b: readInt16(reader),
    c: readInt16(reader),
    d: readInt16(reader),
    hue: readInt16(reader),
    saturation: readInt16(reader),
    lightness: readInt16(reader)
  };
}
function writeHueChannel(writer, channel) {
  var c2 = channel || {};
  writeInt16(writer, c2.a || 0);
  writeInt16(writer, c2.b || 0);
  writeInt16(writer, c2.c || 0);
  writeInt16(writer, c2.d || 0);
  writeInt16(writer, c2.hue || 0);
  writeInt16(writer, c2.saturation || 0);
  writeInt16(writer, c2.lightness || 0);
}
addHandler("hue2", adjustmentType("hue/saturation"), function(reader, target, left) {
  if (readUint16(reader) !== 2)
    throw new Error("Invalid hue2 version");
  target.adjustment = __assign$3(__assign$3({}, target.adjustment), { type: "hue/saturation", master: readHueChannel(reader), reds: readHueChannel(reader), yellows: readHueChannel(reader), greens: readHueChannel(reader), cyans: readHueChannel(reader), blues: readHueChannel(reader), magentas: readHueChannel(reader) });
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  writeUint16(writer, 2);
  writeHueChannel(writer, info.master);
  writeHueChannel(writer, info.reds);
  writeHueChannel(writer, info.yellows);
  writeHueChannel(writer, info.greens);
  writeHueChannel(writer, info.cyans);
  writeHueChannel(writer, info.blues);
  writeHueChannel(writer, info.magentas);
});
function readColorBalance(reader) {
  return {
    cyanRed: readInt16(reader),
    magentaGreen: readInt16(reader),
    yellowBlue: readInt16(reader)
  };
}
function writeColorBalance(writer, value) {
  writeInt16(writer, value.cyanRed || 0);
  writeInt16(writer, value.magentaGreen || 0);
  writeInt16(writer, value.yellowBlue || 0);
}
addHandler("blnc", adjustmentType("color balance"), function(reader, target, left) {
  target.adjustment = {
    type: "color balance",
    shadows: readColorBalance(reader),
    midtones: readColorBalance(reader),
    highlights: readColorBalance(reader),
    preserveLuminosity: !!readUint8(reader)
  };
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  writeColorBalance(writer, info.shadows || {});
  writeColorBalance(writer, info.midtones || {});
  writeColorBalance(writer, info.highlights || {});
  writeUint8(writer, info.preserveLuminosity ? 1 : 0);
  writeZeros(writer, 1);
});
addHandler("blwh", adjustmentType("black & white"), function(reader, target, left) {
  var desc = readVersionAndDescriptor(reader);
  target.adjustment = {
    type: "black & white",
    reds: desc["Rd  "],
    yellows: desc.Yllw,
    greens: desc["Grn "],
    cyans: desc["Cyn "],
    blues: desc["Bl  "],
    magentas: desc.Mgnt,
    useTint: !!desc.useTint,
    presetKind: desc.bwPresetKind,
    presetFileName: desc.blackAndWhitePresetFileName
  };
  if (desc.tintColor !== void 0)
    target.adjustment.tintColor = parseColor(desc.tintColor);
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  var desc = {
    "Rd  ": info.reds || 0,
    Yllw: info.yellows || 0,
    "Grn ": info.greens || 0,
    "Cyn ": info.cyans || 0,
    "Bl  ": info.blues || 0,
    Mgnt: info.magentas || 0,
    useTint: !!info.useTint,
    tintColor: serializeColor(info.tintColor),
    bwPresetKind: info.presetKind || 0,
    blackAndWhitePresetFileName: info.presetFileName || ""
  };
  writeVersionAndDescriptor(writer, "", "null", desc);
});
addHandler("phfl", adjustmentType("photo filter"), function(reader, target, left) {
  var version2 = readUint16(reader);
  if (version2 !== 2 && version2 !== 3)
    throw new Error("Invalid phfl version");
  var color;
  if (version2 === 2) {
    color = readColor(reader);
  } else {
    color = {
      l: readInt32(reader) / 100,
      a: readInt32(reader) / 100,
      b: readInt32(reader) / 100
    };
  }
  target.adjustment = {
    type: "photo filter",
    color,
    density: readUint32(reader) / 100,
    preserveLuminosity: !!readUint8(reader)
  };
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  writeUint16(writer, 2);
  writeColor(writer, info.color || { l: 0, a: 0, b: 0 });
  writeUint32(writer, (info.density || 0) * 100);
  writeUint8(writer, info.preserveLuminosity ? 1 : 0);
  writeZeros(writer, 3);
});
function readMixrChannel(reader) {
  var red = readInt16(reader);
  var green = readInt16(reader);
  var blue = readInt16(reader);
  skipBytes(reader, 2);
  var constant = readInt16(reader);
  return { red, green, blue, constant };
}
function writeMixrChannel(writer, channel) {
  var c2 = channel || {};
  writeInt16(writer, c2.red);
  writeInt16(writer, c2.green);
  writeInt16(writer, c2.blue);
  writeZeros(writer, 2);
  writeInt16(writer, c2.constant);
}
addHandler("mixr", adjustmentType("channel mixer"), function(reader, target, left) {
  if (readUint16(reader) !== 1)
    throw new Error("Invalid mixr version");
  var adjustment = target.adjustment = __assign$3(__assign$3({}, target.adjustment), { type: "channel mixer", monochrome: !!readUint16(reader) });
  if (!adjustment.monochrome) {
    adjustment.red = readMixrChannel(reader);
    adjustment.green = readMixrChannel(reader);
    adjustment.blue = readMixrChannel(reader);
  }
  adjustment.gray = readMixrChannel(reader);
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  writeUint16(writer, 1);
  writeUint16(writer, info.monochrome ? 1 : 0);
  if (info.monochrome) {
    writeMixrChannel(writer, info.gray);
    writeZeros(writer, 3 * 5 * 2);
  } else {
    writeMixrChannel(writer, info.red);
    writeMixrChannel(writer, info.green);
    writeMixrChannel(writer, info.blue);
    writeMixrChannel(writer, info.gray);
  }
});
var colorLookupType = createEnum("colorLookupType", "3DLUT", {
  "3dlut": "3DLUT",
  abstractProfile: "abstractProfile",
  deviceLinkProfile: "deviceLinkProfile"
});
var LUTFormatType = createEnum("LUTFormatType", "look", {
  look: "LUTFormatLOOK",
  cube: "LUTFormatCUBE",
  "3dl": "LUTFormat3DL"
});
var colorLookupOrder = createEnum("colorLookupOrder", "rgb", {
  rgb: "rgbOrder",
  bgr: "bgrOrder"
});
addHandler("clrL", adjustmentType("color lookup"), function(reader, target, left) {
  if (readUint16(reader) !== 1)
    throw new Error("Invalid clrL version");
  var desc = readVersionAndDescriptor(reader);
  target.adjustment = { type: "color lookup" };
  var info = target.adjustment;
  if (desc.lookupType !== void 0)
    info.lookupType = colorLookupType.decode(desc.lookupType);
  if (desc["Nm  "] !== void 0)
    info.name = desc["Nm  "];
  if (desc.Dthr !== void 0)
    info.dither = desc.Dthr;
  if (desc.profile !== void 0)
    info.profile = desc.profile;
  if (desc.LUTFormat !== void 0)
    info.lutFormat = LUTFormatType.decode(desc.LUTFormat);
  if (desc.dataOrder !== void 0)
    info.dataOrder = colorLookupOrder.decode(desc.dataOrder);
  if (desc.tableOrder !== void 0)
    info.tableOrder = colorLookupOrder.decode(desc.tableOrder);
  if (desc.LUT3DFileData !== void 0)
    info.lut3DFileData = desc.LUT3DFileData;
  if (desc.LUT3DFileName !== void 0)
    info.lut3DFileName = desc.LUT3DFileName;
  skipBytes(reader, left());
}, function(writer, target) {
  var info = target.adjustment;
  var desc = {};
  if (info.lookupType !== void 0)
    desc.lookupType = colorLookupType.encode(info.lookupType);
  if (info.name !== void 0)
    desc["Nm  "] = info.name;
  if (info.dither !== void 0)
    desc.Dthr = info.dither;
  if (info.profile !== void 0)
    desc.profile = info.profile;
  if (info.lutFormat !== void 0)
    desc.LUTFormat = LUTFormatType.encode(info.lutFormat);
  if (info.dataOrder !== void 0)
    desc.dataOrder = colorLookupOrder.encode(info.dataOrder);
  if (info.tableOrder !== void 0)
    desc.tableOrder = colorLookupOrder.encode(info.tableOrder);
  if (info.lut3DFileData !== void 0)
    desc.LUT3DFileData = info.lut3DFileData;
  if (info.lut3DFileName !== void 0)
    desc.LUT3DFileName = info.lut3DFileName;
  writeUint16(writer, 1);
  writeVersionAndDescriptor(writer, "", "null", desc);
});
addHandler("nvrt", adjustmentType("invert"), function(reader, target, left) {
  target.adjustment = { type: "invert" };
  skipBytes(reader, left());
}, function() {
});
addHandler("post", adjustmentType("posterize"), function(reader, target, left) {
  target.adjustment = {
    type: "posterize",
    levels: readUint16(reader)
  };
  skipBytes(reader, left());
}, function(writer, target) {
  var _a;
  var info = target.adjustment;
  writeUint16(writer, (_a = info.levels) !== null && _a !== void 0 ? _a : 4);
  writeZeros(writer, 2);
});
addHandler("thrs", adjustmentType("threshold"), function(reader, target, left) {
  target.adjustment = {
    type: "threshold",
    level: readUint16(reader)
  };
  skipBytes(reader, left());
}, function(writer, target) {
  var _a;
  var info = target.adjustment;
  writeUint16(writer, (_a = info.level) !== null && _a !== void 0 ? _a : 128);
  writeZeros(writer, 2);
});
var grdmColorModels = ["", "", "", "rgb", "hsb", "", "lab"];
addHandler("grdm", adjustmentType("gradient map"), function(reader, target, left) {
  var version2 = readUint16(reader);
  if (version2 !== 1 && version2 !== 3)
    throw new Error("Invalid grdm version");
  var info = {
    type: "gradient map",
    gradientType: "solid"
  };
  info.reverse = !!readUint8(reader);
  info.dither = !!readUint8(reader);
  var hasMethod = !!readUint8(reader);
  reader.offset--;
  if (hasMethod) {
    var method = readSignature(reader);
    info.method = gradientInterpolationMethodType.decode(method);
  }
  info.name = readUnicodeString(reader);
  info.colorStops = [];
  info.opacityStops = [];
  var stopsCount = readUint16(reader);
  for (var i2 = 0; i2 < stopsCount; i2++) {
    info.colorStops.push({
      location: readUint32(reader),
      midpoint: readUint32(reader) / 100,
      color: readColor(reader)
    });
    skipBytes(reader, 2);
  }
  var opacityStopsCount = readUint16(reader);
  for (var i2 = 0; i2 < opacityStopsCount; i2++) {
    info.opacityStops.push({
      location: readUint32(reader),
      midpoint: readUint32(reader) / 100,
      opacity: readUint16(reader) / 255
    });
  }
  var expansionCount = readUint16(reader);
  if (expansionCount !== 2)
    throw new Error("Invalid grdm expansion count");
  var interpolation = readUint16(reader);
  info.smoothness = interpolation / 4096;
  var length = readUint16(reader);
  if (length !== 32)
    throw new Error("Invalid grdm length");
  info.gradientType = readUint16(reader) ? "noise" : "solid";
  info.randomSeed = readUint32(reader);
  info.addTransparency = !!readUint16(reader);
  info.restrictColors = !!readUint16(reader);
  info.roughness = readUint32(reader) / 4096;
  info.colorModel = grdmColorModels[readUint16(reader)] || "rgb";
  info.min = [
    readUint16(reader) / 32768,
    readUint16(reader) / 32768,
    readUint16(reader) / 32768,
    readUint16(reader) / 32768
  ];
  info.max = [
    readUint16(reader) / 32768,
    readUint16(reader) / 32768,
    readUint16(reader) / 32768,
    readUint16(reader) / 32768
  ];
  skipBytes(reader, left());
  for (var _i = 0, _a = info.colorStops; _i < _a.length; _i++) {
    var s2 = _a[_i];
    s2.location /= interpolation;
  }
  for (var _b = 0, _c = info.opacityStops; _b < _c.length; _b++) {
    var s2 = _c[_b];
    s2.location /= interpolation;
  }
  target.adjustment = info;
}, function(writer, target) {
  var _a, _b, _c;
  var info = target.adjustment;
  writeUint16(writer, info.method !== void 0 ? 3 : 1);
  writeUint8(writer, info.reverse ? 1 : 0);
  writeUint8(writer, info.dither ? 1 : 0);
  if (info.method !== void 0) {
    writeSignature(writer, gradientInterpolationMethodType.encode(info.method));
  }
  writeUnicodeStringWithPadding(writer, info.name || "");
  writeUint16(writer, info.colorStops && info.colorStops.length || 0);
  var interpolation = Math.round(((_a = info.smoothness) !== null && _a !== void 0 ? _a : 1) * 4096);
  for (var _i = 0, _d = info.colorStops || []; _i < _d.length; _i++) {
    var s2 = _d[_i];
    writeUint32(writer, Math.round(s2.location * interpolation));
    writeUint32(writer, Math.round(s2.midpoint * 100));
    writeColor(writer, s2.color);
    writeZeros(writer, 2);
  }
  writeUint16(writer, info.opacityStops && info.opacityStops.length || 0);
  for (var _e = 0, _f = info.opacityStops || []; _e < _f.length; _e++) {
    var s2 = _f[_e];
    writeUint32(writer, Math.round(s2.location * interpolation));
    writeUint32(writer, Math.round(s2.midpoint * 100));
    writeUint16(writer, Math.round(s2.opacity * 255));
  }
  writeUint16(writer, 2);
  writeUint16(writer, interpolation);
  writeUint16(writer, 32);
  writeUint16(writer, info.gradientType === "noise" ? 1 : 0);
  writeUint32(writer, info.randomSeed || 0);
  writeUint16(writer, info.addTransparency ? 1 : 0);
  writeUint16(writer, info.restrictColors ? 1 : 0);
  writeUint32(writer, Math.round(((_b = info.roughness) !== null && _b !== void 0 ? _b : 1) * 4096));
  var colorModel = grdmColorModels.indexOf((_c = info.colorModel) !== null && _c !== void 0 ? _c : "rgb");
  writeUint16(writer, colorModel === -1 ? 3 : colorModel);
  for (var i2 = 0; i2 < 4; i2++)
    writeUint16(writer, Math.round((info.min && info.min[i2] || 0) * 32768));
  for (var i2 = 0; i2 < 4; i2++)
    writeUint16(writer, Math.round((info.max && info.max[i2] || 0) * 32768));
  writeZeros(writer, 4);
});
function readSelectiveColors(reader) {
  return {
    c: readInt16(reader),
    m: readInt16(reader),
    y: readInt16(reader),
    k: readInt16(reader)
  };
}
function writeSelectiveColors(writer, cmyk) {
  var c2 = cmyk || {};
  writeInt16(writer, c2.c);
  writeInt16(writer, c2.m);
  writeInt16(writer, c2.y);
  writeInt16(writer, c2.k);
}
addHandler("selc", adjustmentType("selective color"), function(reader, target) {
  if (readUint16(reader) !== 1)
    throw new Error("Invalid selc version");
  var mode = readUint16(reader) ? "absolute" : "relative";
  skipBytes(reader, 8);
  target.adjustment = {
    type: "selective color",
    mode,
    reds: readSelectiveColors(reader),
    yellows: readSelectiveColors(reader),
    greens: readSelectiveColors(reader),
    cyans: readSelectiveColors(reader),
    blues: readSelectiveColors(reader),
    magentas: readSelectiveColors(reader),
    whites: readSelectiveColors(reader),
    neutrals: readSelectiveColors(reader),
    blacks: readSelectiveColors(reader)
  };
}, function(writer, target) {
  var info = target.adjustment;
  writeUint16(writer, 1);
  writeUint16(writer, info.mode === "absolute" ? 1 : 0);
  writeZeros(writer, 8);
  writeSelectiveColors(writer, info.reds);
  writeSelectiveColors(writer, info.yellows);
  writeSelectiveColors(writer, info.greens);
  writeSelectiveColors(writer, info.cyans);
  writeSelectiveColors(writer, info.blues);
  writeSelectiveColors(writer, info.magentas);
  writeSelectiveColors(writer, info.whites);
  writeSelectiveColors(writer, info.neutrals);
  writeSelectiveColors(writer, info.blacks);
});
addHandler("CgEd", function(target) {
  var a2 = target.adjustment;
  if (!a2)
    return false;
  return a2.type === "brightness/contrast" && !a2.useLegacy || (a2.type === "levels" || a2.type === "curves" || a2.type === "exposure" || a2.type === "channel mixer" || a2.type === "hue/saturation") && a2.presetFileName !== void 0;
}, function(reader, target, left) {
  var desc = readVersionAndDescriptor(reader);
  if (desc.Vrsn !== 1)
    throw new Error("Invalid CgEd version");
  if ("presetFileName" in desc) {
    target.adjustment = __assign$3(__assign$3({}, target.adjustment), { presetKind: desc.presetKind, presetFileName: desc.presetFileName });
  } else if ("curvesPresetFileName" in desc) {
    target.adjustment = __assign$3(__assign$3({}, target.adjustment), { presetKind: desc.curvesPresetKind, presetFileName: desc.curvesPresetFileName });
  } else if ("mixerPresetFileName" in desc) {
    target.adjustment = __assign$3(__assign$3({}, target.adjustment), { presetKind: desc.mixerPresetKind, presetFileName: desc.mixerPresetFileName });
  } else {
    target.adjustment = {
      type: "brightness/contrast",
      brightness: desc.Brgh,
      contrast: desc.Cntr,
      meanValue: desc.means,
      useLegacy: !!desc.useLegacy,
      labColorOnly: !!desc["Lab "],
      auto: !!desc.Auto
    };
  }
  skipBytes(reader, left());
}, function(writer, target) {
  var _a, _b, _c, _d;
  var info = target.adjustment;
  if (info.type === "levels" || info.type === "exposure" || info.type === "hue/saturation") {
    var desc = {
      Vrsn: 1,
      presetKind: (_a = info.presetKind) !== null && _a !== void 0 ? _a : 1,
      presetFileName: info.presetFileName || ""
    };
    writeVersionAndDescriptor(writer, "", "null", desc);
  } else if (info.type === "curves") {
    var desc = {
      Vrsn: 1,
      curvesPresetKind: (_b = info.presetKind) !== null && _b !== void 0 ? _b : 1,
      curvesPresetFileName: info.presetFileName || ""
    };
    writeVersionAndDescriptor(writer, "", "null", desc);
  } else if (info.type === "channel mixer") {
    var desc = {
      Vrsn: 1,
      mixerPresetKind: (_c = info.presetKind) !== null && _c !== void 0 ? _c : 1,
      mixerPresetFileName: info.presetFileName || ""
    };
    writeVersionAndDescriptor(writer, "", "null", desc);
  } else if (info.type === "brightness/contrast") {
    var desc = {
      Vrsn: 1,
      Brgh: info.brightness || 0,
      Cntr: info.contrast || 0,
      means: (_d = info.meanValue) !== null && _d !== void 0 ? _d : 127,
      "Lab ": !!info.labColorOnly,
      useLegacy: !!info.useLegacy,
      Auto: !!info.auto
    };
    writeVersionAndDescriptor(writer, "", "null", desc);
  } else {
    throw new Error("Unhandled CgEd case");
  }
});
function getTextLayersSortedByIndex(psd) {
  var layers = [];
  function collect(layer) {
    var _a;
    if (layer.children) {
      for (var _i = 0, _b = layer.children; _i < _b.length; _i++) {
        var child = _b[_i];
        if (((_a = child.text) === null || _a === void 0 ? void 0 : _a.index) !== void 0) {
          layers[child.text.index] = child;
        }
        collect(child);
      }
    }
  }
  collect(psd);
  return layers;
}
addHandler("Txt2", hasKey("engineData"), function(reader, target, left, psd) {
  var data3 = readBytes(reader, left());
  target.engineData = base64JsExports.fromByteArray(data3);
  var layersByIndex = getTextLayersSortedByIndex(psd);
  var engineData = parseEngineData(data3);
  var engineData2 = decodeEngineData2(engineData);
  var TextFrameSet = engineData2.ResourceDict.TextFrameSet;
  if (TextFrameSet) {
    for (var i2 = 0; i2 < TextFrameSet.length; i2++) {
      var layer = layersByIndex[i2];
      if (TextFrameSet[i2].path && (layer === null || layer === void 0 ? void 0 : layer.text)) {
        layer.text.textPath = TextFrameSet[i2].path;
      }
    }
  }
}, function(writer, target) {
  var buffer = base64JsExports.toByteArray(target.engineData);
  writeBytes(writer, buffer);
});
addHandler("FEid", hasKey("filterEffectsMasks"), function(reader, target, leftBytes) {
  var version2 = readInt32(reader);
  if (version2 < 1 || version2 > 3)
    throw new Error("Invalid filterEffects version ".concat(version2));
  target.filterEffectsMasks = [];
  while (leftBytes() > 8) {
    if (readUint32(reader))
      throw new Error("filterEffects: 64 bit length is not supported");
    var length_2 = readUint32(reader);
    var end = reader.offset + length_2;
    var id = readPascalString(reader, 1);
    var effectVersion = readInt32(reader);
    if (effectVersion !== 1)
      throw new Error("Invalid filterEffect version ".concat(effectVersion));
    if (readUint32(reader))
      throw new Error("filterEffect: 64 bit length is not supported");
    readUint32(reader);
    var top_2 = readInt32(reader);
    var left = readInt32(reader);
    var bottom = readInt32(reader);
    var right = readInt32(reader);
    var depth = readInt32(reader);
    var maxChannels = readInt32(reader);
    var channels2 = [];
    for (var i2 = 0; i2 < maxChannels + 2; i2++) {
      var exists = readInt32(reader);
      if (exists) {
        if (readUint32(reader))
          throw new Error("filterEffect: 64 bit length is not supported");
        var channelLength = readUint32(reader);
        if (!channelLength)
          throw new Error("filterEffect: Empty channel");
        var compressionMode = readUint16(reader);
        var data3 = readBytes(reader, channelLength - 2);
        channels2.push({ compressionMode, data: data3 });
      } else {
        channels2.push(void 0);
      }
    }
    target.filterEffectsMasks.push({ id, top: top_2, left, bottom, right, depth, channels: channels2 });
    if (reader.offset < end && readUint8(reader)) {
      var top_3 = readInt32(reader);
      var left_1 = readInt32(reader);
      var bottom_1 = readInt32(reader);
      var right_1 = readInt32(reader);
      if (readUint32(reader))
        throw new Error("filterEffect: 64 bit length is not supported");
      var extraLength = readUint32(reader);
      var compressionMode = readUint16(reader);
      var data3 = readBytes(reader, extraLength - 2);
      target.filterEffectsMasks[target.filterEffectsMasks.length - 1].extra = { top: top_3, left: left_1, bottom: bottom_1, right: right_1, compressionMode, data: data3 };
    }
    reader.offset = end;
    var len = length_2;
    while (len % 4) {
      reader.offset++;
      len++;
    }
  }
}, function(writer, target) {
  var _a;
  writeInt32(writer, 3);
  for (var _i = 0, _b = target.filterEffectsMasks; _i < _b.length; _i++) {
    var mask3 = _b[_i];
    writeUint32(writer, 0);
    writeUint32(writer, 0);
    var lengthOffset = writer.offset;
    writePascalString(writer, mask3.id, 1);
    writeInt32(writer, 1);
    writeUint32(writer, 0);
    writeUint32(writer, 0);
    var length2Offset = writer.offset;
    writeInt32(writer, mask3.top);
    writeInt32(writer, mask3.left);
    writeInt32(writer, mask3.bottom);
    writeInt32(writer, mask3.right);
    writeInt32(writer, mask3.depth);
    var maxChannels = Math.max(0, mask3.channels.length - 2);
    writeInt32(writer, maxChannels);
    for (var i2 = 0; i2 < maxChannels + 2; i2++) {
      var channel = mask3.channels[i2];
      writeInt32(writer, channel ? 1 : 0);
      if (channel) {
        writeUint32(writer, 0);
        writeUint32(writer, channel.data.length + 2);
        writeUint16(writer, channel.compressionMode);
        writeBytes(writer, channel.data);
      }
    }
    writer.view.setUint32(length2Offset - 4, writer.offset - length2Offset, false);
    var extra = (_a = target.filterEffectsMasks[target.filterEffectsMasks.length - 1]) === null || _a === void 0 ? void 0 : _a.extra;
    if (extra) {
      writeUint8(writer, 1);
      writeInt32(writer, extra.top);
      writeInt32(writer, extra.left);
      writeInt32(writer, extra.bottom);
      writeInt32(writer, extra.right);
      writeUint32(writer, 0);
      writeUint32(writer, extra.data.byteLength + 2);
      writeUint16(writer, extra.compressionMode);
      writeBytes(writer, extra.data);
    }
    var length_3 = writer.offset - lengthOffset;
    writer.view.setUint32(lengthOffset - 4, length_3, false);
    while (length_3 % 4) {
      writeZeros(writer, 1);
      length_3++;
    }
  }
});
addHandlerAlias("FXid", "FEid");
addHandler("FMsk", hasKey("filterMask"), function(reader, target) {
  target.filterMask = {
    colorSpace: readColor(reader),
    opacity: readUint16(reader) / 255
  };
}, function(writer, target) {
  var _a;
  writeColor(writer, target.filterMask.colorSpace);
  writeUint16(writer, clamp((_a = target.filterMask.opacity) !== null && _a !== void 0 ? _a : 1, 0, 1) * 255);
});
addHandler(
  "artd",
  // document-wide artboard info
  function(target) {
    return target.artboards !== void 0;
  },
  function(reader, target, left) {
    var desc = readVersionAndDescriptor(reader);
    target.artboards = {
      count: desc["Cnt "],
      autoExpandOffset: { horizontal: desc.autoExpandOffset.Hrzn, vertical: desc.autoExpandOffset.Vrtc },
      origin: { horizontal: desc.origin.Hrzn, vertical: desc.origin.Vrtc },
      autoExpandEnabled: desc.autoExpandEnabled,
      autoNestEnabled: desc.autoNestEnabled,
      autoPositionEnabled: desc.autoPositionEnabled,
      shrinkwrapOnSaveEnabled: !!desc.shrinkwrapOnSaveEnabled,
      docDefaultNewArtboardBackgroundColor: parseColor(desc.docDefaultNewArtboardBackgroundColor),
      docDefaultNewArtboardBackgroundType: desc.docDefaultNewArtboardBackgroundType
    };
    skipBytes(reader, left());
  },
  function(writer, target) {
    var _a, _b, _c, _d, _e;
    var artb = target.artboards;
    var desc = {
      "Cnt ": artb.count,
      autoExpandOffset: artb.autoExpandOffset ? { Hrzn: artb.autoExpandOffset.horizontal, Vrtc: artb.autoExpandOffset.vertical } : { Hrzn: 0, Vrtc: 0 },
      origin: artb.origin ? { Hrzn: artb.origin.horizontal, Vrtc: artb.origin.vertical } : { Hrzn: 0, Vrtc: 0 },
      autoExpandEnabled: (_a = artb.autoExpandEnabled) !== null && _a !== void 0 ? _a : true,
      autoNestEnabled: (_b = artb.autoNestEnabled) !== null && _b !== void 0 ? _b : true,
      autoPositionEnabled: (_c = artb.autoPositionEnabled) !== null && _c !== void 0 ? _c : true,
      shrinkwrapOnSaveEnabled: (_d = artb.shrinkwrapOnSaveEnabled) !== null && _d !== void 0 ? _d : true,
      docDefaultNewArtboardBackgroundColor: serializeColor(artb.docDefaultNewArtboardBackgroundColor),
      docDefaultNewArtboardBackgroundType: (_e = artb.docDefaultNewArtboardBackgroundType) !== null && _e !== void 0 ? _e : 1
    };
    writeVersionAndDescriptor(writer, "", "null", desc, "artd");
  }
);
function hasMultiEffects(effects) {
  return Object.keys(effects).map(function(key) {
    return effects[key];
  }).some(function(v2) {
    return Array.isArray(v2) && v2.length > 1;
  });
}
addHandler("lfx2", function(target) {
  return target.effects !== void 0 && !hasMultiEffects(target.effects);
}, function(reader, target, left) {
  var version2 = readUint32(reader);
  if (version2 !== 0)
    throw new Error("Invalid lfx2 version");
  var desc = readVersionAndDescriptor(reader);
  target.effects = parseEffects(desc, !!reader.logMissingFeatures);
  skipBytes(reader, left());
}, function(writer, target, _, options) {
  var desc = serializeEffects(target.effects, !!options.logMissingFeatures, true);
  writeUint32(writer, 0);
  writeVersionAndDescriptor(writer, "", "null", desc);
});
addHandler("cinf", hasKey("compositorUsed"), function(reader, target, left) {
  var desc = readVersionAndDescriptor(reader);
  function enumValue(desc2) {
    return desc2.split(".")[1];
  }
  target.compositorUsed = {
    description: desc.description,
    reason: desc.reason,
    engine: enumValue(desc.Engn)
  };
  if (desc.Vrsn)
    target.compositorUsed.version = desc.Vrsn;
  if (desc.psVersion)
    target.compositorUsed.photoshopVersion = desc.psVersion;
  if (desc.enableCompCore)
    target.compositorUsed.enableCompCore = enumValue(desc.enableCompCore);
  if (desc.enableCompCoreGPU)
    target.compositorUsed.enableCompCoreGPU = enumValue(desc.enableCompCoreGPU);
  if (desc.enableCompCoreThreads)
    target.compositorUsed.enableCompCoreThreads = enumValue(desc.enableCompCoreThreads);
  if (desc.compCoreSupport)
    target.compositorUsed.compCoreSupport = enumValue(desc.compCoreSupport);
  if (desc.compCoreGPUSupport)
    target.compositorUsed.compCoreGPUSupport = enumValue(desc.compCoreGPUSupport);
  skipBytes(reader, left());
}, function(writer, target) {
  var cinf = target.compositorUsed;
  var desc = {
    Vrsn: cinf.version || { major: 1, minor: 0, fix: 0 }
  };
  if (cinf.photoshopVersion)
    desc.psVersion = cinf.photoshopVersion;
  desc.description = cinf.description;
  desc.reason = cinf.reason;
  desc.Engn = "Engn.".concat(cinf.engine);
  if (cinf.enableCompCore)
    desc.enableCompCore = "enable.".concat(cinf.enableCompCore);
  if (cinf.enableCompCoreGPU)
    desc.enableCompCoreGPU = "enable.".concat(cinf.enableCompCoreGPU);
  if (cinf.enableCompCoreThreads)
    desc.enableCompCoreThreads = "enable.".concat(cinf.enableCompCoreThreads);
  if (cinf.compCoreSupport)
    desc.compCoreSupport = "reason.".concat(cinf.compCoreSupport);
  if (cinf.compCoreGPUSupport)
    desc.compCoreGPUSupport = "reason.".concat(cinf.compCoreGPUSupport);
  writeVersionAndDescriptor(writer, "", "null", desc);
});
addHandler("extn", function(target) {
  return target._extn !== void 0;
}, function(reader, target) {
  readVersionAndDescriptor(reader);
}, function(writer, target) {
});
addHandler("iOpa", hasKey("fillOpacity"), function(reader, target) {
  target.fillOpacity = readUint8(reader) / 255;
  skipBytes(reader, 3);
}, function(writer, target) {
  writeUint8(writer, target.fillOpacity * 255);
  writeZeros(writer, 3);
});
addHandler("brst", hasKey("channelBlendingRestrictions"), function(reader, target, left) {
  target.channelBlendingRestrictions = [];
  while (left() > 4) {
    target.channelBlendingRestrictions.push(readInt32(reader));
  }
}, function(writer, target) {
  for (var _i = 0, _a = target.channelBlendingRestrictions; _i < _a.length; _i++) {
    var channel = _a[_i];
    writeInt32(writer, channel);
  }
});
addHandler("tsly", hasKey("transparencyShapesLayer"), function(reader, target) {
  target.transparencyShapesLayer = !!readUint8(reader);
  skipBytes(reader, 3);
}, function(writer, target) {
  writeUint8(writer, target.transparencyShapesLayer ? 1 : 0);
  writeZeros(writer, 3);
});
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
function createWriter(size) {
  if (size === void 0) {
    size = 4096;
  }
  var buffer = new ArrayBuffer(size);
  var view = new DataView(buffer);
  var offset = 0;
  return { buffer, view, offset, tempBuffer: void 0 };
}
function getWriterBuffer(writer) {
  return writer.buffer.slice(0, writer.offset);
}
function writeUint8(writer, value) {
  var offset = addSize(writer, 1);
  writer.view.setUint8(offset, value);
}
function writeInt16(writer, value) {
  var offset = addSize(writer, 2);
  writer.view.setInt16(offset, value, false);
}
function writeUint16(writer, value) {
  var offset = addSize(writer, 2);
  writer.view.setUint16(offset, value, false);
}
function writeUint16LE(writer, value) {
  var offset = addSize(writer, 2);
  writer.view.setUint16(offset, value, true);
}
function writeInt32(writer, value) {
  var offset = addSize(writer, 4);
  writer.view.setInt32(offset, value, false);
}
function writeInt32LE(writer, value) {
  var offset = addSize(writer, 4);
  writer.view.setInt32(offset, value, true);
}
function writeUint32(writer, value) {
  var offset = addSize(writer, 4);
  writer.view.setUint32(offset, value, false);
}
function writeFloat32(writer, value) {
  var offset = addSize(writer, 4);
  writer.view.setFloat32(offset, value, false);
}
function writeFloat64(writer, value) {
  var offset = addSize(writer, 8);
  writer.view.setFloat64(offset, value, false);
}
function writeFixedPoint32(writer, value) {
  writeInt32(writer, value * (1 << 16));
}
function writeFixedPointPath32(writer, value) {
  writeInt32(writer, value * (1 << 24));
}
function writeBytes(writer, buffer) {
  if (buffer) {
    ensureSize(writer, writer.offset + buffer.length);
    var bytes = new Uint8Array(writer.buffer);
    bytes.set(buffer, writer.offset);
    writer.offset += buffer.length;
  }
}
function writeZeros(writer, count) {
  for (var i2 = 0; i2 < count; i2++) {
    writeUint8(writer, 0);
  }
}
function writeSignature(writer, signature) {
  if (signature.length !== 4)
    throw new Error("Invalid signature: '".concat(signature, "'"));
  for (var i2 = 0; i2 < 4; i2++) {
    writeUint8(writer, signature.charCodeAt(i2));
  }
}
function writeAsciiString(writer, text) {
  for (var i2 = 0; i2 < text.length; i2++) {
    writeUint8(writer, text.charCodeAt(i2));
  }
}
function writePascalString(writer, text, padTo) {
  var length = text.length;
  if (length > 255)
    throw new Error("String too long");
  writeUint8(writer, length);
  for (var i2 = 0; i2 < length; i2++) {
    var code2 = text.charCodeAt(i2);
    writeUint8(writer, code2 < 128 ? code2 : "?".charCodeAt(0));
  }
  while (++length % padTo) {
    writeUint8(writer, 0);
  }
}
function writeUnicodeStringWithoutLength(writer, text) {
  for (var i2 = 0; i2 < text.length; i2++) {
    writeUint16(writer, text.charCodeAt(i2));
  }
}
function writeUnicodeStringWithoutLengthLE(writer, text) {
  for (var i2 = 0; i2 < text.length; i2++) {
    writeUint16LE(writer, text.charCodeAt(i2));
  }
}
function writeUnicodeString(writer, text) {
  writeUint32(writer, text.length);
  writeUnicodeStringWithoutLength(writer, text);
}
function writeUnicodeStringWithPadding(writer, text) {
  writeUint32(writer, text.length + 1);
  for (var i2 = 0; i2 < text.length; i2++) {
    writeUint16(writer, text.charCodeAt(i2));
  }
  writeUint16(writer, 0);
}
function getLargestLayerSize(layers) {
  if (layers === void 0) {
    layers = [];
  }
  var max = 0;
  for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
    var layer = layers_1[_i];
    if (layer.canvas || layer.imageData) {
      var _a = getLayerDimentions(layer), width = _a.width, height = _a.height;
      max = Math.max(max, 2 * height + 2 * width * height);
    }
    if (layer.children) {
      max = Math.max(max, getLargestLayerSize(layer.children));
    }
  }
  return max;
}
function writeSection(writer, round, func, writeTotalLength, large) {
  if (writeTotalLength === void 0) {
    writeTotalLength = false;
  }
  if (large === void 0) {
    large = false;
  }
  if (large)
    writeUint32(writer, 0);
  var offset = writer.offset;
  writeUint32(writer, 0);
  func();
  var length = writer.offset - offset - 4;
  var len = length;
  while (len % round) {
    writeUint8(writer, 0);
    len++;
  }
  if (writeTotalLength) {
    length = len;
  }
  writer.view.setUint32(offset, length, false);
}
function verifyBitCount(target) {
  var _a;
  (_a = target.children) === null || _a === void 0 ? void 0 : _a.forEach(verifyBitCount);
  var data3 = target.imageData;
  if (data3 && (data3.data instanceof Uint32Array || data3.data instanceof Uint16Array)) {
    throw new Error("imageData has incorrect bitDepth");
  }
  if ("mask" in target && target.mask) {
    var data_1 = target.mask.imageData;
    if (data_1 && (data_1.data instanceof Uint32Array || data_1.data instanceof Uint16Array)) {
      throw new Error("mask imageData has incorrect bitDepth");
    }
  }
}
function writePsd$1(writer, psd, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  if (!(+psd.width > 0 && +psd.height > 0))
    throw new Error("Invalid document size");
  if ((psd.width > 3e4 || psd.height > 3e4) && !options.psb)
    throw new Error("Document size is too large (max is 30000x30000, use PSB format instead)");
  var bitsPerChannel = (_a = psd.bitsPerChannel) !== null && _a !== void 0 ? _a : 8;
  if (bitsPerChannel !== 8)
    throw new Error("bitsPerChannel other than 8 are not supported for writing");
  verifyBitCount(psd);
  var imageResources = __assign$2({}, psd.imageResources);
  var opt = __assign$2(__assign$2({}, options), { layerIds: /* @__PURE__ */ new Set(), layerToId: /* @__PURE__ */ new Map() });
  if (opt.generateThumbnail) {
    imageResources.thumbnail = createThumbnail(psd);
  }
  var imageData = psd.imageData;
  if (!imageData && psd.canvas) {
    imageData = psd.canvas.getContext("2d").getImageData(0, 0, psd.canvas.width, psd.canvas.height);
  }
  if (imageData && (psd.width !== imageData.width || psd.height !== imageData.height))
    throw new Error("Document canvas must have the same size as document");
  var globalAlpha = !!imageData && hasAlpha(imageData);
  var maxBufferSize = Math.max(getLargestLayerSize(psd.children), 4 * 2 * psd.width * psd.height + 2 * psd.height);
  writer.tempBuffer = new Uint8Array(maxBufferSize);
  writeSignature(writer, "8BPS");
  writeUint16(writer, options.psb ? 2 : 1);
  writeZeros(writer, 6);
  writeUint16(writer, globalAlpha ? 4 : 3);
  writeUint32(writer, psd.height);
  writeUint32(writer, psd.width);
  writeUint16(writer, bitsPerChannel);
  writeUint16(
    writer,
    3
    /* ColorMode.RGB */
  );
  writeSection(writer, 1, function() {
    var _a2, _b, _c;
    if (psd.palette) {
      for (var i3 = 0; i3 < 256; i3++)
        writeUint8(writer, ((_a2 = psd.palette[i3]) === null || _a2 === void 0 ? void 0 : _a2.r) || 0);
      for (var i3 = 0; i3 < 256; i3++)
        writeUint8(writer, ((_b = psd.palette[i3]) === null || _b === void 0 ? void 0 : _b.g) || 0);
      for (var i3 = 0; i3 < 256; i3++)
        writeUint8(writer, ((_c = psd.palette[i3]) === null || _c === void 0 ? void 0 : _c.b) || 0);
    }
  });
  var layers = [];
  addChildren(layers, psd.children);
  if (!layers.length)
    layers.push({});
  imageResources.layersGroup = layers.map(function(l2) {
    return l2.linkGroup || 0;
  });
  imageResources.layerGroupsEnabledId = layers.map(function(l2) {
    return l2.linkGroupEnabled == false ? 0 : 1;
  });
  writeSection(writer, 1, function() {
    var _loop_1 = function(handler4) {
      var has = handler4.has(imageResources);
      var count = has === false ? 0 : has === true ? 1 : has;
      var _loop_2 = function(i4) {
        writeSignature(writer, "8BIM");
        writeUint16(writer, handler4.key);
        writePascalString(writer, "", 2);
        writeSection(writer, 2, function() {
          return handler4.write(writer, imageResources, i4);
        });
      };
      for (var i3 = 0; i3 < count; i3++) {
        _loop_2(i3);
      }
    };
    for (var _i = 0, resourceHandlers_1 = resourceHandlers; _i < resourceHandlers_1.length; _i++) {
      var handler3 = resourceHandlers_1[_i];
      _loop_1(handler3);
    }
  });
  writeSection(writer, 2, function() {
    writeLayerInfo(writer, layers, psd, globalAlpha, opt);
    writeGlobalLayerMaskInfo(writer, psd.globalLayerMaskInfo);
    writeAdditionalLayerInfo(writer, psd, psd, opt);
  }, void 0, !!opt.psb);
  var channels2 = globalAlpha ? [0, 1, 2, 3] : [0, 1, 2];
  var width = imageData ? imageData.width : psd.width;
  var height = imageData ? imageData.height : psd.height;
  var data3 = { data: new Uint8Array(width * height * 4), width, height };
  writeUint16(
    writer,
    1
    /* Compression.RleCompressed */
  );
  {
    if (imageData)
      data3.data.set(new Uint8Array(imageData.data.buffer, imageData.data.byteOffset, imageData.data.byteLength));
    if (globalAlpha) {
      var size = data3.width * data3.height * 4;
      var p2 = data3.data;
      for (var i2 = 0; i2 < size; i2 += 4) {
        var pa = p2[i2 + 3];
        if (pa != 0 && pa != 255) {
          var a2 = pa / 255;
          var ra = 255 * (1 - a2);
          p2[i2 + 0] = p2[i2 + 0] * a2 + ra;
          p2[i2 + 1] = p2[i2 + 1] * a2 + ra;
          p2[i2 + 2] = p2[i2 + 2] * a2 + ra;
        }
      }
    }
    writeBytes(writer, writeDataRLE(writer.tempBuffer, data3, channels2, !!options.psb));
  }
}
function writeLayerInfo(writer, layers, psd, globalAlpha, options) {
  writeSection(writer, 4, function() {
    var _a;
    writeInt16(writer, globalAlpha ? -layers.length : layers.length);
    var layersData = layers.map(function(l2, i2) {
      return getChannels(writer.tempBuffer, l2, i2 === 0, options);
    });
    var _loop_3 = function(layerData2) {
      var layer = layerData2.layer, top_1 = layerData2.top, left = layerData2.left, bottom = layerData2.bottom, right = layerData2.right, channels2 = layerData2.channels;
      writeInt32(writer, top_1);
      writeInt32(writer, left);
      writeInt32(writer, bottom);
      writeInt32(writer, right);
      writeUint16(writer, channels2.length);
      for (var _e = 0, channels_1 = channels2; _e < channels_1.length; _e++) {
        var c2 = channels_1[_e];
        writeInt16(writer, c2.channelId);
        if (options.psb)
          writeUint32(writer, 0);
        writeUint32(writer, c2.length);
      }
      writeSignature(writer, "8BIM");
      writeSignature(writer, fromBlendMode[layer.blendMode] || "norm");
      writeUint8(writer, Math.round(clamp((_a = layer.opacity) !== null && _a !== void 0 ? _a : 1, 0, 1) * 255));
      writeUint8(writer, layer.clipping ? 1 : 0);
      var flags = 8;
      if (layer.transparencyProtected)
        flags |= 1;
      if (layer.hidden)
        flags |= 2;
      if (layer.vectorMask || layer.sectionDivider && layer.sectionDivider.type !== 0 || layer.adjustment) {
        flags |= 16;
      }
      if (layer.effectsOpen)
        flags |= 32;
      writeUint8(writer, flags);
      writeUint8(writer, 0);
      writeSection(writer, 1, function() {
        writeLayerMaskData(writer, layer, layerData2);
        writeLayerBlendingRanges(writer, layer);
        writePascalString(writer, (layer.name || "").substring(0, 255), 4);
        writeAdditionalLayerInfo(writer, layer, psd, options);
      });
    };
    for (var _i = 0, layersData_1 = layersData; _i < layersData_1.length; _i++) {
      var layerData = layersData_1[_i];
      _loop_3(layerData);
    }
    for (var _b = 0, layersData_2 = layersData; _b < layersData_2.length; _b++) {
      var layerData = layersData_2[_b];
      for (var _c = 0, _d = layerData.channels; _c < _d.length; _c++) {
        var channel = _d[_c];
        writeUint16(writer, channel.compression);
        if (channel.buffer) {
          writeBytes(writer, channel.buffer);
        }
      }
    }
  }, true, options.psb);
}
function writeLayerMaskData(writer, _a, layerData) {
  var mask3 = _a.mask, realMask = _a.realMask;
  writeSection(writer, 1, function() {
    if (!mask3 && !realMask)
      return;
    var params = 0, flags = 0, realFlags = 0;
    if (mask3) {
      if (mask3.userMaskDensity !== void 0)
        params |= 1;
      if (mask3.userMaskFeather !== void 0)
        params |= 2;
      if (mask3.vectorMaskDensity !== void 0)
        params |= 4;
      if (mask3.vectorMaskFeather !== void 0)
        params |= 8;
      if (mask3.disabled)
        flags |= 2;
      if (mask3.positionRelativeToLayer)
        flags |= 1;
      if (mask3.fromVectorData)
        flags |= 8;
      if (params)
        flags |= 16;
    }
    var m2 = layerData.mask || {};
    writeInt32(writer, m2.top || 0);
    writeInt32(writer, m2.left || 0);
    writeInt32(writer, m2.bottom || 0);
    writeInt32(writer, m2.right || 0);
    writeUint8(writer, mask3 && mask3.defaultColor || 0);
    writeUint8(writer, flags);
    if (realMask) {
      if (realMask.disabled)
        realFlags |= 2;
      if (realMask.positionRelativeToLayer)
        realFlags |= 1;
      if (realMask.fromVectorData)
        realFlags |= 8;
      var r = layerData.realMask || {};
      writeUint8(writer, realFlags);
      writeUint8(writer, realMask.defaultColor || 0);
      writeInt32(writer, r.top || 0);
      writeInt32(writer, r.left || 0);
      writeInt32(writer, r.bottom || 0);
      writeInt32(writer, r.right || 0);
    }
    if (params && mask3) {
      writeUint8(writer, params);
      if (mask3.userMaskDensity !== void 0)
        writeUint8(writer, Math.round(mask3.userMaskDensity * 255));
      if (mask3.userMaskFeather !== void 0)
        writeFloat64(writer, mask3.userMaskFeather);
      if (mask3.vectorMaskDensity !== void 0)
        writeUint8(writer, Math.round(mask3.vectorMaskDensity * 255));
      if (mask3.vectorMaskFeather !== void 0)
        writeFloat64(writer, mask3.vectorMaskFeather);
    }
    writeZeros(writer, 2);
  });
}
function writerBlendingRange(writer, range) {
  writeUint8(writer, range[0]);
  writeUint8(writer, range[1]);
  writeUint8(writer, range[2]);
  writeUint8(writer, range[3]);
}
function writeLayerBlendingRanges(writer, layer) {
  writeSection(writer, 1, function() {
    var ranges = layer.blendingRanges;
    if (ranges) {
      writerBlendingRange(writer, ranges.compositeGrayBlendSource);
      writerBlendingRange(writer, ranges.compositeGraphBlendDestinationRange);
      for (var _i = 0, _a = ranges.ranges; _i < _a.length; _i++) {
        var r = _a[_i];
        writerBlendingRange(writer, r.sourceRange);
        writerBlendingRange(writer, r.destRange);
      }
    }
  });
}
function writeGlobalLayerMaskInfo(writer, info) {
  writeSection(writer, 1, function() {
    if (info) {
      writeUint16(writer, info.overlayColorSpace);
      writeUint16(writer, info.colorSpace1);
      writeUint16(writer, info.colorSpace2);
      writeUint16(writer, info.colorSpace3);
      writeUint16(writer, info.colorSpace4);
      writeUint16(writer, info.opacity * 255);
      writeUint8(writer, info.kind);
      writeZeros(writer, 3);
    }
  });
}
function writeAdditionalLayerInfo(writer, target, psd, options) {
  var _loop_4 = function(handler4) {
    var key = handler4.key;
    if (key === "Txt2" && options.invalidateTextLayers)
      return "continue";
    if (key === "vmsk" && options.psb)
      key = "vsms";
    if (handler4.has(target)) {
      var large = options.psb && largeAdditionalInfoKeys.indexOf(key) !== -1;
      var writeTotalLength = key !== "Txt2" && key !== "cinf" && key !== "extn" && key !== "CAI " && key !== "OCIO";
      var fourBytes = key === "Txt2" || key === "luni" || key === "vmsk" || key === "artb" || key === "artd" || key === "vogk" || key === "SoLd" || key === "lnk2" || key === "vscg" || key === "vsms" || key === "GdFl" || key === "lmfx" || key === "lrFX" || key === "cinf" || key === "PlLd" || key === "Anno" || key === "CAI " || key === "OCIO" || key === "GenI" || key === "FEid" || key === "curv" || key === "CgEd" || key === "vibA" || key === "blwh" || key === "grdm";
      writeSignature(writer, large ? "8B64" : "8BIM");
      writeSignature(writer, key);
      writeSection(writer, fourBytes ? 4 : 2, function() {
        handler4.write(writer, target, psd, options);
      }, writeTotalLength, large);
    }
  };
  for (var _i = 0, infoHandlers_1 = infoHandlers; _i < infoHandlers_1.length; _i++) {
    var handler3 = infoHandlers_1[_i];
    _loop_4(handler3);
  }
}
function addChildren(layers, children) {
  if (!children)
    return;
  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
    var c2 = children_1[_i];
    if (c2.children && c2.canvas)
      throw new Error("Invalid layer, cannot have both 'canvas' and 'children' properties");
    if (c2.children && c2.imageData)
      throw new Error("Invalid layer, cannot have both 'imageData' and 'children' properties");
    if (c2.children) {
      layers.push({
        name: "</Layer group>",
        sectionDivider: {
          type: 3
        }
        // blendingRanges: children[0].blendingRanges,
        // nameSource: 'lset',
        // id: layerIds.shift(),
        // protected: {
        // 	transparency: false,
        // 	composite: false,
        // 	position: false,
        // },
        // layerColor: 'red',
        // timestamp: timestamps.shift(),
        // referencePoint: { x: 0, y: 0 },
      });
      addChildren(layers, c2.children);
      layers.push(__assign$2(__assign$2({}, c2), { blendMode: c2.blendMode === "pass through" ? "normal" : c2.blendMode, sectionDivider: {
        type: c2.opened === false ? 2 : 1,
        key: fromBlendMode[c2.blendMode] || "pass",
        subType: 0
      } }));
    } else {
      layers.push(__assign$2({}, c2));
    }
  }
}
function resizeBuffer(writer, size) {
  var newLength = writer.buffer.byteLength;
  do {
    newLength *= 2;
  } while (size > newLength);
  var newBuffer = new ArrayBuffer(newLength);
  var newBytes = new Uint8Array(newBuffer);
  var oldBytes = new Uint8Array(writer.buffer);
  newBytes.set(oldBytes);
  writer.buffer = newBuffer;
  writer.view = new DataView(writer.buffer);
}
function ensureSize(writer, size) {
  if (size > writer.buffer.byteLength) {
    resizeBuffer(writer, size);
  }
}
function addSize(writer, size) {
  var offset = writer.offset;
  ensureSize(writer, writer.offset += size);
  return offset;
}
function createThumbnail(psd) {
  var canvas = createCanvas(10, 10);
  var scale = 1;
  if (psd.width > psd.height) {
    canvas.width = 160;
    canvas.height = Math.floor(psd.height * (canvas.width / psd.width));
    scale = canvas.width / psd.width;
  } else {
    canvas.height = 160;
    canvas.width = Math.floor(psd.width * (canvas.height / psd.height));
    scale = canvas.height / psd.height;
  }
  var context = canvas.getContext("2d");
  context.scale(scale, scale);
  if (psd.imageData) {
    context.drawImage(imageDataToCanvas(psd.imageData), 0, 0);
  } else if (psd.canvas) {
    context.drawImage(psd.canvas, 0, 0);
  }
  return canvas;
}
function getMaskChannels(tempBuffer, layerData, layer, mask3, options, realMask) {
  var top = mask3.top | 0;
  var left = mask3.left | 0;
  var right = mask3.right | 0;
  var bottom = mask3.bottom | 0;
  var _a = getLayerDimentions(mask3), width = _a.width, height = _a.height;
  var imageData = mask3.imageData;
  if (!imageData && mask3.canvas && width && height) {
    imageData = mask3.canvas.getContext("2d").getImageData(0, 0, width, height);
  }
  if (imageData && (imageData.width !== width || imageData.height !== height)) {
    throw new Error("Invalid imageData dimentions");
  }
  right = left + width;
  bottom = top + height;
  var buffer;
  var compression;
  if (!imageData) {
    buffer = new Uint8Array(0);
    compression = 1;
  } else if (options.compress) {
    buffer = writeDataZipWithoutPrediction(imageData, [0]);
    compression = 2;
  } else {
    buffer = writeDataRLE(tempBuffer, imageData, [0], !!options.psb);
    compression = 1;
  }
  layerData.channels.push({ channelId: realMask ? -3 : -2, compression, buffer, length: 2 + buffer.length });
  layerData[realMask ? "realMask" : "mask"] = { top, left, right, bottom };
}
function getChannels(tempBuffer, layer, background, options) {
  var layerData = getLayerChannels(tempBuffer, layer, background, options);
  if (layer.mask)
    getMaskChannels(tempBuffer, layerData, layer, layer.mask, options, false);
  if (layer.realMask)
    getMaskChannels(tempBuffer, layerData, layer, layer.realMask, options, true);
  return layerData;
}
function getLayerDimentions(_a) {
  var _b, _c, _d, _e;
  var canvas = _a.canvas, imageData = _a.imageData;
  var width = (_c = (_b = imageData === null || imageData === void 0 ? void 0 : imageData.width) !== null && _b !== void 0 ? _b : canvas === null || canvas === void 0 ? void 0 : canvas.width) !== null && _c !== void 0 ? _c : 0;
  var height = (_e = (_d = imageData === null || imageData === void 0 ? void 0 : imageData.height) !== null && _d !== void 0 ? _d : canvas === null || canvas === void 0 ? void 0 : canvas.height) !== null && _e !== void 0 ? _e : 0;
  return { width, height };
}
function cropImageData(data3, left, top, width, height) {
  if (data3.data instanceof Uint32Array || data3.data instanceof Uint16Array) {
    throw new Error("imageData has incorrect bit depth");
  }
  var croppedData = createImageData(width, height);
  var srcData = data3.data;
  var dstData = croppedData.data;
  for (var y2 = 0; y2 < height; y2++) {
    for (var x2 = 0; x2 < width; x2++) {
      var src = (x2 + left + (y2 + top) * data3.width) * 4;
      var dst = (x2 + y2 * width) * 4;
      dstData[dst] = srcData[src];
      dstData[dst + 1] = srcData[src + 1];
      dstData[dst + 2] = srcData[src + 2];
      dstData[dst + 3] = srcData[src + 3];
    }
  }
  return croppedData;
}
function getLayerChannels(tempBuffer, layer, background, options) {
  var top = layer.top | 0;
  var left = layer.left | 0;
  var right = layer.right | 0;
  var bottom = layer.bottom | 0;
  var channels2 = [
    { channelId: -1, compression: 0, buffer: void 0, length: 2 },
    { channelId: 0, compression: 0, buffer: void 0, length: 2 },
    { channelId: 1, compression: 0, buffer: void 0, length: 2 },
    { channelId: 2, compression: 0, buffer: void 0, length: 2 }
  ];
  var _b = getLayerDimentions(layer), width = _b.width, height = _b.height;
  if (!(layer.canvas || layer.imageData) || !width || !height) {
    right = left;
    bottom = top;
    return { layer, top, left, right, bottom, channels: channels2 };
  }
  right = left + width;
  bottom = top + height;
  var data3 = layer.imageData || layer.canvas.getContext("2d").getImageData(0, 0, width, height);
  if (options.trimImageData) {
    var trimmed = trimData(data3);
    if (trimmed.left !== 0 || trimmed.top !== 0 || trimmed.right !== data3.width || trimmed.bottom !== data3.height) {
      left += trimmed.left;
      top += trimmed.top;
      right -= data3.width - trimmed.right;
      bottom -= data3.height - trimmed.bottom;
      width = right - left;
      height = bottom - top;
      if (!width || !height)
        return { layer, top, left, right, bottom, channels: channels2 };
      data3 = cropImageData(data3, trimmed.left, trimmed.top, width, height);
    }
  }
  var channelIds = [
    0,
    1,
    2
  ];
  if (!background || options.noBackground || layer.mask || hasAlpha(data3) || RAW_IMAGE_DATA) {
    channelIds.unshift(
      -1
      /* ChannelID.Transparency */
    );
  }
  channels2 = channelIds.map(function(channelId) {
    var offset = offsetForChannel(channelId, false);
    var buffer;
    var compression;
    if (options.compress) {
      buffer = writeDataZipWithoutPrediction(data3, [offset]);
      compression = 2;
    } else {
      buffer = writeDataRLE(tempBuffer, data3, [offset], !!options.psb);
      compression = 1;
    }
    return { channelId, compression, buffer, length: 2 + buffer.length };
  });
  return { layer, top, left, right, bottom, channels: channels2 };
}
function isRowEmpty(_a, y2, left, right) {
  var data3 = _a.data, width = _a.width;
  var start = (y2 * width + left) * 4 + 3 | 0;
  var end = start + (right - left) * 4 | 0;
  for (var i2 = start; i2 < end; i2 = i2 + 4 | 0) {
    if (data3[i2] !== 0) {
      return false;
    }
  }
  return true;
}
function isColEmpty(_a, x2, top, bottom) {
  var data3 = _a.data, width = _a.width;
  var stride = width * 4 | 0;
  var start = top * stride + x2 * 4 + 3 | 0;
  for (var y2 = top, i2 = start; y2 < bottom; y2++, i2 = i2 + stride | 0) {
    if (data3[i2] !== 0) {
      return false;
    }
  }
  return true;
}
function trimData(data3) {
  var top = 0;
  var left = 0;
  var right = data3.width;
  var bottom = data3.height;
  while (top < bottom && isRowEmpty(data3, top, left, right))
    top++;
  while (bottom > top && isRowEmpty(data3, bottom - 1, left, right))
    bottom--;
  while (left < right && isColEmpty(data3, left, top, bottom))
    left++;
  while (right > left && isColEmpty(data3, right - 1, top, bottom))
    right--;
  return { top, left, right, bottom };
}
function writeColor(writer, color) {
  if (!color) {
    writeUint16(
      writer,
      0
      /* ColorSpace.RGB */
    );
    writeZeros(writer, 8);
  } else if ("r" in color) {
    writeUint16(
      writer,
      0
      /* ColorSpace.RGB */
    );
    writeUint16(writer, Math.round(color.r * 257));
    writeUint16(writer, Math.round(color.g * 257));
    writeUint16(writer, Math.round(color.b * 257));
    writeUint16(writer, 0);
  } else if ("fr" in color) {
    writeUint16(
      writer,
      0
      /* ColorSpace.RGB */
    );
    writeUint16(writer, Math.round(color.fr * 255 * 257));
    writeUint16(writer, Math.round(color.fg * 255 * 257));
    writeUint16(writer, Math.round(color.fb * 255 * 257));
    writeUint16(writer, 0);
  } else if ("l" in color) {
    writeUint16(
      writer,
      7
      /* ColorSpace.Lab */
    );
    writeInt16(writer, Math.round(color.l * 1e4));
    writeInt16(writer, Math.round(color.a < 0 ? color.a * 12800 : color.a * 12700));
    writeInt16(writer, Math.round(color.b < 0 ? color.b * 12800 : color.b * 12700));
    writeUint16(writer, 0);
  } else if ("h" in color) {
    writeUint16(
      writer,
      1
      /* ColorSpace.HSB */
    );
    writeUint16(writer, Math.round(color.h * 65535));
    writeUint16(writer, Math.round(color.s * 65535));
    writeUint16(writer, Math.round(color.b * 65535));
    writeUint16(writer, 0);
  } else if ("c" in color) {
    writeUint16(
      writer,
      2
      /* ColorSpace.CMYK */
    );
    writeUint16(writer, Math.round(color.c * 257));
    writeUint16(writer, Math.round(color.m * 257));
    writeUint16(writer, Math.round(color.y * 257));
    writeUint16(writer, Math.round(color.k * 257));
  } else {
    writeUint16(
      writer,
      8
      /* ColorSpace.Grayscale */
    );
    writeUint16(writer, Math.round(color.k * 1e4 / 255));
    writeZeros(writer, 6);
  }
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var ColorMode;
(function(ColorMode2) {
  ColorMode2[ColorMode2["Bitmap"] = 0] = "Bitmap";
  ColorMode2[ColorMode2["Grayscale"] = 1] = "Grayscale";
  ColorMode2[ColorMode2["Indexed"] = 2] = "Indexed";
  ColorMode2[ColorMode2["RGB"] = 3] = "RGB";
  ColorMode2[ColorMode2["CMYK"] = 4] = "CMYK";
  ColorMode2[ColorMode2["Multichannel"] = 7] = "Multichannel";
  ColorMode2[ColorMode2["Duotone"] = 8] = "Duotone";
  ColorMode2[ColorMode2["Lab"] = 9] = "Lab";
})(ColorMode || (ColorMode = {}));
var SectionDividerType;
(function(SectionDividerType2) {
  SectionDividerType2[SectionDividerType2["Other"] = 0] = "Other";
  SectionDividerType2[SectionDividerType2["OpenFolder"] = 1] = "OpenFolder";
  SectionDividerType2[SectionDividerType2["ClosedFolder"] = 2] = "ClosedFolder";
  SectionDividerType2[SectionDividerType2["BoundingSectionDivider"] = 3] = "BoundingSectionDivider";
})(SectionDividerType || (SectionDividerType = {}));
var LayerCompCapturedInfo;
(function(LayerCompCapturedInfo2) {
  LayerCompCapturedInfo2[LayerCompCapturedInfo2["None"] = 0] = "None";
  LayerCompCapturedInfo2[LayerCompCapturedInfo2["Visibility"] = 1] = "Visibility";
  LayerCompCapturedInfo2[LayerCompCapturedInfo2["Position"] = 2] = "Position";
  LayerCompCapturedInfo2[LayerCompCapturedInfo2["Appearance"] = 4] = "Appearance";
})(LayerCompCapturedInfo || (LayerCompCapturedInfo = {}));
function writePsd(psd, options) {
  var writer = createWriter();
  writePsd$1(writer, psd, options);
  return getWriterBuffer(writer);
}
const i18n = createI18n({
  legacy: false,
  locale: "en",
  fallbackLocale: "en",
  messages: { en, zh }
});
let mountContainer = null;
let vueApp = null;
let rootInstance = null;
const IMAGE_NODES = ["LoadImage", "PreviewImage", "SaveImage"];
function isImageNode(node) {
  var _a;
  if (!node || typeof node !== "object") return false;
  const n = node;
  return n.previewMediaType === "image" || n.previewMediaType !== "video" && !!((_a = n.imgs) == null ? void 0 : _a.length);
}
function getImageUrlsFromNode(node) {
  var _a, _b, _c;
  if ((_a = node.images) == null ? void 0 : _a.length) {
    return node.images.map((img) => {
      const params = new URLSearchParams({
        filename: img.filename,
        type: img.type || "input",
        subfolder: img.subfolder || ""
      });
      return api.apiURL(`/view?${params.toString()}`);
    });
  }
  if ((_b = node.imgs) == null ? void 0 : _b.length) {
    return node.imgs.map((img) => img.src).filter(Boolean);
  }
  const imageWidget = (_c = node.widgets) == null ? void 0 : _c.find((w2) => w2.name === "image");
  if (imageWidget == null ? void 0 : imageWidget.value) {
    const value = imageWidget.value;
    const match = value.match(/^(.+?)(?:\s*\[(\w+)\])?$/);
    if (match) {
      const fullPath = match[1];
      const type = match[2] || "input";
      const lastSlash = fullPath.lastIndexOf("/");
      const subfolder = lastSlash > -1 ? fullPath.substring(0, lastSlash) : "";
      const filename = lastSlash > -1 ? fullPath.substring(lastSlash + 1) : fullPath;
      const params = new URLSearchParams({ filename, type, subfolder });
      return [api.apiURL(`/view?${params.toString()}`)];
    }
  }
  return [];
}
async function loadImageElement(url) {
  return new Promise((resolve2, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve2(img);
    img.onerror = reject;
    img.src = url;
  });
}
async function exportNodeAsPSD(node) {
  const imageUrls = getImageUrlsFromNode(node);
  if (imageUrls.length === 0) {
    console.error("[Polotno] No images found in node");
    return;
  }
  try {
    const firstImg = await loadImageElement(imageUrls[0]);
    const psdWidth = firstImg.width;
    const psdHeight = firstImg.height;
    const compositeCanvas = document.createElement("canvas");
    compositeCanvas.width = psdWidth;
    compositeCanvas.height = psdHeight;
    const compositeCtx = compositeCanvas.getContext("2d");
    const layers = [];
    for (let i2 = 0; i2 < imageUrls.length; i2++) {
      const img = i2 === 0 ? firstImg : await loadImageElement(imageUrls[i2]);
      const layerCanvas = document.createElement("canvas");
      layerCanvas.width = psdWidth;
      layerCanvas.height = psdHeight;
      const layerCtx = layerCanvas.getContext("2d");
      layerCtx.drawImage(img, 0, 0, psdWidth, psdHeight);
      compositeCtx.drawImage(img, 0, 0, psdWidth, psdHeight);
      layers.push({
        name: imageUrls.length > 1 ? `Layer ${i2 + 1}` : "Image",
        canvas: layerCanvas,
        left: 0,
        top: 0,
        right: psdWidth,
        bottom: psdHeight
      });
    }
    const psd = {
      width: psdWidth,
      height: psdHeight,
      canvas: compositeCanvas,
      children: layers
    };
    const psdBuffer = writePsd(psd);
    const blob = new Blob([psdBuffer], { type: "application/octet-stream" });
    const downloadUrl = URL.createObjectURL(blob);
    const a2 = document.createElement("a");
    a2.href = downloadUrl;
    a2.download = `comfyui-export-${Date.now()}.psd`;
    document.body.appendChild(a2);
    a2.click();
    document.body.removeChild(a2);
    URL.revokeObjectURL(downloadUrl);
    console.log("[Polotno] PSD exported successfully");
  } catch (error) {
    console.error("[Polotno] Failed to export PSD:", error);
  }
}
function ensurePolotnoInstance() {
  if (rootInstance) {
    return rootInstance;
  }
  mountContainer = document.createElement("div");
  mountContainer.id = "polotno-canvas-editor-root";
  document.body.appendChild(mountContainer);
  vueApp = createApp(_sfc_main);
  vueApp.use(i18n);
  vueApp.use(PrimeVue);
  rootInstance = vueApp.mount(mountContainer);
  rootInstance.setSaveCallback(handleSaveToComfyUI);
  return rootInstance;
}
async function handleSaveToComfyUI(imageDataUrl, node) {
  var _a, _b, _c;
  try {
    const response = await fetch(imageDataUrl);
    const blob = await response.blob();
    const timestamp = Date.now();
    const filename = `polotno-${timestamp}.png`;
    const formData = new FormData();
    formData.append("image", blob, filename);
    formData.append("type", "input");
    formData.append("subfolder", "polotno");
    formData.append("overwrite", "true");
    const uploadResponse = await api.fetchApi("/upload/image", {
      method: "POST",
      body: formData
    });
    if (!uploadResponse.ok) {
      throw new Error("Failed to upload image");
    }
    const result = await uploadResponse.json();
    if (node) {
      const widgetValue = result.subfolder ? `${result.subfolder}/${result.name} [input]` : `${result.name} [input]`;
      node.images = [{
        filename: result.name,
        subfolder: result.subfolder || "",
        type: "input"
      }];
      const imageWidget = (_a = node.widgets) == null ? void 0 : _a.find((w2) => w2.name === "image");
      if (imageWidget) {
        if (((_b = imageWidget.options) == null ? void 0 : _b.values) && !imageWidget.options.values.includes(widgetValue)) {
          imageWidget.options.values.push(widgetValue);
        }
        imageWidget.value = widgetValue;
        const anyNode = node;
        if (anyNode.widgets_values && anyNode.widgets) {
          const widgetIndex = anyNode.widgets.findIndex((w2) => w2.name === "image");
          if (widgetIndex >= 0) {
            anyNode.widgets_values[widgetIndex] = widgetValue;
          }
        }
        const propsNode = node;
        if (propsNode.properties) {
          propsNode.properties["image"] = widgetValue;
        }
        (_c = imageWidget.callback) == null ? void 0 : _c.call(imageWidget, widgetValue);
      }
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src = imageDataUrl;
      await new Promise((resolve2) => {
        img.onload = resolve2;
      });
      node.imgs = [img];
      app.graph.setDirtyCanvas(true, true);
    }
    console.log("[Polotno] Image saved successfully:", result);
  } catch (error) {
    console.error("[Polotno] Failed to save image:", error);
    throw error;
  }
}
function openPolotnoEditor(node) {
  const instance = ensurePolotnoInstance();
  if (node) {
    const imageUrls = getImageUrlsFromNode(node);
    if (imageUrls.length > 0) {
      instance.loadImages(imageUrls, node);
    } else {
      instance.openNew(node);
    }
  } else {
    instance.openNew();
  }
}
app.registerExtension({
  name: "ComfyUI.PolotnoCanvasEditor",
  settings: [
    {
      id: "Comfy.PolotnoCanvasEditor.ApiKey",
      category: ["Polotno Canvas Editor", "API Key"],
      name: "Polotno API Key",
      tooltip: "Your Polotno API key. Get one from https://polotno.com. Leave empty for open-source/non-profit use.",
      type: "text",
      defaultValue: ""
    },
    {
      id: "Comfy.PolotnoCanvasEditor.DefaultWidth",
      category: ["Polotno Canvas Editor", "Canvas"],
      name: "Default Canvas Width",
      tooltip: "Default width for new canvas",
      type: "number",
      defaultValue: 1024
    },
    {
      id: "Comfy.PolotnoCanvasEditor.DefaultHeight",
      category: ["Polotno Canvas Editor", "Canvas"],
      name: "Default Canvas Height",
      tooltip: "Default height for new canvas",
      type: "number",
      defaultValue: 1024
    }
  ],
  setup() {
    var _a;
    const { ComfyButton } = window.comfyAPI.button;
    const button = new ComfyButton({
      icon: "palette",
      tooltip: "Polotno Canvas Editor",
      content: "Polotno Canvas",
      action: () => openPolotnoEditor()
    });
    (_a = app.menu) == null ? void 0 : _a.settingsGroup.append(button);
  },
  getNodeMenuItems(node) {
    var _a;
    const typedNode = node;
    const nodeClass = (_a = typedNode == null ? void 0 : typedNode.constructor) == null ? void 0 : _a.comfyClass;
    if (!nodeClass || !IMAGE_NODES.includes(nodeClass)) {
      if (!isImageNode(node)) {
        return [];
      }
    }
    const imageUrls = getImageUrlsFromNode(node);
    const count = imageUrls.length;
    return [
      null,
      {
        content: count > 1 ? `Open in Polotno (${count} as layers)` : "Open in Polotno Canvas Editor",
        callback: () => {
          openPolotnoEditor(node);
        }
      },
      {
        content: count > 1 ? `Export as PSD (${count} layers)` : "Export as PSD",
        callback: () => {
          exportNodeAsPSD(node);
        }
      }
    ];
  }
});
export {
  exportNodeAsPSD,
  openPolotnoEditor
};
//# sourceMappingURL=main.js.map
